<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WB&#39;s Root</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-02T07:43:23.189Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WB</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Resources 杂记</title>
    <link href="http://yoursite.com/2018/06/29/Android/Android%20%E8%B5%84%E6%BA%90/Resources%E6%9D%82%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/29/Android/Android 资源/Resources杂记/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T07:43:23.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>Base resource <strong>directories</strong> supported inside project <code>res/</code> directory.</p><ul><li>animator/</li><li>anim/</li><li>color/</li><li>drawable/</li><li>mipmap/</li><li>layout/</li><li>menu/</li><li>raw/</li><li>values/</li><li>xml/</li><li>font/</li></ul></li><li><p>Whereas XML resource files in other <code>res/</code> subdirectories define a single resource based on the XML filename, files in the <code>values/</code>directory describe multiple resources. For a file in this directory, each child of the <code>&lt;resources&gt;</code> element defines a single resource. For example, a <code>&lt;string&gt;</code> element creates an <code>R.string</code> resource and a <code>&lt;color&gt;</code> element creates an <code>R.color</code> resource.</p><p>Because each resource is defined with its own XML element, you can name the file whatever you want and place different resource types in one file. However, for clarity, you might want to place unique resource types in different files.</p></li></ul><h3 id="Alternative-Resources"><a href="#Alternative-Resources" class="headerlink" title="Alternative Resources"></a>Alternative Resources</h3><h4 id="provide-alternative-resources"><a href="#provide-alternative-resources" class="headerlink" title="provide alternative resources"></a>provide alternative resources</h4><ul><li><p><strong>Directories</strong> of configuration-specific <strong>alternatives</strong> for a set of resources are in the following form:  <code>&lt;resources_name&gt;-&lt;config_qualifier&gt;</code></p></li><li><p>Always provide <strong>default</strong> resources for the resources your app needs to perform properly. Then create alternative resources for specific device configurations using the configuration qualifiers.</p><blockquote><p>除了针对不同密度的drawable资源不需要提供默认资源之外，其他资源都应该提供default 资源，否则系统可能因找不到对应的资源而抛出异常，使得app 崩溃。一般的做法是选择某个配置的资源作为default 资源，放置在不带qualifier 的资源目录下，比如将竖屏的layout 文件放在 <code>layout/</code>目录下，再将横屏的layout 文件放在<code>layout-land</code>目录下。</p><p>而对于针对不同密度的drawable，系统在找不到对应设备密度的资源时，会选择最佳匹配的drawable 资源，并根据需要进行缩放。</p></blockquote></li></ul><h4 id="匹配资源"><a href="#匹配资源" class="headerlink" title="匹配资源"></a>匹配资源</h4><ul><li><p><a href="https://developer.android.com/guide/topics/resources/providing-resources.html#BestMatch" target="_blank" rel="noopener">How Android Finds the Best-matching Resource</a></p><blockquote><p>Though this procedure is executed for each resource requested, the system further optimizes some aspects. One such optimization is that once the device configuration is known, it might eliminate alternative resources that can never match. For example, if the configuration language is English (“en”), then any resource directory that has a language qualifier set to something other than English is never included in the pool of resources checked (though a resource directory <em>without</em> the language qualifier is still included).</p></blockquote><blockquote><p>If the qualifier in question is <strong>screen pixel density</strong>, Android selects the option that most closely matches the device screen density. In general, Android prefers scaling down a larger original image to scaling up a smaller original image.</p></blockquote><blockquote><p>When selecting resources based on the <strong>screen size qualifiers</strong>, the system uses resources designed for a screen smaller than the current screen if there are no resources that better match (for example, a large-size screen uses normal-size screen resources if necessary). However, if the only available resources are <em>larger</em> than the current screen, the system <strong>doesn’t</strong> use them and your app will crash if no other resources match the device configuration (for example, if all layout resources are tagged with the <code>xlarge</code> qualifier, but the device is a normal-size screen).</p></blockquote></li><li><p>Some device configurations can change during <strong>runtime</strong> (such as screen orientation, keyboard availability, and language). When such a change occurs, Android <strong>restarts</strong> the running <code>Activity</code>(<code>onDestroy()</code> is called, followed by <code>onCreate()</code>). The restart behavior is designed to help your application adapt to new configurations by automatically reloading your application with alternative resources that match the new device configuration.</p></li><li><p><strong>Remember:</strong> When you declare your activity to handle a configuration change, you are responsible for resetting any elements for which you provide alternatives.</p><p>If you don’t need to update your application based on these configuration changes, you can instead <em>not</em> implement <code>onConfigurationChanged()</code>. In which case, all of the resources used before the configuration change are <strong>still</strong> used and you’ve <strong>only</strong> avoided the restart of your activity. </p><blockquote><p>比如显示<code>string</code>资源的<code>TextView</code>，需要重新设置<code>string</code>资源，否则不会随着语言的切换而自动切换。</p></blockquote></li><li><p>Starting with Android 7.0 (API level 24), Android exposes the <code>LocaleList.getDefault()</code> API that lets apps directly query the list of languages a user has specified. This API allows you to create more sophisticated app behavior and better-optimized display of content. For example, Search can show results in multiple languages based on user’s settings. </p></li><li><p><strong>Formatters</strong> 使用<code>Locale</code>格式化字符串</p><p> Up through Android 6.0 (API level 23), Android supported only one or two locales for many common languages (en, es, ar, fr, ru). Because there were only a few variants of each language, apps could get away with storing some numbers and dates as hard coded strings in resource files. However, with Android’s broadened set of supported locales, there can be significant differences in formats for dates, times, currencies, and similar information even within a single locale. Hard-coding your formats can produce a confusing experience for end users. Therefore, when developing for Android 7.0 or higher versions, make sure to use formatters instead of hard coding numbers and date strings.</p><p> For example, Android 7.0 and higher includes support for 27 Arabic locales. These locales can share most resources, but some prefer ASCII digits, while others prefer native digits. For example, when you want to create a sentence with a digit variable, such as “Choose a 4 digit pin”, use formatters as shown below:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format(locale, <span class="string">"Choose a %d-digit PIN"</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="Drawable"><a href="#Drawable" class="headerlink" title="Drawable"></a>Drawable</h3><ul><li><p><strong>bitmap</strong> </p><p>可用于设置<code>Drawable</code>的重复模式，比如平铺</p></li><li><p><strong>nine-patch</strong></p><p>.9图</p></li><li><p><strong>layer-list</strong> </p><p>多个item按照定义的顺序层叠，最后定义的item在最顶层，可对item设置偏移值，item 里面可以有bitmap</p></li><li><p><strong>state-list</strong></p><ul><li>标签是<code>&lt;selector&gt;</code></li><li>描述<code>View</code>在不同<code>state</code>下的<code>Drawable</code></li></ul></li><li><p><strong>lever-list</strong> </p><p>像是<code>state-list</code> 的可自定义版本，<code>minLevel</code>和<code>maxLevel</code>属性类比<code>state</code>，通过给<code>View</code>设置<code>level</code>可以应用不同的<code>Drawable</code></p></li><li><p><strong>transition</strong></p><p>通过渐变（alpha）动画渐变切换两个item指向的drawable，一般用于开关或<code>CheckBox</code></p></li><li><p><strong>inset</strong></p><p>用来在<code>Drawable</code>周围留边距，<code>View</code>的<code>padding</code>是不影响background的，所以这可以用来处理background</p></li><li><p><strong>clip</strong></p><p>可以用于裁剪<code>Drawable</code>，实现类似进度条的效果，不过只能在水平和竖直方向裁剪，圆的就不行了。通过level动态控制裁剪多少。</p></li><li><p><strong>scale</strong> </p><p>类似<code>clip</code>，可用于缩放<code>Drawable</code>，通过level动态控制缩放比例</p></li><li><p><strong>shape</strong></p><p>描述以矩形、圆形、线段、环形几何图形为基础的<code>Drawable</code></p></li></ul><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><ul><li><p>通过使用<strong>别名</strong>来避免将同一份资源放置到具有不同qualifier 类型的资源目录（比如图片资源，可减少apk 大小；而layout 资源则可避免重复代码）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">drawable</span> <span class="attr">name</span>=<span class="string">"icon"</span>&gt;</span>@drawable/icon_ca<span class="tag">&lt;/<span class="name">drawable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.android.com/guide/topics/resources/complex-xml-resources.html" target="_blank" rel="noopener">Inline Complex XML Resources</a> </p><p>对于组合式的xml 资源，可以用内联的方式定义在一个文件中，避免创建多个文件。不过对于那些需要针对不同qualifier 定义的资源，比如<code>drawable-v21/</code> 和<code>drawable/</code>不知道有什么方法也搞一搞。</p></li><li><p><code>&lt;include&gt;</code>声明的属性都会覆盖被引用的布局文件的<code>root view</code>，包括<code>android:id</code></p><blockquote><p><strong>Caution:</strong> If you want to override layout attributes using the <code>&lt;include&gt;</code> tag, you must override both <code>android:layout_height</code> and<code>android:layout_width</code> in order for other layout attributes to take effect.</p></blockquote><p><code>&lt;merge&gt;</code> is an alternative root element that is not drawn in the layout hierarchy. Using this as the root element is useful when you know that this layout will be placed into a layout that already contains the appropriate parent View to contain the children of the <code>&lt;merge&gt;</code> element. This is particularly useful when you plan to include this layout in another layout file using <a href="https://developer.android.com/guide/topics/resources/layout-resource.html#include-element" target="_blank" rel="noopener"><code>&lt;include&gt;</code></a> and this layout doesn’t require a different <code>ViewGroup</code> container.</p></li></ul><ul><li><p><a href="https://developer.android.com/guide/topics/resources/string-resource.html#plurals-element" target="_blank" rel="noopener">Quantity Strings (Plurals 复数字符串资源)</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plurals</span> <span class="attr">name</span>=<span class="string">"numberOfSongsAvailable"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">             As a developer, you should always supply "one" and "other"</span></span><br><span class="line"><span class="comment">             strings. Your translators will know which strings are actually</span></span><br><span class="line"><span class="comment">             needed for their language. Always include %d in "one" because</span></span><br><span class="line"><span class="comment">             translators will need to use %d for languages where "one"</span></span><br><span class="line"><span class="comment">             doesn't mean 1 (as explained above).</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">quantity</span>=<span class="string">"one"</span>&gt;</span>%d song found.<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">quantity</span>=<span class="string">"other"</span>&gt;</span>%d songs found.<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plurals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.android.com/guide/topics/resources/string-resource.html#FormattingAndStyling" target="_blank" rel="noopener">Formatting and Styling (格式化和带样式的字符串资源)</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      关于Android中的资源的碎片笔记。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Handler消息处理机制</title>
    <link href="http://yoursite.com/2018/06/29/Android/Handler%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/06/29/Android/Handler消息处理机制/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T05:16:26.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息处理机制"><a href="#消息处理机制" class="headerlink" title="消息处理机制"></a>消息处理机制</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>Android是响应式的操作系统，系统需要对用户的触摸操作、时间的变化、光线的变化等事件做出<strong><em>及时</em></strong>响应，比如响应点击、激活闹钟、自动调节屏幕亮度等。这符合生产者与消费者模型。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>满足这个需求，至少需要解决以下两个问题：</p><ol><li>生产者生产的消息能被<strong>加入消息队列</strong>进行处理。并且，消息往往需要指定其被处理的时间。</li><li>消费者要能<strong>及时处理消息</strong>。多线程（多进程也同理，但不在本文讨论范围内）是解决此问题的一种方式，也是Android系统采用的方式。</li></ol><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>Handler 消息处理机制为了解决这两个问题，提供了以下两个功能：</p><ol><li>能在指定时间处理消息。以下简称<strong><em>功能A</em></strong>。</li><li>能将消息发送到指定线程处理。以下简称<strong><em>功能B</em></strong>。</li></ol><blockquote><p>There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>在Handler消息机制中，有以下四个角色：</p><ol><li><code>Message</code>是消息，或者称为事件。</li><li><code>MessageQueue</code>是消息队列。</li><li><code>Handler</code>提供了将消息入列的方法，充当生产者的角色。</li><li><code>Looper</code>会从消息队列中提取消息，充当消费者的角色。实际上<code>Looper</code>提取消息后，是调用<code>Message.target.dispatchMessage(Message msg)</code>来处理消息，而这里的<code>target</code>就是<code>Handler</code>类型，所以从这个角度来看，<code>Handler</code>不仅是生产者，也是真正的消费者。</li></ol><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><h4 id="功能A"><a href="#功能A" class="headerlink" title="功能A"></a>功能A</h4><p>功能A的实现需要<code>Message</code>、<code>MessageQueue</code>、<code>Handler</code>三者的配合。</p><h5 id="生产消息"><a href="#生产消息" class="headerlink" title="生产消息"></a>生产消息</h5><p><code>Handler</code>提供了一系列<code>send</code>和<code>post</code>方法来发送消息，并指定消息的处理时机。这些方法最终都会调用<code>enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)</code>，该方法做了以下两件事：</p><ol><li><p>将<code>Message.target</code>指向<code>Handler</code>自身。此操作将消息与处理者绑定在一起。</p></li><li><p>调用<code>MessageQueue.enqueueMessage(Message msg, long when)</code>来将消息入列。这里<code>when</code>参数正是消息的处理时间。</p><blockquote><p><code>Handler.sendMessageAtFrontOfQueue(Message msg)</code>方法将<code>when</code>赋值为0。</p></blockquote><blockquote><p>The time-base is <code>android.os.SystemClock.uptimeMillis()</code>.</p></blockquote></li></ol><h5 id="消息入列"><a href="#消息入列" class="headerlink" title="消息入列"></a>消息入列</h5><p>实际上，Handler消息处理机制并未提供在<strong>准确</strong>的时间处理消息的机制。而是折衷地采取了以下方案：</p><ul><li>在消息入列时，根据<code>Message.when</code>将消息插入到队列中合适的位置，使得队列中的消息总是<strong>按照处理时间排序</strong>的。</li><li>在消费消息时，总是从<strong>队列头部</strong>提取消息，并检查是否还未到达消息的处理时间，若是则不消费消息继续等待；否则消费消息。</li></ul><p>因此实际效果是<strong>不早于</strong>消息指定的时间来处理消息。并且，已经入列的消息的执行顺序在入列的时候就已经确定了，消费消息的时候不会改变顺序。</p><p><code>MessageQueue</code>采用<strong>链表</strong>来存储消息，<code>enqueueMessage(Message msg, long when)</code>的实现中会根据<code>Message.when</code>将消息插入到链表中的正确位置。</p><h4 id="功能B"><a href="#功能B" class="headerlink" title="功能B"></a>功能B</h4><p>功能B的实现依赖于<code>Looper</code>，<code>MessageQueue</code>和<code>Handler</code>的配合。</p><ul><li>每个线程可以绑定<strong>不超过</strong>一对<code>Looper</code>和<code>MessageQueue</code>（可以没有，那就是常规的Java线程，不具备Handler消息处理机制）。</li><li>每个<code>Handler</code>也持有<strong>一对</strong><code>Looper</code>和<code>MessageQueue</code>，一旦<code>Handler</code>实例被构造，只能用于向其持有的队列添加消息。</li><li>在线程中启动绑定的<code>Looper</code>，在队列中监听并处理消息。</li></ul><h5 id="创建线程独立的消息队列"><a href="#创建线程独立的消息队列" class="headerlink" title="创建线程独立的消息队列"></a>创建线程独立的消息队列</h5><p>让一个线程具备消息处理机制，需要完成两件事：</p><ol><li><p>创建<code>Looper</code>和<code>MessageQueue</code>。</p><p>在线程中调用<strong>静态</strong>方法<code>Looper.prepare()</code>，该方法会创建一个<code>Looper</code>对象，该<code>Looper</code>创建一个<code>MessageQueue</code>并持有它（<code>Looper</code>也会持有当前<code>Thread</code>对象）。</p><blockquote><p>Android使用<code>ThreadLocal</code>来保证一个线程不能绑定超过一个<code>Looper</code>。</p></blockquote></li><li><p>在绑定的线程中调用<code>Looper</code>的静态方法<code>loop()</code>让<code>Looper</code>开始监听消息。<code>loop()</code>方法会无限循环调用<code>MessageQueue.next()</code>方法来将消息出列并处理。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意：由于<code>loop()</code>方法是一个死循环，调用<code>loop()</code>之后的语句在其跳出循环之前不会被执行。这也是为什么经常看到以下写法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * This is a typical example of the implementation of a Looper thread,</span></span><br><span class="line"><span class="comment">  * using the separation of &#123;<span class="doctag">@link</span> #prepare&#125; and &#123;<span class="doctag">@link</span> #loop&#125; to create an</span></span><br><span class="line"><span class="comment">  * initial Handler to communicate with the Looper.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// process incoming messages here</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="消息出列"><a href="#消息出列" class="headerlink" title="消息出列"></a>消息出列</h5><p><code>MessageQueue.next()</code>方法会返回下一个<strong>达到执行时间</strong>的消息。实现这个需求有以下方案：</p><ol><li>无限循环访问消息队列对其进行监听，并判断队头是否有到时间的消息。缺点是显而易见的，该线程将始终处于忙碌状态，造成对CPU等资源的浪费。</li><li>挂起线程，直到有可处理的消息。<code>sleep()</code>和<code>wait()</code>都能实现挂起线程。关键在于线程需要在以下两种情况苏醒或被唤醒：<ul><li>到达队头消息处理时间。<code>sleep()</code>和<code>wait()</code>都可以传参设置挂起的时长，做到主动苏醒。</li><li>有新的消息被加入到队列头部，而且该消息已到达可被处理的时间。只有<code>wait()</code>可以做到被<code>notify()</code>唤醒。</li></ul></li></ol><p>在<code>MessageQueue.next()</code>中，通过调用native 方法<code>nativePollOnce(long ptr, int timeoutMillis)</code>来完成挂起线程指定时长，与<code>wait()</code>作用相同。<code>MessageQueue.enqueueMessage(Message msg, long when)</code>将消息入列时，如果是加到队头，会调用native 方法<code>nativeWake(long ptr)</code>来唤醒线程，被唤醒的线程会去检查队列中是否有可被处理的消息，否则重新挂起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//将线程挂起</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><ul><li><p>为什么<code>Looper</code>与线程是一对一的关系，而与<code>Handler</code>是一对多的关系？</p><p>作为消息发送工具，<code>Handler</code>只需一个即可。但是<code>Handler</code>同时还具有消费者的身份，这使其可处理具体的业务（通过复写其<code>void handleMessage(Message msg)</code>方法），因此为不同的业务分配不同的<code>Handler</code>有了充分的理由。</p></li><li><p>为什么消息只会被对应的<code>Handler</code>处理？</p><p>因为<code>Message.target</code>指定了对应的<code>Handler</code>。</p></li><li><p><code>Handler</code>如何实现删除消息时，只删除由其加入队列的消息？</p><p>实际上，<code>Handler</code>并不负责删除消息的细节，它会调用<code>MessageQueue</code>的<code>remove</code>方法来删除消息，并将自身作为参数传递给<code>remove</code>方法。<code>MessageQueue</code>会遍历链表，删除满足条件的消息。其中一个条件就是<code>Message.target</code>为参数中<code>Handler</code>。</p></li><li><p>为什么使用Handler不用加锁？</p><p>因为真正执行消息入列的<code>MessageQueue</code>被加了锁。</p></li><li><p>开发者无需对<code>Message</code>调用<code>recycle()</code>方法，因为<code>Looper</code>每处理完一个<code>Message</code>，都会调用<code>Message.recycleUnchecked()</code>来回收。</p></li><li><p>主线程调用<code>Looper.loop()</code>，并且当其队列为空被挂起之后，主线程如何被唤醒？</p><ul><li><p>主线程并不是唯一的线程，还有Binder线程等其他线程存在，这些线程可向主线程的队列添加消息。</p></li><li><p>调试发现，<code>nativePollOnce(long ptr, int timeoutMillis)</code>这个本地方法的作用不只是简单地挂起线程。在主线程的队列为空调用这个方法被阻塞之后，点击一下屏幕，发现主线程的调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">at android.view.InputEventReceiver.dispatchInputEvent(InputEventReceiver.java:185)</span><br><span class="line">at android.os.MessageQueue.nativePollOnce(MessageQueue.java:-1)</span><br><span class="line">at android.os.MessageQueue.next(MessageQueue.java:325)</span><br><span class="line">at android.os.Looper.loop(Looper.java:142)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:6541)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:-1)</span><br><span class="line">at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767)</span><br></pre></td></tr></table></figure><p>在<code>nativePollOnce(long ptr, int timeoutMillis)</code>里调用了<code>InputEventReceiver.dispatchInputEvent(InputEventReceiver.java:185)</code>，看源码可以发现该方法有如下注释，这是一个被native 代码调用的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchInputEvent</span><span class="params">(<span class="keyword">int</span> seq, InputEvent event)</span></span></span><br></pre></td></tr></table></figure><p>由此可推测，调用<code>nativePollOnce()</code>方法挂起主线程之后，当有一些事件到来时，native层会唤醒主线程。具体的阻塞和唤醒机制，就是epoll 机制了。</p></li></ul></li></ul><h3 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h3><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>这个类的实例可以用来存储或获取<strong>一个</strong>与线程相关的变量。在不同的线程调用同一个对象的<code>TheadLocal.set()</code>和<code>ThreadLocal.get()</code>可以设置和访问<strong>对应线程</strong>的变量。原理上是隐藏了对<code>Thread.currentThread()</code>的调用，变量实际上是被<code>Thread</code>对象持有的。</p><h4 id="Synchronization-barrier-amp-Asynchronous-message"><a href="#Synchronization-barrier-amp-Asynchronous-message" class="headerlink" title="Synchronization barrier &amp; Asynchronous message"></a>Synchronization barrier &amp; Asynchronous message</h4><blockquote><p>Sets whether the message is asynchronous, meaning that it is not subject to {@link Looper} synchronization barriers.<br>Certain operations, such as view invalidation, may introduce synchronization barriers into the {@link Looper}’s message queue to <em>prevent <strong>subsequent messages</strong> from being delivered <strong>until some condition is met</strong></em>.  In the case of view invalidation, messages which are posted after a call to {@link android.view.View#invalidate} are suspended by means of a synchronization barrier until the next frame is ready to be drawn.  The synchronization barrier ensures that the invalidation request is completely handled before resuming.<br>Asynchronous messages are exempt from synchronization barriers. They typically represent <strong>interrupts</strong>, <strong>input events</strong>, and other signals that must be handled independently even while other work has been suspended.<br>Note that asynchronous messages may be delivered <strong>out of order with respect to synchronous messages</strong> although they are always delivered <strong>in order among themselves</strong>. If the relative order of these messages matters then they probably should not be asynchronous in the first place.  Use with caution.</p></blockquote><blockquote><p>Message processing occurs as usual until the message queue encounters the synchronization barrier that has been posted.  When the barrier is encountered, later synchronous messages in the queue are stalled (prevented from being executed) until the barrier is released by calling {@link #removeSyncBarrier} and specifying the token that identifies the synchronization barrier.<br>This method is used to immediately postpone execution of all subsequently posted synchronous messages until a condition is met that releases the barrier. Asynchronous messages (see {@link Message#isAsynchronous} are exempt from the barrier and continue to be processed as usual.</p></blockquote><h5 id="同步消息屏障"><a href="#同步消息屏障" class="headerlink" title="同步消息屏障"></a>同步消息屏障</h5><p>消息队列中的消息会根据时间按序被处理，这些消息称为<strong>同步消息</strong>。有时需要延迟处理消息，直到达到某个条件。Synchronization Barrier（以下简称Sync Barrier），翻译为同步消息屏障或同步分隔栏等，提供了这样的功能。</p><ul><li>Sync Barrier的本质是一个<code>Message</code>，只是<code>target</code>为<code>null</code>，使用的时候，像普通消息一样，将其添加到消息队列即可。其作用是作为队列中一个的标志，标志着其<strong>后续的同步消息</strong>暂不被处理。其本身不需要被处理。</li><li>Sync Barrier的入列规则与同步消息相同，会根据<code>Message.when</code>排序。</li></ul><blockquote><p>系统对添加Sync Barriers 的方法<code>postSyncBarrier()</code>添加了{@Hide}注解，而<code>Handler</code>会为其发送的所有消息指定<code>target</code>，因此App 开发者无法采用常规方式添加同步消息屏障。</p></blockquote><h5 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h5><p>Sync Barriers会阻止同步消息的处理，对于一些不需要被Sync Barriers阻止的消息，比如输入事件，Android 引入了异步消息的概念，来避免受制于Sync Barriers，使其能被正常执行。</p><ul><li>异步消息也是<code>Message</code>，<code>Message.setAsynchronous(boolean async)</code>可消息设置一个消息是否为异步消息。</li><li>异步消息的入列规则与同步消息相同，会根据<code>Message.when</code>排序。因此异步消息之间会按序被执行。并且，当不存在Sync Barrier时，异步消息与同步消息没有差别。</li></ul><h5 id="延迟处理消息"><a href="#延迟处理消息" class="headerlink" title="延迟处理消息"></a>延迟处理消息</h5><p><code>MessageQueue.next()</code>在提取下一个处理的消息时，分以下两种情况：</p><ul><li><p>如果队头是Sync Barrier，会遍历队列寻找第一个异步消息进行处理。</p><blockquote><p>Sync Barrier本身不会被该方法出列。需要调用<code>MessageQueue.removeSyncBarrier(int token)</code>才能将Sync Barrier移除。</p></blockquote></li></ul><ul><li>如果队头不是Sync Barrier，会处理队头消息。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">Message msg = mMessages;</span><br><span class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理消息或者挂起线程...</span></span><br></pre></td></tr></table></figure><h4 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h4><blockquote><p>Callback interface for discovering when a thread is going to block waiting for more messages.</p></blockquote><p><code>MessageQueue.next()</code>如果没找到可以处理的消息，会遍历<code>MessageQueue.mIdleHandlers</code>调用<code>IdleHandler.queueIdle()</code>来执行一些”空闲“时处理的工作。</p>]]></content>
    
    <summary type="html">
    
      Handler消息处理机制解析。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Permission</title>
    <link href="http://yoursite.com/2018/06/29/Android/Permissions/"/>
    <id>http://yoursite.com/2018/06/29/Android/Permissions/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T08:14:25.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Permissions"><a href="#Permissions" class="headerlink" title="Permissions"></a>Permissions</h2><h3 id="Requesting-permission"><a href="#Requesting-permission" class="headerlink" title="Requesting permission"></a>Requesting permission</h3><ul><li><p>清单文件中声明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.android.app.myapp"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.RECEIVE_SMS"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.android.com/training/permissions/requesting.html" target="_blank" rel="noopener">动态申请</a></p><blockquote><p>注意：</p><ol><li><p>动态授权的时候尽管用户是授权给整个permission group，但是只有所申请的权限会被授予，如果需要使用该permission group中的其他权限，仍然需要再次申请（但是系统不会再次要求用户授权，而是马上回调授权的回调方法<code>onRequestPermissionsResult()</code>）。</p></li><li><p>permission group可能随着系统版本不同而不同，所以申请授权时不应该依赖permission group中的其他权限。</p></li><li><p>在授权框上，用户可选择禁止app再次请求该权限，在这种情况下，此后app再调用<code>requestPermissions()</code> ，系统不会弹框要求用户授权，而是马上回调授权的回调方法<code>onRequestPermissionsResult()</code>来通知授权被拒绝。</p></li><li><p>You can also use the adb -g option to grant all permissions automatically when installing an app on an emulator or test device:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    $ adb shell install -g MyApp.apk</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote></li><li><p>There are a couple of permissions that don’t behave like normal and dangerous permissions. <a href="https://developer.android.com/reference/android/Manifest.permission.html#SYSTEM_ALERT_WINDOW" target="_blank" rel="noopener">SYSTEM_ALERT_WINDOW</a> and <a href="https://developer.android.com/reference/android/Manifest.permission.html#WRITE_SETTINGS" target="_blank" rel="noopener">WRITE_SETTINGS</a> are particularly sensitive, so most apps should not use them. If an app needs one of these permissions, it must declare the permission in the manifest, <em>and</em> <strong>send an intent</strong> requesting the user’s authorization. The system responds to the intent by showing a detailed management screen to the user.</p><p>For details on how to request these permissions, see the <code>SYSTEM_ALERT_WINDOW</code> and <code>WRITE_SETTINGS</code> reference entries.</p></li></ul><h3 id="Permission"><a href="#Permission" class="headerlink" title="Permission"></a>Permission</h3><h4 id="Permission-attributes"><a href="#Permission-attributes" class="headerlink" title="Permission attributes"></a>Permission attributes</h4><ul><li><p>System permissions are divided into several <a href="https://developer.android.com/guide/topics/manifest/permission-element.html#plevel" target="_blank" rel="noopener"><strong>protection levels</strong></a>. The two most important protection levels to know about are <a href="https://developer.android.com/guide/topics/permissions/normal-permissions.html" target="_blank" rel="noopener">normal</a> and dangerous permissions.</p><blockquote><p>个人注解：</p><p><code>normal</code>权限其实就是安装app时列出来的权限要求。</p><p><code>dangerous</code>权限从6.0开始需要动态授权。</p><p>另外有传言，在Google play 或者app 安装页面，<code>normal</code>权限可能被折叠（如果权限比较多的话），<code>dangerous</code>则不会。</p></blockquote></li><li><p>Any permission can belong to a <a href="https://developer.android.com/reference/android/Manifest.permission_group.html" target="_blank" rel="noopener"><strong>permission group</strong></a>. </p><blockquote><p>个人注解：</p><p>6.0及以上系统，当app对某个permission发起授权请求，系统以permission group为单位，向用户提供授权选项。并且当下次对同一个group中的其他permission发起授权请求时，系统自动授予权限。</p></blockquote></li></ul><h4 id="Define-custom-permissions"><a href="#Define-custom-permissions" class="headerlink" title="Define custom permissions"></a><a href="https://developer.android.com/guide/topics/permissions/defining.html#defining" target="_blank" rel="noopener">Define custom permissions</a></h4><ol><li>定义权限</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.example.myapp"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"com.example.myapp.permission.DEADLY_ACTIVITY"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/permlab_deadlyActivity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:description</span>=<span class="string">"@string/permdesc_deadlyActivity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:permissionGroup</span>=<span class="string">"android.permission-group.COST_MONEY"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:protectionLevel</span>=<span class="string">"dangerous"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>由于四大组件是app的入口，app的自定义权限是通过限制四大组件的调用来起保护作用的。</p><p>通过在四大组件的声明标签中添加<code>android:permission</code>属性可以声明调用该组件所需要的权限。（动态注册和发送广播时也可以声明必须的权限）（<code>ContentProvider</code>通过<code>android:readPermission</code>和<code>android:writePermission</code>分别控制读写权限）</p></li></ol><h4 id="uid及其权限作用"><a href="#uid及其权限作用" class="headerlink" title="uid及其权限作用"></a><a href="https://developer.android.com/guide/topics/permissions/defining.html#userid" target="_blank" rel="noopener">uid及其权限作用</a></h4><ul><li><p>通过在<code>manifest</code>标签中声明<code>sharedUserId</code>属性，并指定相同的属性值，拥有<strong>相同签名</strong>的多个app在同一台设备上，会被分配相同的uid，从而app可以相互访问私有文件，以及在同一进程中运行。系统不允许<strong>uid</strong>不同的apk定义同名权限，定义已经存在的权限的apk会安装失败。  </p></li><li><p>如果只想在拥有相同签名的app间共享机能，可以不用定义权限，而是直接进行签名检查。</p><blockquote><p>If the functionality is only available to apps signed with the same signature as the providing app, you may be able to avoid defining custom permissions by using signature checks. When one of your apps makes a request of another of your apps, the second app can verify that both apps are signed with the same certificate before complying with the request. <strong>But how to verify ???</strong></p></blockquote></li></ul><h4 id="URI-Permissions"><a href="#URI-Permissions" class="headerlink" title="URI Permissions"></a><a href="https://developer.android.com/guide/topics/permissions/overview.html#uri" target="_blank" rel="noopener">URI Permissions</a></h4><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><ul><li><p>Often times a permission failure will result in a <code>SecurityException</code> being thrown back to the app. However, this is not guaranteed to occur everywhere. For example, the <code>sendBroadcast(Intent)</code> method checks permissions as data is being delivered to each receiver, after the method call has returned, so you will not receive an exception if there are permission failures. In almost all cases, however, a permission failure will be printed to the system log.</p></li><li><p>A particular permission may be enforced at a number of places during your program’s operation:</p><ol><li>At the time of a call into the system, to prevent an app from executing certain functions.</li><li>When starting an <strong>activity</strong>, to prevent apps from launching activities of other apps.</li><li>Both sending and receiving <strong>broadcasts</strong>, to control who can receive your broadcast or who can send a broadcast to you.</li><li>When accessing and operating on a <strong>content provider</strong>.</li><li>Binding to or starting a <strong>service</strong>.</li></ol></li><li><p>Over time, <strong>new restrictions</strong> may be added to the platform such that, in order to use certain APIs, your app must request a permission that it previously did not need. Android may apply the new permission request to the app’s manifest. Android makes the decision as to whether an app might need the permission based on the value provided for the <code>targetSdkVersion</code> attribute. If the value is lower than the version in which the permission was added, then Android adds the permission.  </p><blockquote><p><strong>Caution:</strong> If a permission is automatically added to your app, your app listing on Google Play lists these additional permissions even though your app might not actually require them.<br>To avoid this and remove the default permissions you don’t need, always update your targetSdkVersion to be as high as possible. You can see which permissions were added with each release in the <a href="https://developer.android.com/reference/android/os/Build.VERSION_CODES.html" target="_blank" rel="noopener">Build.VERSION_CODES</a> documentation</p></blockquote></li><li><p>If an <strong>app update</strong> includes the need for <strong>additional permissions</strong>， the user is prompted to accept those new permissions before updating the app.</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>获取权限</strong>的结果由以下维度共同决定：<ol><li>权限的 protection level（是否需要动态授权）</li><li>权限的 permission group（以权限组为单位进行授权）</li><li>App的 targetSdkVersion（是否被自动补充权限声明以及是否需要动态授权等）</li><li>App的uid（拥有相同<strong>signature</strong>的不同app可通过声明<code>sharedUserId</code>属性共享uid，从而有权互搞）</li></ol></li><li><strong>权限保护</strong>由以下维度共同决定：<ol><li>四大组件在AndroidManifest.xml文件中声明时，通过标签属性或子元素，声明要求的权限。</li><li>URI Permission</li><li>动态检查权限其他App是否有某个权限<ul><li><a href="https://developer.android.com/reference/android/content/Context.html#checkCallingPermission(java.lang.String" target="_blank" rel="noopener">Context.checkCallingPermission()</a>)</li><li><a href="https://developer.android.com/reference/android/content/Context.html#checkUriPermission(android.net.Uri, int, int, int" target="_blank" rel="noopener"> Context.checkUriPermission()</a>)</li><li><a href="https://developer.android.com/reference/android/content/pm/PackageManager.html#checkPermission(java.lang.String, java.lang.String" target="_blank" rel="noopener">PackageManager.checkPermission()</a>)</li></ul></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      关于Android中的权限的一些要点摘录和总结。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 支持不同的屏幕</title>
    <link href="http://yoursite.com/2018/06/29/Android/%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B1%8F%E5%B9%95/"/>
    <id>http://yoursite.com/2018/06/29/Android/支持不同的屏幕/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T08:15:29.837Z</updated>
    
    <content type="html"><![CDATA[<h3 id="清晰度"><a href="#清晰度" class="headerlink" title="清晰度"></a>清晰度</h3><p><strong>我认为</strong>清晰度是，<strong>特定人所看到的物体的图像与此人对该物体的认知是否相同的一个反映</strong>。也就是说不同的人对同一个图像的清晰度的看法是不同的。比如UI设计师，往往能观察到更多图像细节，觉得不清晰。再比如，像素鸟，尽管一眼看去，全是块状的颜色，但在人们的认知中，这就是像素鸟的样子，所以不会觉得它“糊了”。因此清晰度实际上是由两个因素共同决定：</p><ol><li>图像的客观显示效果。</li><li>图像观察者的主观认知。</li></ol><p>在显示器上，图像的客观显示效果，由很多个因素共同决定，比如颜色。这里仅讨论，“像素”对显示效果的影响。图像在显示器上显示，是将图像数据解析并通过物理硬件显示。因此其显示效果主要依赖于以下两个因素：</p><ol><li>硬件显示图像的基本单位（以下简称物理显示单位）的物理尺寸。对硬件而言，比如液晶显示屏，基本显示单位往往是固定的，由晶体管等的显示效果决定。在古老的显示设备上，物理显示单位往往较大，以至于大多数人能辨识出这些单位，产生块状感。</li><li>图像数据与物理显示单位的映射关系。不同的图像数据格式记录数据的方式不同，但有一个共同点，将图像转换为一系列的颜色值进行记录，换言之，图像数据记录了颜色值和这些颜色值的排列关系。显示器在软件和硬件的共同作用下，使用<strong>一个或多个</strong>基本显示单位来显示图像数据记录的<strong>每一个</strong>颜色值，以下称之为映射关系。</li></ol><p>当物理显示单位的物理尺寸较大，以至能被人眼所辨识时，便产生不连续的块状感，与物体在认知中的连续性不同，便觉得不清晰。</p><p>当物理显示单位足够小，不能被人眼所辨识时，映射关系成为影响清晰度的主要因素。如果映射关系是一对一，那么每一个颜色值的物理显示尺寸足够小，足以产生连续感。如果映射关系是多对一，比如将图片放大，试图将数量固定的颜色值显示在数量多于颜色值的物理显示单位上，软件或硬件需要将缺失的颜色值补全，最粗暴的方式是让多个物理显示单位显示同一个颜色值。这种映射比例越大，一个颜色值的物理显示尺寸便越大，块状感便越强。</p><h3 id="使内容的物理显示尺寸固定"><a href="#使内容的物理显示尺寸固定" class="headerlink" title="使内容的物理显示尺寸固定"></a>使内容的物理显示尺寸固定</h3><h4 id="PPI-amp-DPI"><a href="#PPI-amp-DPI" class="headerlink" title="PPI &amp; DPI"></a>PPI &amp; DPI</h4><ul><li><a href="https://en.wikipedia.org/wiki/Pixel_density" target="_blank" rel="noopener">PPI，pixel per inch</a>，描述的是显示的像素密度。包括两方面，一方面是硬件的像素密度，往往是固定的。另一方面，往往可通过软件设置分辨率，来改变最终显示的像素密度。以下统称为<strong>显示像素密度</strong>。</li><li><a href="https://en.wikipedia.org/wiki/Dots_per_inch" target="_blank" rel="noopener">DPI，dot per inch</a>，原本用于描述扫描设备的采样点密度，或者打印设备的打印墨点密度等。</li></ul><p>在Android中，DPI 实际上指的是PPI。从7.0开始，系统提供了开发者选项来设置”最小宽度”，作用等同于设置分辨率。部分厂商也将这个特性开放给了普通用户，在设置中提供了“显示”选项。</p><h4 id="DIP"><a href="#DIP" class="headerlink" title="DIP"></a>DIP</h4><p>显示器以像素作为基本显示单位，因此必须将物理长度单位转换为像素才能显示在显示器上，而像素的物理尺寸不是固定的，因此物理长度单位与像素的转换关系是与像素的物理尺寸相关的。像素的物理尺寸信息可通过DPI来表示（倒数）。</p><p>实际上，Android允许直接使用<code>in</code>（表示英寸）作为长度单位，系统会将以<code>in</code>为单位的<code>dimen</code>数值，根据DPI换算成像素数量。换算公式为：<br>$$<br>ypx = npx/inch * xinch<br>$$<br>其中$npx/inch$ 即为DPI，是系统根据设备的物理像素密度或者设置的分辨率得出的值。式子左边$ypx$即为换算结果。</p><p>DIP（简称DP），density-independent pixel，虽然名字里有<strong>像素</strong>，但其显示长度与<strong>像素密度</strong>无关，而是与<strong>物理长度</strong>相关，可用于为内容设定（大致）固定的物理显示尺寸。与物理长度相关指的是，其与英寸等长度单位相同，直接指明了其表示的物理长度，并可与英寸等长度单位进行换算。DP其本身只是一个符号，是Android设计的一个单位，脱离了Android的解析，其本身便失去了表示长度的能力。Android指定dp与px的换算公式为：</p><p>$$<br>ypx = npx/inch / 160 * xdp<br>$$<br>因此，1dp等于1/160英寸。并且当DPI为160时，1dp可换算为1px。但是，实际上，系统在英寸和dp与像素的两个换算关系中，使用了不同的DPI。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypedValue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">applyDimension</span><span class="params">(<span class="keyword">int</span> unit, <span class="keyword">float</span> value, DisplayMetrics metrics)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_PX:</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_DIP:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.density;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_SP:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.scaledDensity;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_PT:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.xdpi * (<span class="number">1.0f</span>/<span class="number">72</span>);</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_IN:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.xdpi;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_MM:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.xdpi * (<span class="number">1.0f</span>/<span class="number">25.4f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayMetrics</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The logical density of the display.  This is a scaling factor for the</span></span><br><span class="line"><span class="comment">     * Density Independent Pixel unit, where one DIP is one pixel on an</span></span><br><span class="line"><span class="comment">     * approximately 160 dpi screen (for example a 240x320, 1.5"x2" screen), </span></span><br><span class="line"><span class="comment">     * providing the baseline of the system's display. Thus on a 160dpi screen </span></span><br><span class="line"><span class="comment">     * this density value will be 1; on a 120 dpi screen it would be .75; etc.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This value does not exactly follow the real screen size (as given by </span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #xdpi&#125; and &#123;<span class="doctag">@link</span> #ydpi&#125;, but rather is used to scale the size of</span></span><br><span class="line"><span class="comment">     * the overall UI in steps based on gross changes in the display dpi.  For </span></span><br><span class="line"><span class="comment">     * example, a 240x320 screen will have a density of 1 even if its width is </span></span><br><span class="line"><span class="comment">     * 1.8", 1.3", etc. However, if the screen resolution is increased to </span></span><br><span class="line"><span class="comment">     * 320x480 but the screen size remained 1.5"x2" then the density would be </span></span><br><span class="line"><span class="comment">     * increased (probably to 1.5).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #DENSITY_DEFAULT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> density;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The exact physical pixels per inch of the screen in the X dimension.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> xdpi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在英寸的换算中，使用的是物理DPI，而在DP的换算中，使用的是逻辑DPI，从7.0开始提供的修改分辨率的设置，修改的正是逻辑DPI。这导致DP与英寸之间的换算公式不成立，也使得DP失去了“density independence”的特性。</p><blockquote><p>Your application achieves “density independence” when it preserves the physical size (from the user’s point of view) of user interface elements when displayed on screens with different densities.</p><p>The density-independent pixel is equivalent to one physical pixel on a 160 dpi screen, which is the baseline density assumed by the system for a “medium” density screen.</p><p>The Android system helps your application achieve density independence in two ways:</p><ul><li>The system scales dp units as appropriate for the current screen density</li><li>The system scales drawable resources to the appropriate size, based on the current screen density, if necessary</li></ul></blockquote><blockquote><p>You can use the command line to simulate different device densities and display resolutions. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; // Set the display size</span><br><span class="line">&gt; adb shell am display-size 600x800</span><br><span class="line">&gt; </span><br><span class="line">&gt; // Set the display density</span><br><span class="line">&gt; adb shell am display-density 80</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="A-set-of-six-generalized-densities"><a href="#A-set-of-six-generalized-densities" class="headerlink" title="A set of six generalized densities"></a>A set of six generalized densities</h4><ul><li><em>ldpi</em> (low) ~120dpi</li><li><em>mdpi</em> (medium) ~160dpi</li><li><em>hdpi</em> (high) ~240dpi</li><li><em>xhdpi</em> (extra-high) ~320dpi</li><li><em>xxhdpi</em> (extra-extra-high) ~480dpi</li><li><em>xxxhdpi</em> (extra-extra-extra-high) ~640dpi</li></ul><p>通过划分出6个通用的密度区间，开发者不需为每个不同像素密度的设备提供对应的资源，系统会根据设备像素密度所属的区间，从对应后缀名的资源目录中寻找资源。特别是对于图片资源的匹配，系统的匹配优先级如下：</p><ol><li>优先从对应目录中寻找资源，假设DPI为300，会在xhdpi目录下寻找资源，并进行“压缩”显示（因为该目录下的图片应该是为320DPI设计的）。</li><li>从密度更高的目录中寻找，并将图片进行“压缩”显示。</li><li>从密度更低的目录中寻找，并将图片进行“拉伸”显示。</li></ol><blockquote><p>If the qualifier in question is <strong>screen pixel density</strong>, Android selects the option that most closely matches the device screen density. In general, Android prefers scaling down a larger original image to scaling up a smaller original image.</p></blockquote><blockquote><p><strong>Note:</strong> Place all your launcher icons in the <code>res/mipmap-[density]/</code> folders, rather than the <code>res/drawable-[density]/</code> folders. The Android system retains the resources in these density-specific folders, such as mipmap-xxxhdpi, regardless of the screen resolution of the device where your app is installed. This behavior allows launcher apps to pick the best resolution icon for your app to display on the home screen. For more information about using the mipmap folders, see <a href="https://web.archive.org/web/20170716144332/https://developer.android.com/tools/projects/index.html#mipmap" target="_blank" rel="noopener">Managing Projects Overview</a>.</p></blockquote><h3 id="为不同尺寸的设备提供不同的资源"><a href="#为不同尺寸的设备提供不同的资源" class="headerlink" title="为不同尺寸的设备提供不同的资源"></a>为不同尺寸的设备提供不同的资源</h3><h4 id="A-set-of-four-generalized-sizes"><a href="#A-set-of-four-generalized-sizes" class="headerlink" title="A set of four generalized sizes"></a>A set of four generalized sizes</h4><ul><li><em>xlarge</em> screens are at least 960dp x 720dp</li><li><em>large</em> screens are at least 640dp x 480dp</li><li><em>normal</em> screens are at least 470dp x 320dp</li><li><em>small</em> screens are at least 426dp x 320dp</li></ul><blockquote><p>When selecting resources based on the <strong>screen size qualifiers</strong>, the system uses resources designed for a screen smaller than the current screen if there are no resources that better match (for example, a large-size screen uses normal-size screen resources if necessary). However, if the only available resources are <em>larger</em> than the current screen, the system <strong>doesn’t</strong> use them and your app will <strong>crash</strong> if no other resources match the device configuration (for example, if all layout resources are tagged with the <code>xlarge</code> qualifier, but the device is a normal-size screen).</p></blockquote><h3 id="160-DPI-和-normal-size-的由来"><a href="#160-DPI-和-normal-size-的由来" class="headerlink" title="160 DPI 和 normal size 的由来"></a>160 DPI 和 normal size 的由来</h3><blockquote><p>The generalized sizes and densities are arranged around a baseline configuration that is a <strong>normal</strong> size and <strong>mdpi</strong> (medium) density. This baseline is based upon the screen configuration for the first Android-powered device, the T-Mobile G1, which has an HVGA screen (until Android 1.6, this was the only screen configuration that Android supported). Starting with Android 1.6 (API Level 4), Android provides support for multiple screen sizes and densities.</p></blockquote>]]></content>
    
    <summary type="html">
    
      在Android中支持多屏幕的一些个人看法。#Android中的像素单位解读#
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Service</title>
    <link href="http://yoursite.com/2018/06/29/Android/Service/"/>
    <id>http://yoursite.com/2018/06/29/Android/Service/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T19:23:13.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="Fundamental"><a href="#Fundamental" class="headerlink" title="Fundamental"></a>Fundamental</h2><ul><li><p>Beginning with Android 5.0 (API level 21), the system throws an exception if you call <code>bindService()</code> with an <strong>implicit intent</strong>.</p></li><li><p>If your app targets API level 26 or higher, the system imposes <a href="https://developer.android.com/about/versions/oreo/background.html" target="_blank" rel="noopener">restrictions on running background services</a> when the app itself is not in the <strong>foreground</strong>. In most cases like this, your app should use a <a href="https://developer.android.com/topic/performance/scheduling.html" target="_blank" rel="noopener">scheduled job</a> instead. See also <a href="https://developer.android.com/about/versions/oreo/background.html#services" target="_blank" rel="noopener">Background Service Limitations</a>.</p></li><li><p>Users can see what services are running on their device and can stop them. In order to avoid having your service stopped accidentally by users, you need to add the <a href="https://developer.android.com/guide/topics/manifest/service-element.html#desc" target="_blank" rel="noopener"><code>android:description</code></a> attribute to the <a href="https://developer.android.com/guide/topics/manifest/service-element.html" target="_blank" rel="noopener"><service></service></a> element in your app manifest. In the description, provide a short sentence explaining what the service does and what benefits it provides.</p></li><li><p><a href="https://developer.android.com/guide/components/activities/process-lifecycle.html" target="_blank" rel="noopener">process lifecycle</a></p><ul><li>foreground process</li><li>visible process</li><li>service process</li><li>cached process</li></ul></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mStartMode;       <span class="comment">// indicates how to behave if the service is killed</span></span><br><span class="line">    IBinder mBinder;      <span class="comment">// interface for clients that bind</span></span><br><span class="line">    <span class="keyword">boolean</span> mAllowRebind; <span class="comment">// indicates whether onRebind should be used</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The service is being created</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The service is starting, due to a call to startService()</span></span><br><span class="line">        <span class="keyword">return</span> mStartMode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A client is binding to the service with bindService()</span></span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onUnbind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// All clients have unbound with unbindService()</span></span><br><span class="line">        <span class="keyword">return</span> mAllowRebind;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRebind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A client is binding to the service with bindService(),</span></span><br><span class="line">        <span class="comment">// after onUnbind() has already been called</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The service is no longer used and is being destroyed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The <code>startService()</code> method returns immediately, and the Android system calls the service’s <code>onStartCommand()</code> method. The binding is also asynchronous, and <code>bindService()</code> returns immediately without returning the <code>IBinder</code> to the client. 这意味着Service是异步创建的。</p></li><li><p>If <a href="https://developer.android.com/reference/android/content/Context.html#bindService(android.content.Intent, android.content.ServiceConnection, int" target="_blank" rel="noopener">bindService()</a>) returns false, your client does not have a valid connection to the service. However, your client should still call <code>unbindService()</code>; otherwise, your client will keep the service from shutting down when it is idle.</p></li><li><p>The Android system calls <a href="https://developer.android.com/reference/android/content/ServiceConnection.html#onServiceDisconnected(android.content.ComponentName" target="_blank" rel="noopener">onServiceDisconnected()</a>) when the connection to the service is <strong>unexpectedly</strong> lost, such as when the service has crashed or has been killed. This is <strong><em>not</em></strong> called when the client unbinds.</p></li><li><p>If your service is started and accepts binding, then when the system calls your <code>onUnbind()</code> method, you can optionally return <code>true</code> if you would like to receive a call to <code>onRebind()</code> the next time a client binds to the service. <code>onRebind()</code> returns void, but the client still receives the <code>IBinder</code> in its <code>onServiceConnected()</code> callback. </p></li><li><p>Unless the service is bound to a client, the system destroys it when the service is stopped by calling <code>stopSelf()</code> or <code>stopService</code>. When the last client unbinds from the service, the system destroys the service, unless the service was also started by <code>startService()</code>. That is, the system destroys an service only after no clients bound to it and explicitly stopped if has been started.</p></li></ul><h2 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h2><h3 id="AIDL-线程与阻塞"><a href="#AIDL-线程与阻塞" class="headerlink" title="AIDL 线程与阻塞"></a>AIDL 线程与阻塞</h3><ul><li><p>A service runs in the <strong>main thread</strong> of its hosting process; the service does <strong>not</strong> create its own thread and does <strong>not</strong> run in a separate process unless you specify otherwise.</p></li><li><p>Calls made from the <strong>local process</strong> are executed in the <strong>same thread</strong> that is making the call.</p></li><li><p>Calls from a remote process are dispatched from a <strong>thread pool</strong> the platform maintains inside of your own process. You must be prepared for incoming calls from unknown threads, with multiple calls happening at the same time. In other words, an implementation of an AIDL interface must be completely <strong>thread-safe</strong>.</p><blockquote><p>当客户端调用服务端提供的<code>IBinder</code>接口时，客户端会被<strong><em>阻塞</em></strong>直到方法返回。在服务进程，系统维护一个线程池，当服务端接口被调用的请求到达时，系统从线程池中调起一个线程来执行服务。</p></blockquote></li><li><p>The <code>oneway</code> keyword modifies the behavior of <strong>remote calls</strong>. When used, a remote call does not block; it simply sends the transaction data and immediately returns. The implementation of the interface eventually receives this as a regular call from the <code>Binder</code> thread pool as a normal remote call. If <code>oneway</code> is used with a <strong>local call</strong>, there is no impact and the call is still synchronous.</p><blockquote><p>已验证：<code>oneway</code>用于修饰接口，表示对该接口所有方法的调用是“单向”的，即无需等待返回数据，方法的返回类型只能是<code>void</code>，并且不含有<code>out</code>或者<code>inout</code>修饰的参数。调用该接口的线程不会被阻塞。</p><p>从根据AIDL文件生成的<code>Proxy</code>类中，可以看到在调用<code>Binder.transact(int code, Parcel data, Parcel reply, int flags)</code>方法时，传递了<code>android.os.IBinder.FLAG_ONEWAY</code>给flag参数，该值用于标示非阻塞调用<strong>远程</strong>接口。</p></blockquote></li></ul><h3 id="AIDL-接口定义"><a href="#AIDL-接口定义" class="headerlink" title="AIDL 接口定义"></a>AIDL 接口定义</h3><p>AIDL 接口是用Java语法定义的。</p><h4 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h4><p>By default, AIDL supports the following data types:</p><ul><li><p>All primitive types in the Java programming language (such as <code>int</code>, <code>long</code>, <code>char</code>, <code>boolean</code>, and so on)</p></li><li><p><code>String</code></p></li><li><p><code>CharSequence</code></p></li><li><p><code>List</code></p><p>All elements in the <code>List</code> must be one of the supported data types in this list or one of the other AIDL-generated interfaces or parcelables you’ve declared. A <code>List</code> may optionally be used as a “generic” class (for example, <code>List&lt;String&gt;</code>). The actual concrete class that the other side receives is always an <code>ArrayList</code>, although the method is generated to use the <code>List</code> interface.</p></li><li><p><code>Map</code></p><p>All elements in the <code>Map</code> must be one of the supported data types in this list or one of the other AIDL-generated interfaces or parcelables you’ve declared. Generic maps, (such as those of the form <code>Map&lt;String,Integer&gt;</code> are not supported. The actual concrete class that the other side receives is always a <code>HashMap</code>, although the method is generated to use the <code>Map</code> interface.</p></li></ul><p>You must include an <code>import</code> statement for each additional type not listed above, even if they are defined in the same package as your interface.  </p><h4 id="参数的directional标签"><a href="#参数的directional标签" class="headerlink" title="参数的directional标签"></a>参数的directional标签</h4><p>All non-primitive parameters require a <strong>directional</strong> tag indicating which way the data goes. Either <code>in</code>, <code>out</code>, or <code>inout</code>. Primitives are <code>in</code> by default, and cannot be otherwise.</p><p>已验证：这个设定是为了节省传递数据的消耗。<code>in</code> 表示其修饰的参数仅用于提供数据给服务端，因此服务端对该参数的修改，不会影响客户端的实例。<code>out</code>则相反，表示其修饰的参数仅用于从服务端获取数据，接口实现中对该参数的修改将被传递给客户端。</p><p>从根据aidl文件生成的java类中，也可以一见端倪。<code>Proxy</code>是客户端用于与<strong>远程</strong>接口交互的代理类，其持有的<code>Binder</code>对象实现了<code>IBinder</code>接口，封装了与Binder驱动的交互细节。<code>Stub</code>是服务端的抽象类，继承了<code>Binder</code>，封装了远程连接的数据读写等操作，也声明了对aidl接口的实现，服务端的接口实现类继承<code>Stub</code>并<strong>实现</strong>aidl接口中声明的方法。对于<code>in</code>、<code>out</code>、<code>inout</code>修饰的参数，有如下特点：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"><code>Proxy</code>在调用远程方法前</th><th style="text-align:left"><code>Proxy</code>在调用远程方法后</th><th style="text-align:left"><code>Stub</code>在调用aidl接口方法前</th><th style="text-align:left"><code>Stub</code>在调用aidl接口方法后</th></tr></thead><tbody><tr><td style="text-align:left">in</td><td style="text-align:left">写入数据</td><td style="text-align:left">不读取数据</td><td style="text-align:left">读取数据</td><td style="text-align:left">不写入数据</td></tr><tr><td style="text-align:left">out</td><td style="text-align:left">忽略参数</td><td style="text-align:left">读取数据</td><td style="text-align:left">直接生成指定类型的对象，并传递给实现方法</td><td style="text-align:left">写入数据</td></tr><tr><td style="text-align:left">inout</td><td style="text-align:left">写入数据</td><td style="text-align:left">读取数据</td><td style="text-align:left">读取数据</td><td style="text-align:left">写入数据</td></tr></tbody></table><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>No exceptions that you throw are sent back to the caller.</p><p>验证：实际上服务端抛出的部分<code>RuntimeException</code>，是会传递给客户端的。以下描述仅对<strong><em>不</em></strong>被<code>oneway</code>修饰的接口有效。</p><p>首先，由于服务端提供的<code>Binder</code>是根据aidl文件生成的，在生成的接口的方法签名中，只抛出了<code>RemoteException</code>，这意味着<code>Binder</code>的实现类中的方法，无法抛出其他<strong>非运行时</strong>的异常。</p><p>对于抛出的<strong>运行时异常</strong>，从<code>Binder.execTransact()</code>和<code>Parcel.writeException()</code>可以看出，若是系统“已支持”的异常类型，会将该异常的信息写入数据流中，传递给客户端。而对于其他异常类型，将在<strong><em>服务端</em></strong>抛出<code>RuntimeException</code>。</p><p>客户端的远程服务代理类<code>Proxy</code>会在调用<code>Binder.transact()</code>方法后，执行<code>Parcel.readException()</code>，该语句将读取服务端写入数据流中的异常信息，<strong>生成并抛出</strong>对应的异常实例。对于未被传递的异常，客户端读取不到异常。若远程方法因异常终止执行，未将返回值写入数据流（如果该方法有返回值的话），客户端从数据流中也读取不到返回值。</p><h4 id="AIDL类图"><a href="#AIDL类图" class="headerlink" title="AIDL类图"></a>AIDL类图</h4><p><img src="http://pb88ntxoi.bkt.clouddn.com/image/android/AIDL%20Service.png" alt="AIDL Service"></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>Objects are reference <strong>counted</strong> across processes.</li><li><code>Parcel</code>是传输数据的管道，<code>Parcelable</code>是一个接口，表示其可被<code>Parcel</code>传输。</li></ul>]]></content>
    
    <summary type="html">
    
      摘抄关于Service的一些细节，以及AIDL的实战解读。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java杂记</title>
    <link href="http://yoursite.com/2018/06/29/Java/Java%E6%9D%82%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/29/Java/Java杂记/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T09:09:54.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h2><h3 id="字符集与字符编码"><a href="#字符集与字符编码" class="headerlink" title="字符集与字符编码"></a><a href="http://blog.jobbole.com/84903/" target="_blank" rel="noopener">字符集与字符编码</a></h3><ul><li>代码点（code point）是指与一个编码表中的某个字符对应的代码值，比如<code>A</code>的代码点是<code>65（\u0041）</code>。</li><li>代码单元（code unit）<ul><li>在基本多语言级别中，每个字符用16位表示，称为代码单元。</li><li>其他级别中的字符采用一对连续的代码单元进行编码。</li></ul></li><li>Java中采用UTF-16。<code>char</code>用两个字节（16位）来表示一个字符，所以<code>char</code>不能描述所有Unicode字符。因此不建议使用<code>char</code>。</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a><code>String</code></h3><ul><li><p><code>String.length()</code>返回的是字符串的代码单元的数量，而不是代码点的数量。</p><p>即”\uD801\uDC37”实际上表示一个字符，但需要两个代码单元来描述。</p></li><li><p><code>String.codePointCount(0, String.length())</code>返回的才是代码点的数量，也就是字符的数量。</p></li><li><code>String.charAt(n)</code>返回位置<code>n</code>的代码单元。</li><li><code>String.codePointAt(String.offsetByCodePoints(0, i))</code>返回的才是位置<code>i</code>的代码点。</li><li><code>String</code>是不可变字符串，没有提供修改字符串的行为，<code>String</code>的拼接或提取等都是产生新的<code>String</code>对象。</li></ul><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a><code>StringBuilder</code></h3><ul><li>为了避免“修改”字符串时，产生大量新对象，可使用<code>StringBuilder</code>，其内部实现是一个<code>char[]</code>。</li><li>采用<code>+</code>运算符来拼接<code>String</code>，编译后实际上是使用<code>StringBuilder</code>，并且每一个使用<code>+</code>的语句，都会创建一个<code>StringBuilder</code>对象。</li></ul><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a><code>StringBuffer</code></h3><p><code>StringBuilder</code>的线程安全版本，使用<code>synchronized</code>。</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul><li><p>内部有一个对应的基本类型的<code>final</code>成员<code>value</code>。</p></li><li><p>包装类会自动打包，本质是调用包装类的<code>static</code>方法<code>valueOf()</code>来创建一个包装类对象。</p></li><li><p>包装类会自动拆包，本质是调用包装类<strong>对象</strong>的<code>intValue()</code>等方法来返回<code>value</code>成员。</p></li><li><p>值得一提的是，<code>Integer</code>和<code>Long</code>有缓存机制，会将值落在[-128, 127]（上限可被虚拟机参数修改）范围内的<code>Integer</code>和<code>Long</code>对象缓存起来，因此不会重复创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a 跟 b是同一个对象，a == b 返回true</span></span><br><span class="line">Integer a = <span class="number">37</span>, b = <span class="number">37</span>;</span><br><span class="line"><span class="comment">//c 跟 d不是同一个对象，c == d 返回false</span></span><br><span class="line">Integer c = <span class="number">137</span>, d = <span class="number">137</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类是一种<strong>编译器现象</strong>，对于虚拟机而言，并不知道内部类的存在，编译器会把内部类编译成用$符号分隔外部类名和内部类名的常规类文件，虚拟机将其当做常规类文件处理。 并通过修改内部类的构造器等行为，绕过权限控制。</p><h3 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h3><p>编译器会在非静态内部类中添加一个<strong>外部类类型</strong>的<code>final</code>成员<code>this$0</code>，并通过修改内部类的所有构造器，添加一个外部类的引用参数，在创建内部类对象时，将实例化该内部类的外部类对象作为参数传入构造器，再将该参数赋值给<code>this$0</code>。</p><h3 id="访问私有成员"><a href="#访问私有成员" class="headerlink" title="访问私有成员"></a>访问私有成员</h3><p>内部类和外部类之间可以相互调用<strong>私有成员</strong>（包括field和method）。编译器会为<strong>被调用</strong>的私有成员生成具有包权限的静态方法，内部类和外部类通过这些静态方法来相互调用<strong>私有成员</strong>。</p><p>值得一提的是，如果调用的是非静态成员，自动生成的静态方法会带有一个对方类型的参数。</p><h4 id="field"><a href="#field" class="headerlink" title="field"></a>field</h4><p>对于被调用的私有field，编译器会生成具有包权限的静态方法，来get和set field。</p><h4 id="method"><a href="#method" class="headerlink" title="method"></a>method</h4><p>对于被调用的私有method，编译器会生成具有包权限的静态方法，该方法会调用私有method。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义在局部块（方法）中的类称为局部内部类。</p><p>局部内部类可以访问<code>final</code>的局部变量。编译器会为局部内部类添加一个<strong>该局部变量类型</strong>的<code>final</code>field，添加一个构造函数，并将被调用的局部变量作为参数，对其进行赋值。</p><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>正如上文所言，非静态内部类因持有外部类对象以及局部变量，容易造成内存泄露。</p><p>除了显式声明为静态内部类，在外部类的静态方法中声明的局部内部类，也是静态内部类，不会隐式持有外部类对象（因为不存在）。</p><p>对于局部变量，可用弱引用等进行包装。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="编译结果"><a href="#编译结果" class="headerlink" title="编译结果"></a>编译结果</h3><p>编译后实际上是一个类，access flags 为 <code>0x4031[public final enum]</code>，继承自<code>java.lang.Enum</code>。</p><h3 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h3><p>一个枚举类型的每个值都是该类的一个<code>final static</code>的实例对象。在字节码文件中可以看到，编译器自动生成了一个静态初始化块，在该初始化块中，会对每个值进行初始化。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a><code>Serializable</code></h3><ul><li><p>是一个<strong>标记接口</strong>，声明实现<code>Serializable</code>的类，其对象可被<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>序列化和反序列化。<code>Serializable</code>标记的类默认会序列化所有不被<code>static</code>和<code>transient</code>修饰的成员。</p></li><li><p><code>private static final long serialVersionUID</code></p><ul><li>可用于做序列化的<strong>版本兼容</strong>。</li><li>控制非法反序列化。没有正确<code>serialVersionUID</code>的程序无法对序列化的字节码进行反序列化。</li></ul></li><li><p>用<code>transient</code>修饰的成员不会被序列化。</p></li><li><p><strong>添加</strong>以下方法，替换默认的序列化行为，达到加密、序列化特定成员等目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a><code>Externalizable</code></h3><p>继承于<code>Serializable</code>，但默认不序列化任何成员，需要自定义序列化行为，类似于android中的<code>Parcelable</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加密包装类"><a href="#加密包装类" class="headerlink" title="加密包装类"></a>加密包装类</h3><p><code>javax.crypto.SealedObject</code> 和<code>java.security.SignedObject</code> 可用于包装<code>Serializable</code>的实现类，它们定义了加密的序列化行为。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ul><li><p><strong>继承和持有对象的选择</strong></p><p>有时候我们面临着这么一个情况，当我们需要一个类B来扩展一个类A时，是选择继承A，还是持有A的一个对象引用。这两者的区别如下： </p><ul><li>对于客户端需要的调用方法，前者可选择性复写并添加父类A的方法来实现自己的逻辑功能，而后者需要全部提供入口 。</li><li>前者只能拥有父类A的方法属性，而无法拥有A的其他子类的。而后者，则可以引用类A及其所有子类。</li><li>在设计模式中，前者拥有适配器的特点，Adapter包含并重定义了Adaptee的方法，以提供给客户端需要的接口。而后者更接近于门面模式，封装了内部复杂的模块，只提供必需的接口给客户端。</li></ul></li><li><p><strong>宽接口与窄接口。</strong>有时候对于一个类，在内部模块（可能在同一个包或不同的包下，跨包情况下default权限并不能很好地起作用）希望提供正常使用的接口，而对外进行访问限制，例如单纯只被引用，可以考虑，实现两个接口，一个用于内部模块，一个用于外部模块，各自声明拥有仅需的方法。</p></li></ul>]]></content>
    
    <summary type="html">
    
      记录一些Java的语法特性，部分涉及其编译现象。
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的泛型</title>
    <link href="http://yoursite.com/2018/06/29/Java/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/06/29/Java/泛型/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T18:59:11.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的泛型"><a href="#Java中的泛型" class="headerlink" title="Java中的泛型"></a>Java中的泛型</h2><h3 id="没有泛型的时代"><a href="#没有泛型的时代" class="headerlink" title="没有泛型的时代"></a>没有泛型的时代</h3><p>往往使用<code>Object</code>替代泛型，例如Java中的集合。但这种方式往往有两个问题：</p><ul><li>需要类型强制转化。</li><li>没有类型检查，有安全问题。</li></ul><p>后来，Java SE 5引入了泛型的概念，解决了相应的问题。</p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>实际上，泛型是一种<strong>编译器现象</strong>。开发者开发时使用泛型，编译器会帮助开发者做类型转换，也会做相应的类型检查。而在编译的结果中，并没泛型的概念。此行为成为<strong>类型擦除</strong>。</p><ul><li>编译器自动提供了一个相应的原始类型，原始类型的名字就是删去类型参数后的泛型类型名。原始类型用第一个限定的类型变量来替换，如果没有给定限定就用<code>Object</code>替换。</li><li>当程序调用泛型方法时，如果擦除返回类型，编译器会插入强制类型转换。</li><li>桥方法被合成来保持多态。</li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li><p>对于泛型，使用<code>instanceof</code>实际上仅比对了原始类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> Pair&lt;String&gt;; <span class="comment">//等同于 a instanceof Pair</span></span><br></pre></td></tr></table></figure></li><li><p>类型强转同上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;) a; <span class="comment">//等同于 Pair p = (Pair) a</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>在使用泛型API（类或方法时），可用通配符<code>?</code>来替代具体的类型。</p><ul><li><p><code>?</code> 结合 <code>extends</code>。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Manager&gt; list; <span class="comment">//元素必须是 Manager的子类/实现类。</span></span><br></pre></td></tr></table></figure></li><li><p><code>?</code>结合<code>super</code>。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Manager&gt; list; <span class="comment">//元素必须是 Manager的父类。</span></span><br></pre></td></tr></table></figure></li><li><p><code>?</code>单独使用。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz;</span><br></pre></td></tr></table></figure></li></ul><h4 id="与Object"><a href="#与Object" class="headerlink" title="?与Object"></a><code>?</code>与<code>Object</code></h4><p><code>?</code>是通配符，顾名思义，是可以匹配任意类型。<code>Object</code>作为超类，是所有其他类的父类。两者有着本质区别。正如上文所说，泛型的作用之一就是类型检查，<code>?</code>的作用在于匹配所有类型。这两者的区别往往体现在需要类型检查的时候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = AnyClass.class; <span class="comment">//Class&lt;?&gt;能匹配所有类型的class</span></span><br><span class="line">Class&lt;Object&gt; oClazz = Object.class; <span class="comment">//Class&lt;Object&gt;仅能匹配 Object.class</span></span><br><span class="line"></span><br><span class="line">List&lt;?&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Object&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      浅析Java中的泛型。
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java异常机制</title>
    <link href="http://yoursite.com/2018/06/29/Java/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/06/29/Java/异常机制/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T12:30:47.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h2><h3 id="异常分类与继承关系"><a href="#异常分类与继承关系" class="headerlink" title="异常分类与继承关系"></a>异常分类与继承关系</h3><p><img src="http://pb88ntxoi.bkt.clouddn.com/image/java/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="异常分类与继承关系"></p><h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a><code>Error</code></h4><p><code>Error</code>及其子类，描述了Java运行时系统的内部错误和资源耗尽错误。应用程序开发者不应该使用<code>Error</code>。原则上，出现<code>Error</code>时，最多只能保证尽快安全地终止程序。</p><h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a><code>Exception</code></h4><p>应用开发者主要面对<code>Exception</code>，其分为两大类：<code>RuntimeException</code>与编译时异常。</p><h5 id="RuntimeExcetpion"><a href="#RuntimeExcetpion" class="headerlink" title="RuntimeExcetpion"></a><code>RuntimeExcetpion</code></h5><p>运行时异常，或称为未受检异常（unchecked exception）。由应用程序错误导致的异常属于<code>RuntimeException</code>。如错误的类型转换，数组越界等，这些错误往往是由应用开发者的错误导致。因此“如果出现<code>RuntimeException</code>异常，那么就一定是你的问题”。</p><h5 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h5><p>或称为受检异常（checked exception）。应用程序本身没有问题，但由于像I/O错误这类问题导致的异常属于编译时异常。</p><h3 id="使用异常"><a href="#使用异常" class="headerlink" title="使用异常"></a>使用异常</h3><h4 id="使用异常-1"><a href="#使用异常-1" class="headerlink" title="使用异常"></a>使用异常</h4><ul><li>对于可能发生的错误，有两种方法通知调用者。一种是通过返回值，一种是抛出异常。异常处理机制，也是对责任链模式的运用。使用异常，一定程度上可以让开发者专注于业务，而非错误处理，并让“合适的”处理者来处理异常。</li><li>有些情况，无法从返回值中区分是否遭遇了错误，此时可使用异常。</li><li>原则：对于可恢复的情况，使用<strong>受检异常</strong>；对于程序错误，则使用<strong>运行时异常</strong>。</li></ul><h4 id="不使用异常"><a href="#不使用异常" class="headerlink" title="不使用异常"></a>不使用异常</h4><ul><li>异常处理机制更耗时。</li><li>在某些情况下，API方法遇到的错误是调用者的疏忽造成的，而这种错误，调用者可以通过诸如判空、判断是否可执行等来避免，这种情况下应该提供这些检测方法，而不是一味地抛出异常，特别是受检异常。</li></ul><h3 id="线程异常处理器"><a href="#线程异常处理器" class="headerlink" title="线程异常处理器"></a>线程异常处理器</h3><p><code>UncaughtExceptionHandler</code>是线程用于处理异常的接口，如果异常没有被调用栈处理，JVM在终止线程（而不是进程）之前，会先调用线程异常处理器。开发者可通过设置线程异常处理器来保障应用安全地终止。值得一提的是，此处理器，并不能阻止线程的终止。</p><ul><li>可以通过<code>Thread</code>对象的<code>setUncaughtExceptionHandler()</code>方法给线程设置异常处理器。</li><li>也可以通过<code>Thread</code>的静态方法<code>setDefaultUncaughtExceptionHandler()</code>方法给所有线程设置<strong>默认异常处理器</strong>。前者优先级更高。</li><li>如果不为独立的线程设置处理器，其处理器就是该线程的<code>ThreadGroup</code>对象，该类实现了<code>Thread.UncaughtExceptionHandler</code>接口。其行为如下：<ul><li>如果线程组有父线程组，调用父线程组的<code>UnCaughtException()</code>方法。</li><li>否则，如果有默认处理器，调用该处理器。</li><li>否则，如果<code>Throwable</code>是<code>ThreadDeath</code>的一个实例，什么都不做。</li><li>否则，线程的名字以及<code>Throwable</code>的栈踪迹被输出到<code>System.err</code>上。</li></ul></li></ul><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul><li><p>一旦某个方法遭遇异常，将抛出异常并立刻退出，而不返回任何值，此外，调用此方法的代码也将无法继续执行，而是异常处理机制开始搜索异常处理器。直到异常处理器处理之后，便可以继续执行处理器之后的代码。</p></li><li><p>子类重写的方法抛出的异常不能超过父类，因此如果子类的重写方法代码可能遭遇异常，需要在子类中捕获异常。</p></li><li><p>再次抛出异常与异常链：在<code>catch</code>子句中可以再抛出异常，这样做的目的是改变异常类型。比如子系统抛出的异常，可能在其他系统有不同的异常类型表示，这时候可先捕获再抛出新的异常。同时，可调用新抛出的异常对象的<code>initCause()</code> 方法，把原始异常作为参数传入，在之后捕获异常时，可以使用<code>getCause()</code>方法重新得到原始异常。</p></li><li><p><code>try</code>语句块之后可以不跟<code>catch</code>而直接跟<code>finally</code>，这样就可以在不处理异常的情况下，执行一些必须执行的工作，比如回收资源。</p></li><li><p>以下写法不仅逻辑清晰，内嵌<code>try</code>语句负责收尾工作，外部<code>try</code>语句负责处理异常，并且外部的<code>catch</code>子句还能捕获<code>finally</code>子句抛出的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//...回收资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>finally</code>子句只有在<code>try</code>语句块被进入（不被条件语句跳过等）的情况下，才会被执行。</p></li><li><p><code>finally</code>子句的缺陷。当<code>finally</code>子句也抛出异常时，会覆盖<code>try</code>子句抛出的异常。最好的办法是就地捕获<code>finally</code>语句中抛出的异常。</p></li><li><p><code>Throwable.getStackTrace()</code>方法将返回一个<code>StackTraceElement</code>对象的数组，该数组是对一个方法调用过程的堆栈追踪。 类似的有<code>Thread</code>的静态方法的<code>getAllStackTrace()</code>方法，提供对所有线程的堆栈追踪。 </p></li><li><p><code>try-with-resources</code>语句，会把资源（<code>AutoCloseable</code>或 <code>Closeable</code>）对象在<code>try</code>代码块执行结束或捕捉异常后，执行<code>close()</code>方法，<code>close()</code>方法如果抛出异常，将调用该方法抛出的异常的<code>addSuppressed()</code>方法，并将关闭异常作为参数传入，如果该方法未抛异常，则无此步骤。</p></li></ul><h3 id="编译结果"><a href="#编译结果" class="headerlink" title="编译结果"></a>编译结果</h3><p>在Java的字节码中，异常处理器不是通过指令实现，而是通过Exception Table。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void tryFunc();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=3, args_size=1</span><br><span class="line">       0: new           #8                  // class java/lang/RuntimeException</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #9                  // Method java/lang/RuntimeException.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: athrow</span><br><span class="line">       8: astore_1</span><br><span class="line">       9: goto          15</span><br><span class="line">      12: astore_2</span><br><span class="line">      13: aload_2</span><br><span class="line">      14: athrow</span><br><span class="line">      15: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           0     8     8   Class java/lang/Exception</span><br><span class="line">           0     9    12   any</span><br></pre></td></tr></table></figure><p><code>from</code>和<code>to</code>描述<code>try</code>块的开始和结束的行数，<code>target</code>指的是处理异常的行数。这里的行数，指的是字节码方法中的行数，而不是源码中的行数。</p><p>上例中，当方法中的第0行（含）到第8行（不含）之间抛出<code>Exception</code>时，跳转到第8行，开始处理异常。<code>finally</code>子句的本质，也是在Exception Table中添加处理器（并重新抛出异常），来保证会被执行，如上例中的第二个处理器。</p>]]></content>
    
    <summary type="html">
    
      浅析Java异常机制。
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的异步与同步</title>
    <link href="http://yoursite.com/2018/06/29/Java/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/06/29/Java/异步与同步机制/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T09:21:31.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a><code>Thread</code></h3><p>Java中用<code>Thread</code>类来启动线程，除了自身的<code>run()</code>方法，还可以接收一个<code>Runnable</code>来作为线程工作。</p><h4 id="挂起线程"><a href="#挂起线程" class="headerlink" title="挂起线程"></a>挂起线程</h4><ul><li><code>sleep()</code>休眠一定时间，进入阻塞状态。</li><li><code>yield()</code>让出CPU，进入就绪状态，重新抢占CPU。</li></ul><h4 id="中断线程！"><a href="#中断线程！" class="headerlink" title="中断线程！"></a>中断线程！</h4><ul><li><p><code>stop()</code></p><p>调用的时候，被调用的线程会马上从正在执行（或者挂起）的地方抛出<code>ThreadDeath</code>（<code>Error</code>的子类）。</p></li><li><p><code>interrupt()</code></p><p>调用的时候，如果该线程被挂起或阻塞，该线程会抛出<code>InterruptedException</code>等异常；否则，该方法仅起到设置标志的作用，可通过<code>interruped()</code>方法判断是否该结束线程。</p></li></ul><p>不管是<code>stop()</code>还是<code>interrupt()</code>，都是通过抛出<code>Throwable</code>来起到“中断”的作用。实际上，这里的<code>Throwable</code>同样可以被<code>catch</code>子句捕获，<code>finally</code>子句也同样有效。因此，这两个方法都不能保证中断线程。</p><p>相对而言，<code>stop()</code>比<code>interrup()</code>更粗暴，因此也具有一定危险。比如，当线程持有锁，线程的中断，会释放锁，这可能会导致原本需要被锁保护的对象，暴露给了其他线程。因此<code>stop()</code>被标记为废弃的方法。</p><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><ul><li><code>getPriority()</code></li><li><code>setPriority()</code>参数为Thread的静态常量。</li></ul><h3 id="Callable-lt-T-gt-与Future-lt-T-gt"><a href="#Callable-lt-T-gt-与Future-lt-T-gt" class="headerlink" title="Callable&lt;T&gt;与Future&lt;T&gt;"></a><code>Callable&lt;T&gt;</code>与<code>Future&lt;T&gt;</code></h3><ul><li><code>Callable&lt;T&gt;</code>作用与<code>Runnable</code>类似，但可在执行后返回一个T类型的返回值，需要与<code>Future&lt;T&gt;</code>配合使用，<code>Callable&lt;T&gt;</code>的执行结果会存储在一个<code>Future&lt;T&gt;</code>对象中。<code>Future.get()</code>方法可用于取回结果，调用该方法将会阻塞线程直到工作线程计算出结果。 </li><li><code>FutureTask&lt;T&gt;</code>实现了<code>Runnable</code>和<code>Future</code>接口，可接收一个<code>Callable</code>对象，起到包装<code>Callable</code>的作用，可以将<code>FutureTask</code>交给<code>Thread</code>执行，并取得执行结果。</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><code>Executors</code>类有许多静态工厂方法用来构建线程池，可根据需要选择不同的线程池。线程池是实现了<code>ExecutorService</code>接口的类，重载了多个<code>submit()</code>方法，使用<code>Runnable</code>或<code>Callable</code>作为参数，并返回<code>Future</code>。</p><h4 id="重要！"><a href="#重要！" class="headerlink" title="重要！"></a>重要！</h4><p>当使用完一个线程池，应该调用<code>shutdown</code>方法来停止线程池，其内部是调用了<code>Thread.interrupt()</code>来中断线程。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>根据各线程访问同一数据的次序，可能会产生讹误的对象，这种情况称为竞争条件（race condition）。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li>锁是<strong>可重入</strong>的。</li><li>条件：当一个线程<strong>获得某个锁</strong>，却发现需要满足某个条件才能继续执行时，需要释放锁并阻塞线程，直到被唤醒。条件用于挂起线程与唤醒线程。</li></ul><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h4><ul><li><p>使用的时候，如果临界区可能抛出异常，应该在<code>finally</code>子句中调用<code>unlock()</code>，以防止其他线程被永远阻塞。</p></li><li><p><strong>条件</strong></p><p><code>ReentrantLock</code>有一个<code>newCondition()</code>方法，该方法返回一个<code>Condition</code>对象。在某个条件下，线程应该等待，这时可调用条件对象的<code>await()</code>方法挂起线程。当其他线程执行后，使得该条件<strong>可能</strong>已经改变时，应该在该线程调用该条件对象的<code>signal()</code>或<code>signalAll()</code>方法，通知线程调度器，解除该条件的等待集中的所有线程的阻塞状态。 </p></li><li><p><strong>锁重入</strong></p><p>锁保持一个持有计数来跟踪对<code>lock()</code>方法的嵌套调用，因此在每一次调用<code>lock()</code>，都应对应地调用<code>unlock()</code>。由于这一特性，被一个锁保护的代码可以调用另一个使用相同锁的方法。</p></li><li><p><strong>锁测试和锁超时</strong></p><ul><li><p><code>boolean tryLock()</code>尝试获取锁，成功返回<code>true</code>，否则返回<code>false。</code></p></li><li><p><code>boolean tryLock(long time, TimeUnit unit)</code>尝试获取锁，但阻塞时间不会超过给定值，成功返回<code>true</code>。<code>TimeUnit</code>是枚举类型，指定时间单位（秒，毫秒，微秒，纳秒）。</p></li><li><p><code>void lockInterruptibly()</code></p></li><li><p><code>lock()</code>方法不能被中断，如果线程在等待锁的期间被中断，中断线程在获得锁之前仍将处于阻塞状态。带有时间参数的<code>tryLock()</code>在阻塞中被中断，将抛出<code>InterruptedException</code>。<code>lockInterrupted()</code>方法相当于设置一个超时为无限的<code>tryLock()</code>，允许线程提前结束阻塞。</p></li><li><p><code>boolean await(long time, TimeUnit unit)</code></p></li><li><p>进入该条件的等待集，直到线程从等待集移出或者达到指定时间，才解除阻塞。因到达时间而返回，则返回<code>false</code>，否则返回<code>true</code>。如果线程阻塞期间被中断，抛出<code>InterruptedException</code>。</p></li><li><p><code>void awaitUniterruptibly()</code></p><p>进入该条件的等待集，直到线程从等待集移出才解除阻塞。如果线程被中断，不会抛出<code>InterruptedException</code>。</p></li></ul></li></ul><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><code>synchronized</code></h4><ul><li><p><code>synchronized</code>关键字，<strong>锁住的是一个对象</strong>，当一个线程调用该对象的（部分或全部）同步代码时，其他需要调用（相同或不同）同步代码的线程进行等待。即<code>synchronized</code>关键字，限制了一个对象的所有同步代码块的并行执行。执行非同步代码块则无需等待。 </p></li><li><p>非静态方法使用<code>synchronize</code>关键字修饰，锁住的是<code>this</code>。</p></li><li><p>静态方法使用<code>synchronize</code>关键字修饰，锁住的是类的<code>class</code>对象。</p></li><li><p><strong>条件</strong></p><p>Java中的每一个对象都有一个<strong>内部锁</strong>，内部对象锁只有一个相关条件，<code>wait()</code>方法添加一个线程到等待集中，<code>notifyAll()</code>或<code>notify()</code>方法解除等待线程的阻塞状态。相关条件的使用前提是当前线程持有对象锁。也就是必须先进入临界区，然后判断条件，看是否要先把对象锁让给其他线程。 </p></li><li><p><strong>获取锁</strong>与<strong>释放锁</strong></p><ul><li>字节码中，被<code>synchronized</code>块（不是方法），锁的获取是<code>monitorenter</code>指令，释放是<code>monitorexit</code>指令，即<code>synchronized</code>块中的代码是在<code>monitorenter</code>和<code>monitorexit</code>指令之间的。看起来类似<code>ReentrantLock</code>的<code>lock()</code>和<code>unlock()</code>的结构。</li><li>为了保证锁能被释放，编译器会为临界区生成一个异常处理器，在处理器中添加<code>monitorexit</code>指令。这也是为什么线程因异常而中断时，锁会被释放。</li></ul></li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h3><p><code>volatile</code>修饰符并不能提供原子性，即不能保证任何代码或代码块的执行不被中断。但它提供了可见性。volatile修饰的变量，能保证其被所有线程读取到的值是最新且一致的。为了效率，CPU可能从内存中读取了变量值后存储到内部缓存（高速缓存），并对该值进行操作，然而并不马上写回内存。对于多核处理器或者多处理器，其内部缓存对变量值的缓存可能导致变量值出现不一致，因为变量值并没有马上被写回内存。使用<code>volatile</code>修饰符，可强制处理器马上将操作后的变量值写回内存。多处理器通过嗅探，发现内部缓存与内存不一致时，会重新从内存读取数据，从而保证数据一致性。详见<a href="http://www.infoq.com/cn/articles/ftf-java-volatile" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/ftf-java-volatile</a></p>]]></content>
    
    <summary type="html">
    
      浅析Java中的异步与同步机制。
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化理论篇</title>
    <link href="http://yoursite.com/2018/06/29/Android/Android%20%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    <id>http://yoursite.com/2018/06/29/Android/Android 优化/性能优化理论篇/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T04:34:20.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h1><p>从优化目标的角度来看，大致可分为以下两种：</p><ul><li>效率优化，主要为了达到交互流畅，以及提高性能。</li><li>耗电优化。</li></ul><h2 id="效率优化"><a href="#效率优化" class="headerlink" title="效率优化"></a>效率优化</h2><p>效率优化，顾名思义，是减少完成任务的时间，从而提高效率，可再细分为以下两种：交互流畅度优化与功能效率优化。</p><h3 id="交互流畅度优化"><a href="#交互流畅度优化" class="headerlink" title="交互流畅度优化"></a>交互流畅度优化</h3><p>提供流畅的交互，避免<strong>卡顿</strong>、甚至<strong>ANR</strong>。这里的任务主要是尽快提供UI上的反馈来响应用户操作。</p><h4 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h4><ul><li>当用户点击按钮时，马上呈现水波纹等点击效果。</li><li>提供顺畅的列表滑动操作。</li><li>在执行耗时任务时，提供流畅的进度圈或进度条。</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Android系统每隔<strong>16ms</strong>发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps，为了能够实现60fps，这意味着程序的大多数操作都必须在16ms内完成。 如果你的某个操作花费时间是24ms，系统在得到VSYNC信号的时候就无法进行正常渲染，这样就发生了<strong>丢帧现象</strong>（俗称<strong>卡顿</strong>）。那么用户在32ms内看到的会是同一帧画面。 这个每秒帧数的参数来自于手机硬件，大多数手机屏幕刷新频率大概为60赫兹。</p><p>当系统长时间无法进行正常绘制，就发生了<strong>无响应现象</strong>，5秒无响应，系统即会弹出<strong>ANR</strong> 对话框。</p><h3 id="功能效率优化"><a href="#功能效率优化" class="headerlink" title="功能效率优化"></a>功能效率优化</h3><p>除了提供流畅的交互外，提高App 的功能效率也很重要。功能效率指的是App 提供给用户的功能的效率，比如打开文档的效率，加载图片的效率等等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这两者不是相互独立的。</p><h4 id="相辅相成"><a href="#相辅相成" class="headerlink" title="相辅相成"></a>相辅相成</h4><p>功能效率的优化，往往能提升交互流畅度。交互流畅度的优化一般也会减少对CPU时间的占用，为业务执行让路。</p><h4 id="异曲同工"><a href="#异曲同工" class="headerlink" title="异曲同工"></a>异曲同工</h4><p>核心思想是相同的：尽可能<strong>减少完成任务的时间</strong>。</p><p><strong>完成任务的时间</strong>在开发者可控范围内，主要受两方面影响：</p><ul><li>任务本身的耗时。这很大程度上取决于开发者的设计。比如要显示的界面是否过于复杂；是否采用了缓存技术以及缓存命中率等。</li><li>任务执行过程是否包含/遭遇不必要的耗时操作。<ul><li>任务自身包含的非必要耗时操作。比如响应按钮点击时，是否<strong>触发并等待</strong>文件读写等耗时操作。</li><li>任务执行中与其他任务的竞争。典型的竞争胜利者就是GC。可以认为一次GC 操作具备原子性，一次GC 过程中其他线程无法工作。因此GC 发生的频率、耗时，将变相影响其他任务的效率。</li></ul></li></ul><h5 id="寻找优化点"><a href="#寻找优化点" class="headerlink" title="寻找优化点"></a>寻找优化点</h5><p>分析任务执行过程。入手点是分析方法的执行，可借助工具来统计查看执行了哪些方法、方法执行的频率、耗时。寻找优化点是<strong>最难</strong>的一步。困难主要包括：</p><ul><li>人的一瞬间，对计算机而言是漫长的，在这其中可能调用了很多方法，要在繁杂的Profiler 报告中定位到异常，往往需要通过多次的定位，不断缩小范围。</li><li>对于单次调用时问题不明显，但被循环调用，甚至在多个不同的调用链中被调用，累积产生的效率问题，尤其难以发现。</li></ul><h5 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h5><ul><li>去除冗余。具体方案：<ul><li>避免没有意义的工作，典型的场景是过度绘制。</li><li>运用批处理和缓存的思想，减少重复的工作。</li></ul></li><li>分而治之。合理运用线程等技术“并行”开展任务。</li><li>因地制宜。根据具体的需求，选择合适的数据结构、算法。不同的数据结构，比如链表、数组、哈希表，在增删改查上各有所长。</li></ul><h2 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h2><h3 id="Android系统与电量相关的特性"><a href="#Android系统与电量相关的特性" class="headerlink" title="Android系统与电量相关的特性"></a>Android系统与电量相关的特性</h3><ul><li>部分硬件会在空闲时被关闭，以此来延长电池使用时间。</li><li>硬件被唤醒时会出现一个唤醒耗电高峰。</li><li>硬件被唤醒并执行工作后，往往会保持一段时间的活跃。</li></ul><h3 id="优化思路-1"><a href="#优化思路-1" class="headerlink" title="优化思路"></a>优化思路</h3><p>尽可能将不必马上执行的任务推迟，并在达到相关条件时，批量执行任务，以此避免频繁唤醒硬件，并尽可能让设备获得更多的休眠时间。</p><h3 id="典型场景-1"><a href="#典型场景-1" class="headerlink" title="典型场景"></a>典型场景</h3><h4 id="网络任务"><a href="#网络任务" class="headerlink" title="网络任务"></a>网络任务</h4><p>蜂窝网络（移动网络）是耗电大户，尤其是其硬件模块的唤醒会引起一个耗电高峰，为了避免频繁唤醒硬件，它会在一小段时间内保持开启状态（等待网络响应或者其他网络请求）。因此尽可能推迟网络请求的任务，在硬件已经被唤醒的情况下，或者当设备连接WiFi 时，批量处理这些任务，可以避免无谓的硬件唤醒，从而减少电量消耗。</p><h4 id="耗电任务"><a href="#耗电任务" class="headerlink" title="耗电任务"></a>耗电任务</h4><p>对于一些不必马上执行的耗电任务，可推迟到设备连接电源时执行，避免对电池电量的消耗。</p><h1 id="优化实践"><a href="#优化实践" class="headerlink" title="优化实践"></a>优化实践</h1><p>预防优于治理。后期优化相对而言，将耗费更多的人力物力，因此应养成良好的开发习惯，避免“产生优化点”。</p><h2 id="过度绘制"><a href="#过度绘制" class="headerlink" title="过度绘制"></a>过度绘制</h2><p>屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。</p><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ol><li><p>减少布局嵌套层次。<code>&lt;merge&gt;</code>可用于减少无谓的层次。</p></li><li><p>运用<code>ViewStub</code>实现按需加载布局。</p><p><code>ViewStub</code>继承于<code>View</code>，其复写了<code>onMeasure()</code>、<code>dispatchDraw()</code>和<code>draw()</code>等方法，而实现中没有任何实际工作。因此实际上<code>ViewStub</code>在<code>inflate()</code>之前，<strong>并非</strong>没有被加载，只是其绘制流程都是空白罢了，起到一个占位的作用，使得动态加载布局更加容易编写以及维护。</p><p>在<code>ViewStub.inflate()</code>中，做了以下三件事：</p><ul><li>使用<code>LayoutInflater</code>加载指定的布局。</li><li>从父<code>View</code>中移除自身。由于<code>inflate()</code>会移除自身，因此不能被多次调用，否则会因<code>mParent</code>为空而抛异常。</li><li>将加载的布局添加到父<code>View</code></li></ul></li><li><p>去除多余的背景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//甚至可以移除（Activity的）Window的背景</span></span><br><span class="line">getWindow().setBackgroundDrawable(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li><li><p>避免绘制不必要的区域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定绘制的区域</span></span><br><span class="line">Canvas.clipRect();</span><br><span class="line"><span class="comment">//Return true if the specified rectangle, after being transformed by the current matrix, would lie completely outside of the current clip. Call this to check if an area you intend to draw into is clipped out (and therefore you can skip making the draw calls).</span></span><br><span class="line">Canvas.quickReject();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the bounds of the current clip (in local coordinates) in the</span></span><br><span class="line"><span class="comment"> * bounds parameter, and return true if it is non-empty. This can be useful</span></span><br><span class="line"><span class="comment"> * in a way similar to quickReject, in that it tells you that drawing</span></span><br><span class="line"><span class="comment"> * outside of these bounds will be clipped out.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bounds Return the clip bounds here. If it is null, ignore it but</span></span><br><span class="line"><span class="comment"> *               still return true if the current clip is non-empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the current clip is non-empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getClipBounds</span><span class="params">(@Nullable Rect bounds)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p><strong>无用</strong>内存不能被释放，或者短时间内大量分配内存，使得可用内存不足，将导致以下两种负面影响：</p><ol><li>频繁GC，而GC 需要占用CPU 时间，使得其他工作被延迟，典型的结果是无法在16 ms 内完成一帧内容的绘制，出现丢帧。</li><li>遭遇<code>OutOfMemoryException</code>。</li></ol><h3 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>避免在循环中创建对象。拼接字符串也会创建对象。</li><li>避免在<code>View.onDraw()</code>等方法中创建对象。</li><li>使用内部类时，注意内存泄露。</li><li>按需（尺寸）加载图片。</li></ul><h2 id="耗电优化-1"><a href="#耗电优化-1" class="headerlink" title="耗电优化"></a>耗电优化</h2><p>Android 5.0 开始提供了 <code>JobScheduler</code>，此API 提供了延迟执行任务的功能。</p>]]></content>
    
    <summary type="html">
    
      Android性能优化相关理论与思想。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化工具篇</title>
    <link href="http://yoursite.com/2018/06/29/Android/Android%20%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E7%AF%87/"/>
    <id>http://yoursite.com/2018/06/29/Android/Android 优化/性能优化工具篇/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T07:31:51.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="善假于物"><a href="#善假于物" class="headerlink" title="善假于物"></a>善假于物</h1><p>Android 提供了一些工具来帮助我们<strong>寻找优化点</strong>。</p><h2 id="开发者选项"><a href="#开发者选项" class="headerlink" title="开发者选项"></a>开发者选项</h2><h3 id="调试GPU过度绘制"><a href="#调试GPU过度绘制" class="headerlink" title="调试GPU过度绘制"></a><a href="https://developer.android.com/studio/profile/inspect-gpu-rendering#debug_overdraw" target="_blank" rel="noopener">调试GPU过度绘制</a></h3><p><strong>调试GPU过度绘制（Debug GPU Overdraw）</strong>，可将绘制次数可视化，开发者可轻易发现过度绘制的区域。 </p><p><img src="http://pb88ntxoi.bkt.clouddn.com/image/android/gpu-overdraw.png" alt="GPU Overdraw"></p><h3 id="GPU呈现模式分析"><a href="#GPU呈现模式分析" class="headerlink" title="GPU呈现模式分析"></a><a href="https://developer.android.com/studio/profile/inspect-gpu-rendering#profile_rendering" target="_blank" rel="noopener">GPU呈现模式分析</a></h3><p>GPU呈现模式分析（Profile GPU Rendering），将界面绘制时间通过条形图的形式展现出来。每一个长条柱表示一帧的绘制，长条柱由不同的颜色区域组成，每一个颜色代表了在这一帧绘制中的一个阶段。比如：</p><ul><li>draw 阶段，包含了<code>onDraw()</code> 等方法的执行时间。</li><li>Input Handling 阶段，包含了处理事件（比如触摸事件）的时间。</li></ul><p>颜色区域越长，表示该阶段消耗的时间越长。</p><p><img src="http://pb88ntxoi.bkt.clouddn.com/image/android/profile-gpu-rendering-graph.png" alt="profile-gpu-rendering-graph"></p><h2 id="Hierarchy-Viewer"><a href="#Hierarchy-Viewer" class="headerlink" title="Hierarchy Viewer"></a><a href="https://developer.android.com/studio/profile/hierarchy-viewer" target="_blank" rel="noopener">Hierarchy Viewer</a></h2><h3 id="工具提供的信息"><a href="#工具提供的信息" class="headerlink" title="工具提供的信息"></a>工具提供的信息</h3><ul><li>界面<code>View</code>树的层次结构，可用于定位冗余的层次结构。</li><li>观察同一棵子<code>View</code>树下的<code>View</code>的相对绘制速率，可用于定位绘制效率低的<code>View</code>。</li></ul><h2 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a><a href="https://developer.android.com/studio/profile/traceview" target="_blank" rel="noopener">TraceView</a></h2><p>主要用于观察<strong>App 中方法的执行</strong>。使用方法是，生成报告文件，然后用DDMS打开报告文件进行分析。生成报告的方式有两种：</p><ul><li><p>使用DDMS 直接生成指定时间内的所有方法调用的trace文件，可能因信息量过大而难以分析。</p></li><li><p>在代码中指定trace的范围，运行App 使执行此段代码，生成trace文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Debug.startMethodTracing(Environment.getExternalStorageDirectory() + File.separator + <span class="string">"traceFileName.trace"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Debug.stopMethodTracing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="工具提供的信息-1"><a href="#工具提供的信息-1" class="headerlink" title="工具提供的信息"></a>工具提供的信息</h3><ul><li><p>各个线程在指定时间内调用的方法。<strong>GC线程</strong>尤其值得留意。</p><p><img src="http://pb88ntxoi.bkt.clouddn.com/image/android/traceview-timeline-pane.png" alt="traceview-timeline-pane"></p></li><li><p>方法的执行时间、调用者、方法中调用的方法等。</p><p><img src="http://pb88ntxoi.bkt.clouddn.com/image/android/traceview-profile-pane.png" alt="traceview-profile-pane"></p></li></ul><h2 id="systrace"><a href="#systrace" class="headerlink" title="systrace"></a><a href="https://developer.android.com/studio/command-line/systrace" target="_blank" rel="noopener">systrace</a></h2><p>跟TraceView差不多，也是生成报告文件（html文件，用chrome打开）进行分析。不同的是TraceView 提供的是指定App 的方法执行信息，而systrace 是从系统层面出发，提供了比如帧绘制、事件方面的信息。</p><p>注：官方教程中提到的使用方法，在命令行调用SDK 中的systrace.py 脚本生成报告文件会执行失败。只能在Android Device Monitor 中使用。</p><p>由于报告中包含的信息过多，systrace 允许我们在代码中添加标签，方便定位问题。与TraceView 中指定生成报告的范围不同，此方法只是在报告中添加标签，以便辨识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Trace.beginSection(<span class="string">"Trace Label"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Trace.endSection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工具提供的信息-2"><a href="#工具提供的信息-2" class="headerlink" title="工具提供的信息"></a>工具提供的信息</h3><ul><li><p>通过小圆圈展示了每一帧的绘制情况，黄色和红色表示这一帧的绘制时间超过16 ms。</p><p><img src="http://pb88ntxoi.bkt.clouddn.com/image/android/systrace-frame-unselected.png" alt="systrace-frame-unselected"></p></li><li><p>点击小圆圈，可以在面板看到更多信息，包括绘制这一帧时所执行的方法，甚至优化建议。</p><p><img src="http://pb88ntxoi.bkt.clouddn.com/image/android/systrace-frame-selected.png" alt="systrace-frame-selected.png"></p></li></ul><h2 id="内存分析工具"><a href="#内存分析工具" class="headerlink" title="内存分析工具"></a>内存分析工具</h2><h3 id="Memory-Monitor"><a href="#Memory-Monitor" class="headerlink" title="Memory Monitor"></a>Memory Monitor</h3><p>可以观察内存在时间线上的实时变动，已用内存的分配与释放，内存的大小等。当已用内存频繁抖动时，可得知发生了频繁的GC。</p><h3 id="Heap-Viewer"><a href="#Heap-Viewer" class="headerlink" title="Heap Viewer"></a>Heap Viewer</h3><p>DDMS 的功能，可以查看各种类型的数据所占用内存空间。每次GC发生后会更新Heap。可用于定位内存泄露。</p><h3 id="Allocation-Tracker"><a href="#Allocation-Tracker" class="headerlink" title="Allocation Tracker"></a>Allocation Tracker</h3><p>可查看内存分配的时间，以及产生分配内存行为的方法。可用于定位内存泄露。</p><p>Tips：Android Device Monitor 里的用不了。Android Studio 3.0以下有集成，3.0及以上被去除。</p><h2 id="Battery-Historian"><a href="#Battery-Historian" class="headerlink" title="Battery Historian"></a>Battery Historian</h2><p>可用来观察电量的消耗情况。此工具无法直接提供各个App或任务消耗电量的信息，而是提供了以下信息：</p><ul><li>各个App或任务执行的时长、频率等。</li><li>设备在特定时段内消耗的电量。</li></ul><p><img src="http://pb88ntxoi.bkt.clouddn.com/image/android/battery-historian-timeline.png" alt="battery-historian-timeline"></p><h2 id="Android-Profiler"><a href="#Android-Profiler" class="headerlink" title="Android Profiler!!!"></a>Android Profiler!!!</h2><p>Android Studio 3.0 开始提供了强大的Android Profiler。此工具提供了CPU 执行、内存、网络请求三方面的信息。</p><h3 id="CPU执行分析"><a href="#CPU执行分析" class="headerlink" title="CPU执行分析"></a>CPU执行分析</h3><h4 id="使用要点"><a href="#使用要点" class="headerlink" title="使用要点"></a>使用要点</h4><p>观察方法的执行时长。</p><h4 id="执行时间类型"><a href="#执行时间类型" class="headerlink" title="执行时间类型"></a>执行时间类型</h4><ul><li><strong>self</strong>：方法自身所占的时间，不包括所调用的方法的执行时间。</li><li><strong>children</strong>：方法中调用其他方法所占的时间。</li><li><strong>total</strong>：方法的总执行时间，等于self + children。</li></ul><h4 id="执行时间统计方式"><a href="#执行时间统计方式" class="headerlink" title="执行时间统计方式"></a>执行时间统计方式</h4><p>通过不同的统计方式，我们可以观察（多次）执行一个方法的真正影响面。</p><h5 id="统计方法在每次调用中的执行时长"><a href="#统计方法在每次调用中的执行时长" class="headerlink" title="统计方法在每次调用中的执行时长"></a>统计方法在每次调用中的执行时长</h5><p>Call Chart：展示指定时间内的所有调用栈。可用于观察一个方法每次调用的执行时长。</p><h5 id="统计在相同调用链下方法的总执行时长"><a href="#统计在相同调用链下方法的总执行时长" class="headerlink" title="统计在相同调用链下方法的总执行时长"></a>统计在相同调用链下方法的总执行时长</h5><p>整合指定时间段内相同的调用链。可用于观察一个方法在指定时间段内，特定调用链下的总执行时长。举例，三次发生了<code>A-&gt;B</code>的调用链，可观察到三次调用的总执行时长。</p><ul><li>Frame Chart：以图表的形式展示。</li><li>Top Down：以调用链的形式展示。</li></ul><h5 id="统计方法的总执行时长"><a href="#统计方法的总执行时长" class="headerlink" title="统计方法的总执行时长"></a>统计方法的总执行时长</h5><p>Bottom Up：整合指定时间段内相同方法的调用。可用于观察一个方法在指定时间段内所有被调用的总执行时长。</p><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><h4 id="在不同系统上的使用方式"><a href="#在不同系统上的使用方式" class="headerlink" title="在不同系统上的使用方式"></a>在不同系统上的使用方式</h4><ul><li><p>Android 8.0以下</p><ul><li><p>需要<a href="https://developer.android.com/studio/preview/features/android-profiler.html#advanced-profiling" target="_blank" rel="noopener">enable advanced profiling</a> </p></li><li><p>需要手动录制内存分配</p><blockquote><p>If your device is running Android 7.1 or lower, click <strong>Record memory allocations</strong> <img src="https://developer.android.com/studio/images/buttons/profiler-record.png" alt="img"> in the Memory Profiler toolbar. While recording, Android Monitor tracks all allocations that occur in your app. When you’re done, click <strong>Stop recording</strong> <img src="https://developer.android.com/studio/images/buttons/profiler-record-stop.png" alt="img"> (the same button; see video 2) to view the allocations. </p></blockquote></li></ul></li><li><p>Android 8.0开始</p><blockquote><p>On Android 8.0 and higher, advanced profiling is always enabled for debuggable apps. </p></blockquote><blockquote><p>If your device is running Android 8.0 or higher, you can view your object allocations at any time as follows: Just click-and-hold in the timeline and drag to select the region where you want to view the allocations </p></blockquote></li></ul><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>观察内存分配在时间线上的<strong>变化</strong>（分配与GC）。</li><li>观察不同的<strong>内存类型及其大小</strong>。</li><li>观察产生分配内存行为的<strong>调用栈</strong>。</li><li>观察对象的<strong>引用者</strong>。</li></ul><h4 id="使用要点-1"><a href="#使用要点-1" class="headerlink" title="使用要点"></a>使用要点</h4><ul><li>观察内存变化，看是否发生了内存抖动，即是否频繁GC。常见原因：<ul><li>在循环中创建对象。拼接字符串也会创建对象。</li><li>在<code>View.onDraw()</code>等方法中创建对象。</li></ul></li><li>在内存使用后Dump Heap 来观察是否被正常释放。常见场景：<ul><li>关闭Activity后，Activity是否被正常释放。</li><li>图片不需要的时候，是否被正常释放。</li></ul></li><li>对于未正常释放的内存（往往比较大才会被发现），通过追踪分配的调用栈以及持有者，来解决泄露问题。</li></ul><h3 id="网络请求分析"><a href="#网络请求分析" class="headerlink" title="网络请求分析"></a>网络请求分析</h3><p>可用来观察App 的网络请求。</p><h4 id="工具提供的信息-3"><a href="#工具提供的信息-3" class="headerlink" title="工具提供的信息"></a>工具提供的信息</h4><ul><li>网络请求的发起、执行时长。</li><li>观察发起网络请求的线程、调用栈，以及请求的详细信息。</li></ul>]]></content>
    
    <summary type="html">
    
      Android性能优化工具。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 杂记</title>
    <link href="http://yoursite.com/2018/06/29/Android/Android%E6%9D%82%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/29/Android/Android杂记/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T08:32:34.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Device-Compatibility"><a href="#Device-Compatibility" class="headerlink" title="Device Compatibility"></a>Device Compatibility</h2><ol><li><p><strong>Device features</strong></p><ul><li><p>declare necessary features</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">"android.hardware.sensor.compass"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:required</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>check for the device feature at runtime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PackageManager pm = getPackageManager();</span><br><span class="line"><span class="keyword">if</span> (!pm.hasSystemFeature(PackageManager.FEATURE_SENSOR_COMPASS)) &#123;</span><br><span class="line">    <span class="comment">// This device does not have a compass, turn off the compass feature</span></span><br><span class="line">    disableCompassFeature();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Some system <strong>permissions</strong> implicitly require the availability of a device feature. For example, if your app requests permission to access to BLUETOOTH, this implicitly requires the <code>FEATURE_BLUETOOTH</code> device feature. You can disable filtering based on this feature and make your app available to devices without Bluetooth by setting the required attribute to “false” in the <code>&lt;uses-feature&gt;</code> tag. </p></li></ul></li><li><p><strong>Platform version</strong></p><ul><li><p>declare the minimum version with which your app is compatible and the highest version on which you’ve optimized your app</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:minSdkVersion</span>=<span class="string">"14"</span> <span class="attr">android:targetSdkVersion</span>=<span class="string">"19"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>check the API level at runtime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">    <span class="comment">// Running on something older than API level 11, so disable</span></span><br><span class="line">    <span class="comment">// the drag/drop features that use ClipboardManager APIs</span></span><br><span class="line">    disableDragAndDrop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Screen configuration</strong></p><ul><li>screen size: small, normal, large, and xlarge</li><li>densities: mdpi (medium), hdpi (hdpi), xhdpi (extra high), xxhdpi (extra-extra high), and others</li></ul></li><li><p>总结</p><ul><li>There are two types of compatibility: <em>device compatibility</em> and <em>app compatibility</em>.</li><li>AndroidManifest.xml 文件中声明“要求”的标签的名字都是“uses-XXX”</li></ul></li></ol><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a><strong>Intent</strong></h2><h3 id="Intent-1"><a href="#Intent-1" class="headerlink" title="Intent"></a>Intent</h3><ul><li><p>Intent 的常用<strong>Action</strong>定义在Intent的类里，以及Android 框架的其他类里，比如<a href="https://developer.android.com/reference/android/provider/Settings.html" target="_blank" rel="noopener">Settings</a>，用于打开设置界面。自定义的Intent Action一般以包名作为前缀，并以大写后缀部分，如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **Data**是一个Uri。Intent的```setData()```和```setType()```会互相置空对方，因此当需要设置两者的时候，使用```setDataAndType()```方法。</span><br><span class="line"></span><br><span class="line">- **category** 提供了一些额外的信息。对用于启动Activity的隐式Intent，系统在解析其可接收的组件时，会假定该Intent携带```CATEGORY_DEFAULT```的category（但系统**不会**自动在Intent中添加这个category）。因此，对于支持隐式Intent启动的Activity，必须在Intent Filter中添加```CATEGORY_DEFAULT```。可以认为```CATEGORY_DEFAULT```将一个Activity标志为可被隐式启动的。</span><br><span class="line"></span><br><span class="line">- 像Action一样，Intent也定义了很多标准[**Extra**常量](https://developer.android.com/reference/android/content/Intent.html#EXTRA_ALARM_COUNT)。</span><br><span class="line"></span><br><span class="line">- 由于设备上不一定有能响应隐式Intent的app，使用隐式Intent启动Activity时，应先进行检查。</span><br><span class="line">    ```java</span><br><span class="line">    if (sendIntent.resolveActivity(getPackageManager()) != null) &#123;</span><br><span class="line">        startActivity(sendIntent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></li><li><p>当响应隐式Intent的Activity有多个时，系统会弹出选择界面供用户选择，并且有选项可供用户将某个Activity设置为默认Activity，下次响应该Intent类型时，将直接启动默认Activity。App也可如下强制每次都调起选择界面。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Intent sendIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// This says something like "Share this photo with"</span></span><br><span class="line">String title = getResources().getString(R.string.chooser_title);</span><br><span class="line"><span class="comment">// Create intent to show the chooser dialog</span></span><br><span class="line">Intent chooser = Intent.createChooser(sendIntent, title);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify the original intent will resolve to at least one activity</span></span><br><span class="line"><span class="keyword">if</span> (sendIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    startActivity(chooser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.android.com/guide/components/intents-common.html" target="_blank" rel="noopener">常用Intent</a></p></li></ul><h3 id="Intent-Filter"><a href="#Intent-Filter" class="headerlink" title="Intent Filter"></a>Intent Filter</h3><ul><li>Intent Filter<ul><li>只对隐式Intent起作用。</li><li>一个组件可以声明多个Intent Filter。隐式Intent在解析时，只要能通过组件任意一个Filter，该组件即可响应该Intent。</li><li>组件在声明Intent Filter时，应该将不同的功能分成不同的Filter。</li><li><a href="https://developer.android.com/guide/topics/manifest/data-element.html" target="_blank" rel="noopener"><strong>data</strong></a> 包含两部分，mime type和URI结构。</li></ul></li><li><a href="https://developer.android.com/guide/components/intents-filters.html#Resolution" target="_blank" rel="noopener">Intent 解析</a><ol><li>Intent Filter的作用是声明了一个组件可以处理的Intent信息，比如Action、Category和数据类型、数据URI结构。</li><li>隐式Intent携带了希望执行的Action，该Intent所属的Category，以及包含的数据及其类型。</li><li>综上，一个Intent命中一个组件的条件是，该Intent符合该组件的任意一个Intent Filter的声明，即该Intent携带的信息被<strong>全部包含</strong>在一个Intent Filter的声明中。</li></ol></li><li><p>匹配Intent不仅可以用来寻找响应的组件，也可以用来查询设备上有哪些组件可以匹配指定的Intent。<a href="https://developer.android.com/reference/android/content/pm/PackageManager.html" target="_blank" rel="noopener">PackageManager</a>提供了一些<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Task and back stack</span><br><span class="line"></span><br><span class="line">- ```Intent Flag</span><br></pre></td></tr></table></figure></p><ul><li><p>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    - 使用```FLAG_ACTIVITY_CLEAR_TOP```调起已经存在于某个task中的Activity时，会清空该task中位于目标Activity之上的其他Activity。常与```FLAG_ACTIVITY_NEW_TASK```配合使用。</span><br><span class="line">- ```Launch Mode```  </span><br><span class="line">    - 对于launchMode为```standard```的Activity，不管用于调起它们的Intent设置了怎样的flag，每次被调起，都会创建新的实例。</span><br><span class="line">- ```Document``` </span><br><span class="line">    - ```FLAG_ACTIVITY_NEW_DOCUMENT```和```documentLaunchMode```的```intoExist```与```always```属性值仅对launchMode为```standard```的Activity起作用。</span><br><span class="line">- Activity的调起结果，由以下三个元素决定：</span><br><span class="line">    - Intent的```Flag</span><br></pre></td></tr></table></figure></p></li><li><p>Activity的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    - Activity的```documentLaunchMode```  </span><br><span class="line">- 这三个元素共同确定了以下维度的结果：  </span><br><span class="line">    1. 是否在已存在的task中查找目标Activity</span><br><span class="line">    2. 当满足1，查找task的范围（仅当前task还是所有task）</span><br><span class="line">    3. 当满足1，且在已存在的task中找到目标Activity，如何处理该task中的其他Activity。</span><br><span class="line">    4. 是否创建新实例（onCreate还是onNewIntent）。与1不是互斥关系，查找目标Activity不意味着不创建新实例。</span><br><span class="line">    5. 若需要创建新实例，新实例创建的task。推论（未证实）：与1有关联，若需要查找task，则新实例将被创建于目标task，不然查找task来干嘛？仅仅是用来销毁？</span><br><span class="line">    6. 当目标Activity结束时，是否在```Recents Screen```中留下入口。</span><br><span class="line"></span><br><span class="line">## Fragment</span><br><span class="line"></span><br><span class="line">- 每个Fragment都需要一个id或者tag来唯一标识。</span><br><span class="line"></span><br><span class="line">- Fragment 的backStack维护的是transaction，而不是Fragment。</span><br><span class="line">    &gt; The order in which you add changes to a FragmentTransaction doesn&apos;t matter, except:  </span><br><span class="line">    &gt;</span><br><span class="line">    &gt; You must call `commit()` last.  </span><br><span class="line">    &gt;</span><br><span class="line">    &gt; If you&apos;re adding multiple fragments to the same container, then the order in which you add them determines the order they appear in the view hierarchy.</span><br><span class="line"></span><br><span class="line">    &gt; If you do not call `addToBackStack()` when you perform a transaction that removes a fragment, then that fragment is destroyed when the transaction is committed and the user cannot navigate back to it. Whereas, if you do call `addToBackStack()` when removing a fragment, then the fragment is stopped and will be resumed if the user navigates back.</span><br><span class="line"></span><br><span class="line">- 提交与执行```FragmentTraction</span><br></pre></td></tr></table></figure></p></li><li><figure class="highlight plain"><figcaption><span>事务被提交，但不会马上执行，而是被异步执行。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">    - ```commitNow()``` 事务被提交并同步执行。在此方法返回前，事务中添加或去除Fragment等操作已被执行。</span><br><span class="line">    - ```commitAllowingStateLoss()```允许在Activity保存状态之后提交事务。</span><br><span class="line">    - ```executePendingTransactions()``` 马上**同步**执行所有提交但未执行的事务。</span><br><span class="line">    &gt; 批注：在FragmentManager中，维护一个事务的队列，使用```Handler.post()```来异步执行事务。```FragmentTransaction.commit()```方法实际是向FragmentManager入列一个事务。而```commitNow()```方法则是调用FragmentManager同步执行一个事务。</span><br><span class="line"></span><br><span class="line">- Fragment的生命周期受Activity影响，但并不一定是对应关系。特别是对于动态添加的Fragment，比如在Activity的resumed状态下添加Fragment，Fragment的生命周期是“一次性”走到```onResume()```的.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## LayoutInflater</span><br><span class="line"></span><br><span class="line">- `LayoutInflater`的多个`inflate()`重载方法，最终都是调用`inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)`版本，该方法会根据XML布局文件的解析结果`parser`创建`View`树，并返回根`View`。</span><br><span class="line"></span><br><span class="line">- `createViewFromTag()`顾名思义，该方法会根据`parser`解析出来的标签名和属性等信息，创建**一个**`View`。在实现中，会先尝试调用`Factory2`和`Factory`的`onCreateView()`来创建`View`，如果返回`null`，再调用自身的`onCreateView()`。</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public interface Factory &#123;</span><br><span class="line">      /**</span><br><span class="line">       * Hook you can supply that is called when inflating from a LayoutInflater.</span><br><span class="line">       * You can use this to customize the tag names available in your XML</span><br><span class="line">       * layout files.</span><br><span class="line">       *</span><br><span class="line">       * &lt;p&gt;</span><br><span class="line">       * Note that it is good practice to prefix these custom names with your</span><br><span class="line">       * package (i.e., com.coolcompany.apps) to avoid conflicts with system</span><br><span class="line">       * names.</span><br><span class="line">       *</span><br><span class="line">       * @param name Tag name to be inflated.</span><br><span class="line">       * @param context The context the view is being created in.</span><br><span class="line">       * @param attrs Inflation attributes as specified in XML file.</span><br><span class="line">       *</span><br><span class="line">       * @return View Newly created view. Return null for the default</span><br><span class="line">       *         behavior.</span><br><span class="line">       */</span><br><span class="line">      public View onCreateView(String name, Context context, AttributeSet attrs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public interface Factory2 extends Factory &#123;</span><br><span class="line">      /**</span><br><span class="line">       * Version of &#123;@link #onCreateView(String, Context, AttributeSet)&#125;</span><br><span class="line">       * that also supplies the parent that the view created view will be</span><br><span class="line">       * placed in.</span><br><span class="line">       *</span><br><span class="line">       * @param parent The parent that the created view will be placed</span><br><span class="line">       * in; &lt;em&gt;note that this may be null&lt;/em&gt;.</span><br><span class="line">       * @param name Tag name to be inflated.</span><br><span class="line">       * @param context The context the view is being created in.</span><br><span class="line">       * @param attrs Inflation attributes as specified in XML file.</span><br><span class="line">       *</span><br><span class="line">       * @return View Newly created view. Return null for the default</span><br><span class="line">       *         behavior.</span><br><span class="line">       */</span><br><span class="line">      public View onCreateView(View parent, String name, Context context, AttributeSet attrs);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>从这两个接口的注释可以看出，它们可以作为“Hook”，用来自定义创建<code>View</code>的行为。<code>AppCompat</code>这些支持库就是利用它在加载布局时，识别XML布局文件中的<code>TextView</code>等标签，并创建对应的<code>AppCompatTextView</code>等。</p></li></ul>]]></content>
    
    <summary type="html">
    
      Android一些琐碎的笔记和心得。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 资源加载</title>
    <link href="http://yoursite.com/2018/06/29/Android/Android%20%E8%B5%84%E6%BA%90/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/06/29/Android/Android 资源/资源加载/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T04:37:55.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h2><p>Android中与资源相关的类主要有<code>Resources</code>、<code>ResourcesImpl</code>、<code>ResourcesManager</code>、Java层的<code>AssetManager</code>和Native层的<code>AssetManager</code>。</p><h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a><code>Resources</code></h3><p>提供了大多数与应用开发直接相关的加载资源的方法，比如<code>getColor(int resId)</code>等。实现上是通过<code>AssetManager</code>来加载资源并进行解析。</p><h3 id="AssetManager"><a href="#AssetManager" class="headerlink" title="AssetManager"></a><code>AssetManager</code></h3><p>Java层的<code>AssetManager</code>是对Native层<code>AssetManager</code>的封装，为上层提供了加载资源的方法。</p><h4 id="加载资源包"><a href="#加载资源包" class="headerlink" title="加载资源包"></a>加载资源包</h4><p>一般而言，一个App至少会引用两个资源包：系统资源包和App的资源包。一个<code>AssetManager</code>对象可加载多个资源包。App在创建<code>AssetManager</code>的时候，会先加载系统资源包，再加载App资源包。这样，通过一个<code>AssetManager</code>对象就可以访问系统资源包和App资源包的资源了。</p><p><code>AssetManager.addAssetPath(String path)</code>是一个<code>@hide</code>方法，调用这个方法可以加载指定的资源包。</p><p>在android的资源中，还有个<a href="https://android.googlesource.com/platform/frameworks/base/+/ics-mr1-release/libs/utils/README" target="_blank" rel="noopener">overlay</a>的概念。用于指定覆盖的资源。</p><h2 id="访问资源"><a href="#访问资源" class="headerlink" title="访问资源"></a>访问资源</h2><p>由于资源id包含了package id的信息，<code>AssetManager</code>通过解析资源id，即可知道从哪个资源包来加载资源。</p>]]></content>
    
    <summary type="html">
    
      Android 资源加载相关知识点。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Dex文件</title>
    <link href="http://yoursite.com/2018/06/29/Android/Dex%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Dex%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/06/29/Android/Dex与类加载/Dex文件/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T07:34:39.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dex"><a href="#Dex" class="headerlink" title="Dex"></a>Dex</h2><p>Dex (dalvik executables) 文件是二进制文件，而非文本文件，是编译java 代码的结果。</p><blockquote><p>Android runtime (ART) is the managed runtime used by applications and some system services on Android. ART and its predecessor Dalvik were originally created specifically for the Android project. ART as the runtime executes the Dalvik Executable format and Dex bytecode specification. </p></blockquote><p>Dex 文件类似一个数据包，由 header 等多个数据段拼接而成。</p><h3 id="Dex文件的结构"><a href="#Dex文件的结构" class="headerlink" title="Dex文件的结构"></a>Dex文件的结构</h3><p>在Dex 文件中，<strong>data（数据区）</strong>不是以类为单位来存储代码，而是分为字符串区域、filed区域、method区域等，所有的数据被分块存储，不同的区块之间通过引用来指明关系。</p><p>举例：method区域中一个方法的记录中，有着不同的字段，记录着方法名等。这些字段并非直接存储着这些数据，而是存储着这些数据在Dex 文件中位置的“指针”。比如方法名字段，实际上是一个代表着方法名字符串在字符串区域位置的数字。例如方法名字段为0x5，意味着方法名是字符串区域中的第五个字符串。</p><p>值得一提的是，字符串区域，不仅仅存储着代码中的字符串常量，也存储着类名、方法名等字符串。</p><p><img src="http://pb88ntxoi.bkt.clouddn.com/image/android/Jar%20&amp;%20Apk%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="Jar &amp; Apk 文件结构"></p><table><thead><tr><th>数据名称</th><th>解释</th></tr></thead><tbody><tr><td>header</td><td>dex文件头部，记录整个dex文件的相关属性</td></tr><tr><td>string_ids</td><td>字符串数据索引，记录了每个字符串在数据区的偏移量</td></tr><tr><td>type_ids</td><td>类似数据索引，记录了每个类型的字符串索引</td></tr><tr><td>proto_ids</td><td>原型数据索引，记录了方法声明的字符串，返回类型字符串，参数列表</td></tr><tr><td>field_ids</td><td>字段数据索引，记录了所属类，类型以及方法名</td></tr><tr><td>method_ids</td><td>类方法索引，记录方法所属类名，方法声明以及方法名等信息</td></tr><tr><td>class_defs</td><td>类定义数据索引，记录指定类各类信息，包括接口，超类，类数据偏移量</td></tr><tr><td>data</td><td>数据区，存储代码的真实数据</td></tr><tr><td>link_data</td><td>连接数据区</td></tr></tbody></table><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><table><thead><tr><th>字段名称</th><th>偏移值</th><th>长度</th><th>说明</th></tr></thead><tbody><tr><td>magic</td><td>0x0</td><td>8</td><td>魔数字段，值为”dex\n035\0”</td></tr><tr><td>checksum</td><td>0x8</td><td>4</td><td>校验码</td></tr><tr><td>signature</td><td>0xc</td><td>20</td><td>sha-1签名</td></tr><tr><td>file_size</td><td>0x20</td><td>4</td><td>dex文件总长度</td></tr><tr><td>header_size</td><td>0x24</td><td>4</td><td>文件头长度，009版本=0x5c,035版本=0x70</td></tr><tr><td>endian_tag</td><td>0x28</td><td>4</td><td>标示字节顺序的常量</td></tr><tr><td>link_size</td><td>0x2c</td><td>4</td><td>链接段的大小，如果为0就是静态链接</td></tr><tr><td>link_off</td><td>0x30</td><td>4</td><td>链接段的开始位置</td></tr><tr><td>map_off</td><td>0x34</td><td>4</td><td>map数据基址</td></tr><tr><td>string_ids_size</td><td>0x38</td><td>4</td><td>字符串列表中字符串个数</td></tr><tr><td>string_ids_off</td><td>0x3c</td><td>4</td><td>字符串列表基址</td></tr><tr><td>type_ids_size</td><td>0x40</td><td>4</td><td>类列表里的类型个数</td></tr><tr><td>type_ids_off</td><td>0x44</td><td>4</td><td>类列表基址</td></tr><tr><td>proto_ids_size</td><td>0x48</td><td>4</td><td>原型列表里面的原型个数</td></tr><tr><td>proto_ids_off</td><td>0x4c</td><td>4</td><td>原型列表基址</td></tr><tr><td>field_ids_size</td><td>0x50</td><td>4</td><td>字段个数</td></tr><tr><td>field_ids_off</td><td>0x54</td><td>4</td><td>字段列表基址</td></tr><tr><td>method_ids_size</td><td>0x58</td><td>4</td><td>方法个数</td></tr><tr><td>method_ids_off</td><td>0x5c</td><td>4</td><td>方法列表基址</td></tr><tr><td>class_defs_size</td><td>0x60</td><td>4</td><td>类定义标中类的个数</td></tr><tr><td>class_defs_off</td><td>0x64</td><td>4</td><td>类定义列表基址</td></tr><tr><td>data_size</td><td>0x68</td><td>4</td><td>数据段的大小，必须4k对齐</td></tr><tr><td>data_off</td><td>0x6c</td><td>4</td><td>数据段基址</td></tr></tbody></table><h2 id="Smali"><a href="#Smali" class="headerlink" title="Smali"></a>Smali</h2><p>Dex 文件作为二进制文件，可读性和可编辑性很差。dex2Jar 等工具，可以将Dex 文件反编成Jar 文件甚至解析成java 文件。值得注意的是，Dex 文件内容与Java 代码不能完全对应，即Dex 文件中的代码是以指令为基本单位，而Java 代码作为高级语言，往往一个语句可编译成多个指令，因此在反汇编过程中会有改动或信息丢失。</p><p>Smali 类似汇编语言，是根据Dex 文件字节码格式，将可读性差的二进制数据解析成可读性更强的指令。将Dex 文件转成Smali 文件的过程称为baksmali ，反过来称为smali。因此Smali 可以指代一种语言、文件格式或者将Smali 文件转成Dex 文件的过程。</p><p>从上面Dex 文件的结构可以看出，Dex 文件中实际上是将不同类型的数据分块存储。在代码区域，存储着函数方法的实现，即编译后的指令。根据Android 对指令集的定义，我们可以解析指令。</p><blockquote><p><a href="https://stackoverflow.com/questions/30837450/what-is-smali-code-android" target="_blank" rel="noopener">What is Smali Code Android</a></p><p><a href="https://www.quora.com/What-is-smali-in-Android" target="_blank" rel="noopener">What is smali in Android? </a></p></blockquote><h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><p>Dex 文件中的代码区，包含了方法中的指令。</p><p>每条指令包含一个<strong>指令码（Op）</strong>，可在<a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode#instructions" target="_blank" rel="noopener">此处</a>查询对应的Op 及其含义，可以理解为不同的指令码对应着不同的操作，如调用方法、赋值等。</p><p>不同指令的指令格式可能不同，比如，调用方法（可能）需要指明调用对象、方法名、参数等，而赋值需要指明赋值对象和值。因此每个指令码对应有一个指令格式，通过<strong>指令格式标识</strong>来指明。指令格式标识大多由三个字符组成，前两个是数字，最后一个是字母。在<a href="https://source.android.com/devices/tech/dalvik/instruction-formats#formats" target="_blank" rel="noopener">此处</a>可查询不同的指令格式。</p><ol><li>第一个数字是表示指令有多少个16位的字组成。</li><li>第二个数字是表示指令最多使用寄存器的个数。特殊标记“r”标识使用一定范围内的寄存器。</li><li>第三个字母为类型码，表示指令用到的额外数据的类型 。</li></ol><blockquote><p><a href="https://www.cnblogs.com/dacainiao/p/6035298.html" target="_blank" rel="noopener">Dalvik指令格式</a></p><p><a href="https://www.cnblogs.com/dacainiao/p/6036834.html" target="_blank" rel="noopener">指令解析</a> </p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/dd864140130/article/details/52076515" target="_blank" rel="noopener">Dalvik字节码指令及Smali文件</a></li><li><a href="https://www.jianshu.com/p/f7f0a712ddfe" target="_blank" rel="noopener">Dex文件格式详解</a></li></ul><h2 id="odex-And-oat"><a href="#odex-And-oat" class="headerlink" title="odex And oat"></a>odex And oat</h2><p>Android 系统在安装app 的时候，会提取dex 文件进行<strong>预处理</strong>，并将处理结果写入 \data\dalvik-cache\ 目录下，运行app 时加载处理过的文件。不同系统的预处理行为有所不同，生成的文件类型也不同，但目标文件名仍然以“.dex”作为后缀。</p><h3 id="5-0-之前的系统"><a href="#5-0-之前的系统" class="headerlink" title="5.0 之前的系统"></a>5.0 之前的系统</h3><p>预处理行为是对dex 文件进行<strong>优化</strong>，生成的文件仍然是字节码文件，文件格式称为odex 或dey。</p><p>虚拟机Dalvik 中包含一个解释器，在运行app 时，加载odex 文件并将指令<strong>逐条解释</strong>成机器码执行。从Android 2.2开始，还引入了<strong>JIT（Just-In-Time）</strong>，在运行时，会识别使用频率高的<strong>代码块</strong>，先编译成本地机器码再执行，以提高效率。顾名思义，JIT 是每次运行时都需要重新进行的操作。</p><h3 id="5-0-及以上系统"><a href="#5-0-及以上系统" class="headerlink" title="5.0 及以上系统"></a>5.0 及以上系统</h3><p>预处理行为是将dex 进行<strong>编译</strong>，将字节码编译成本地机器码，文件格式称为oat 或elf。运行时，ART 加载oat 文件，由于存储的是机器码，无需解释执行字节码指令，从而提高了效率。</p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/Luoshengyang/article/details/18006645" target="_blank" rel="noopener">Android ART运行时无缝替换Dalvik虚拟机的过程分析</a></p>]]></content>
    
    <summary type="html">
    
      Dex文件结构与运行时。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>类加载</title>
    <link href="http://yoursite.com/2018/06/29/Android/Dex%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/06/29/Android/Dex与类加载/类加载机制/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T07:36:08.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h2><p><img src="http://pb88ntxoi.bkt.clouddn.com/image/android/ClassLoader%20%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="ClassLoader 加载流程"></p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li><code>loadClass()</code>是<code>ClassLoader</code>加载类的入口方法，控制着Java 中的类加载流程。如果整个流程未能成功加载类，会抛出<code>ClassNotFoundException</code>。</li><li><code>findLoadedClass(String className)</code>会查找已经加载的类，避免重复加载。</li><li>委托父亲加载器进行加载。</li><li><code>findClass(String className)</code>真正实现类加载器自身加载类的过程。实现一般是定位到类文件（流），读取并调用<code>defineClass()</code>来加载解析类。应用开发者一般通过重写<code>findClass()</code>方法来自定义类加载。</li><li><code>ClassLoader</code>中有多个<code>defineClass()</code>的重载方法，用于将class 文件加载创建对应的<code>Class</code>对象，此过程是由虚拟机实现的，因此这些方法都被<code>final</code> 修饰，不允许子类修改。</li></ol><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="父亲委托机制"><a href="#父亲委托机制" class="headerlink" title="父亲委托机制"></a>父亲委托机制</h4><p><code>ClassLoader</code>会先尝试调用父亲加载器来加载类，如果加载失败（catch 父亲加载器抛出的<code>ClassNotFoundException</code>），再开始自身加载类的过程。</p><h4 id="初始加载器机制"><a href="#初始加载器机制" class="headerlink" title="初始加载器机制"></a>初始加载器机制</h4><p>根据父亲委托机制，一个类的加载过程，可能涉及到多个<code>ClassLoader</code>，我们将发起类加载的类加载器称为一个类的<strong>初始加载器</strong>，而将真正调用<code>defineClass()</code>方法来加载类的类加载器称为<strong>定义加载器</strong>。<code>Class.getClassLoader()</code>方法返回的是定义加载器。虚拟机会使用一个类的定义加载器作为初始加载器来加载这个类引用的其他类，即使这些引用类已经被加载过。</p><h4 id="类型匹配机制"><a href="#类型匹配机制" class="headerlink" title="类型匹配机制"></a>类型匹配机制</h4><p>Java 的类加载机制，使得多个名称相同的类可在Java 虚拟机中并存，它们有着不同的<strong>定义加载器</strong>。可以认为，定义加载器才真正定义了一个类型，不同的类加载器创建了各自的命名空间。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一方面，利用初始加载器机制，当开发者需要动态加载代码模块时，只需使用自定义的类加载器作为定义加载器来加载模块的入口类，随后虚拟机会自动使用这个类加载器来启动加载入口类引用的其他类。</p><p>另一方面，父亲委托机制，保证了一些基础类，可以在各个命名空间中被共享。</p><h2 id="Android-中的类加载器"><a href="#Android-中的类加载器" class="headerlink" title="Android 中的类加载器"></a>Android 中的类加载器</h2><p><img src="http://pb88ntxoi.bkt.clouddn.com/image/android/Android%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="Android 类加载器"></p><h3 id="BaseDexClassLoader"><a href="#BaseDexClassLoader" class="headerlink" title="BaseDexClassLoader"></a><code>BaseDexClassLoader</code></h3><p>Android 使用<code>BaseDexClassLoader</code>来加载类，它是<code>ClassLoader</code>的子类。由于Android 中的虚拟机与JVM 并不兼容，加载的二进制文件也并非class 文件，因此<code>BaseDexClassLoader</code>重写了<code>findClass()</code>，实现从apk、jar或者dex 文件中加载类。从源码可以看到，<code>BaseDexClassLoader</code>并未重写<code>loadClass()</code>，Android 保留了Java 中类加载的特性，包括父亲委托机制、初始加载器机制，类型匹配机制。</p><h4 id="DexPathList"><a href="#DexPathList" class="headerlink" title="DexPathList"></a><code>DexPathList</code></h4><p><code>BaseDexClassLoader</code>的实现并不复杂，类的加载工作主要由其成员<code>DexPathList</code>承担。</p><p><code>DexPathList</code>的成员<code>Element[]</code>存储了apk、jar或者dex 文件的加载结果，这是一个数组，每个文件的加载结果是其中的一个元素。这意味着<code>DexPathList</code>支持加载多个文件。<code>DexPathList.findClass()</code>在加载类时，会遍历数组来寻找。</p><h4 id="DexFile"><a href="#DexFile" class="headerlink" title="DexFile"></a><code>DexFile</code></h4><p>真正实现了对apk、jar或者dex 文件的解析加载，以及加载类。其关键实现是调用了Native 方法。</p><h3 id="PathClassLoader-amp-DexClassLoader"><a href="#PathClassLoader-amp-DexClassLoader" class="headerlink" title="PathClassLoader &amp; DexClassLoader"></a><code>PathClassLoader</code> &amp; <code>DexClassLoader</code></h3><p><code>PathClassLoader</code>和<code>DexClassLoader</code>是<code>BaseDexClassLoader</code>的子类，从源码可以看出，这两者只是简单地提供了构造函数，并没有实质性的工作。二者的不同之处在于后者比前者多了一个<code>String optimizedDirectory</code>这个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@param</span> optimizedDirectory directory where optimized dex files should be written; must not be &#123;<span class="meta">@code</span> <span class="keyword">null</span>&#125;</span><br></pre></td></tr></table></figure><p>源码注释中也指明了这两者的用途：<code>PathClassLoader</code>是android系统和app 的类加载器，而<code>DexClassLoader</code>可以用于加载不随着apk 被安装的代码。</p>]]></content>
    
    <summary type="html">
    
      Java与Android中的类加载机制。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MultiDex</title>
    <link href="http://yoursite.com/2018/06/29/Android/Dex%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/MultiDex/"/>
    <id>http://yoursite.com/2018/06/29/Android/Dex与类加载/MultiDex/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T04:42:35.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="65536-的方法数限制"><a href="#65536-的方法数限制" class="headerlink" title="65536 的方法数限制"></a>65536 的方法数限制</h3><p>Android 官方在<a href="https://developer.android.com/studio/build/multidex" target="_blank" rel="noopener">Multidex</a> 方案中提到，在单个Dex 字节码文件中，能被代码调用的方法数量不能超过65536 个。</p><blockquote><p>65536 represents the total number of references that can be invoked by the code within a single Dalvik Executable (DEX) bytecode file.</p></blockquote><h4 id="Dex-文件中不能存储超过65536个方法？"><a href="#Dex-文件中不能存储超过65536个方法？" class="headerlink" title="Dex 文件中不能存储超过65536个方法？"></a>Dex 文件中不能存储超过65536个方法？</h4><p>在Dex 文件的格式规范中，有两个数据信息与存储的方法相关：</p><ol><li>4个字节表示的 <code>method_id_size</code>，远大于65536.</li><li><p>用于描述方法的数据结构，<code>method_id_item</code>，并没有限制方法数不能超过65536 。</p><p> <strong>method_id_item</strong></p><p> | Name      | Format | Description                              |<br> | ——— | —— | —————————————- |<br> | class_idx | ushort | index into the <code>type_ids</code> list for the definer of this method. This must be a class or array type, and not a primitive type. |<br> | proto_idx | ushort | index into the <code>proto_ids</code> list for the prototype of this method |<br> | name_idx  | uint   | index into the <code>string_ids</code> list for the name of this method. The string must conform to the syntax for <em>MemberName</em>, defined above. |</p><p> 相对应的，在Dalvik virtual machine 的源码中，<a href="https://android.googlesource.com/platform/dalvik/+/android-4.4.2_r2/libdex/DexFile.h" target="_blank" rel="noopener">DexFile.h</a> 中的类和结构体等，存储了Dex 文件被虚拟机加载解析后的数据。其中，用于描述方法的结构体<code>DexMethodId</code>如下。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethodId</span> &#123;</span></span><br><span class="line">    u2  classIdx;           <span class="comment">/* index into typeIds list for defining class */</span></span><br><span class="line">    u2  protoIdx;           <span class="comment">/* index into protoIds for method prototype */</span></span><br><span class="line">    u4  nameIdx;            <span class="comment">/* index into stringIds for method name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>据此，我们可以看出，无论是Dex 文件规范，还是虚拟机的实现中，都没有限制一个Dex 文件中可以声明的方法数不能超过65536。</p><h4 id="能被调用的方法无法超过65536个"><a href="#能被调用的方法无法超过65536个" class="headerlink" title="能被调用的方法无法超过65536个"></a>能被调用的方法无法超过65536个</h4><p>65536 的方法数限制，实际上是来自于指令集中调用方法的指令格式的定义。调用方法的指令中，仅用16位来存储要调用的方法的引用（指代在method_ids section 中第几个方法）。也就是说尽管method_ids section 中可以存储的方法数远远多于65536，但是能被调用的却只有65536个。这也解释了为什么65536 是<strong>被引用的方法数</strong>的上限，而不是App 声明的方法数的上限。即，App 中对Android 框架代码的调用，也会被计入。</p><blockquote><p>invoke-<em>kind</em> {vC, vD, vE, vF, vG}, meth@BBBB </p><p><code>B:</code> method reference index (16 bits) </p></blockquote><p>这也是构建工具报“65536”错误的根本原因，原因不在于构建工具，而在于指令集。否则Google 只需要发布新的构建工具即可。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>Google 为何不推行新的指令集来解决此问题？个人认为应该是为了兼容老版本的系统。推出新的指令集，意味着构建的Dex 文件中的指令格式与以往不同，从而无法被老版本的系统识别。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://stackoverflow.com/questions/21490382/does-the-android-art-runtime-have-the-same-method-limit-limitations-as-dalvik" target="_blank" rel="noopener">Does the Android ART runtime have the same method limit limitations as Dalvik?</a></p><h3 id="LinearAlloc-exceeded"><a href="#LinearAlloc-exceeded" class="headerlink" title="LinearAlloc exceeded"></a>LinearAlloc exceeded</h3><p><a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-dalvik-patch-for-facebook-for-android/10151345597798920" target="_blank" rel="noopener">Facebook hack</a> 和 <a href="https://developer.android.com/studio/build/multidex#limitations" target="_blank" rel="noopener">Android 官网</a> 中，都提到了一个问题，名为<code>LinearAlloc</code>的<code>buffer</code> 溢出而引起崩溃。<code>LinearAlloc</code>缓存了app 中的方法的信息，它在安装和运行app的时候都会发挥作用。</p><h4 id="安装app"><a href="#安装app" class="headerlink" title="安装app"></a>安装app</h4><p>安装的时候，“dexopt” 这个程序在预处理dex 文件的时候会使用<code>LinearAlloc</code>来索引Dex 文件中的所有方法。通过拆分Dex，可以避免此问题。</p><blockquote><p><a href="http://code.google.com/p/android/issues/detail?id=22586" target="_blank" rel="noopener">http://code.google.com/p/android/issues/detail?id=22586</a></p><p>During standard <strong>installation</strong>, a program called “dexopt” runs to prepare your app for the specific phone it’s being installed on. Dexopt uses a fixed-size buffer (called the “LinearAlloc” buffer) to store information about all of the methods in your app. Recent versions of Android use an 8 or 16 MB buffer, but Froyo and Gingerbread (versions 2.2 and 2.3) only have 5 MB. Because older versions of Android have a relatively small buffer, our large number of methods was exceeding the buffer size and causing dexopt to crash.</p></blockquote><blockquote><p>When running on versions prior to Android 5.0 (API level 21), using multidex is not enough to work around the linearalloc limit (<a href="http://b.android.com/78035" target="_blank" rel="noopener">issue 78035</a>). This limit was increased in Android 4.0 (API level 14), but that did not solve it completely. And on versions lower than Android 4.0, you might reach the linearalloc limit before reaching the DEX index limit. </p></blockquote><h4 id="运行app"><a href="#运行app" class="headerlink" title="运行app"></a>运行app</h4><p>运行的时候，app 会使用<code>LinearAlloc</code>来索引方法。由于Facebook 在拆分Dex 之后，运行时将子Dex 注入到<code>ClassLoader</code>中，使得运行时的方法数并没能减少，因此再次遇上了此问题。其通过 JNI 来替换<code>buffer</code>，增大其空间，以此来解决问题。</p><blockquote><p>The LinearAlloc buffer doesn’t just exist in dexopt–it exists within every <strong>running</strong> Android program. While dexopt uses LinearAlloc to to store information about all of the methods in your dex file, the running app only needs it for methods in classes that you are actually using.</p><p>Looking at the definition of the LinearAlloc buffer (<a href="https://github.com/android/platform_dalvik/blob/android-2.3.7_r1/vm/LinearAlloc.h#L33" target="_blank" rel="noopener">https://github.com/android/platform_dalvik/blob/android-2.3.7_r1/vm/LinearAlloc.h#L33</a>), we realized that if we could only increase that buffer from 5 MB to 8 MB, we would be safe! </p><p>That’s when we had the idea of using a JNI extension to replace the existing buffer with a larger one.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是构建时的65536 问题，还是 LinearAlloc exceeded 问题，都将矛头指向了方法数，特别是单个Dex 中的方法数过多的问题。一个可行的解决方案是，在构建的时候将代码拆分到多个Dex。值得一提的是，拆分后所有Dex 的方法数之和<strong>不等于</strong>原先一个Dex 的方法数。</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="构建多Dex"><a href="#构建多Dex" class="headerlink" title="构建多Dex"></a>构建多Dex</h2><h3 id="Ant-构建"><a href="#Ant-构建" class="headerlink" title="Ant 构建"></a>Ant 构建</h3><p><a href="https://android-developers.googleblog.com/2011/07/custom-class-loading-in-dalvik.html" target="_blank" rel="noopener">Custom Class Loading in Dalvik</a></p><h3 id="Gradle-构建"><a href="#Gradle-构建" class="headerlink" title="Gradle 构建"></a>Gradle 构建</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        minSdkVersion <span class="number">21</span> </span><br><span class="line">        targetSdkVersion <span class="number">26</span></span><br><span class="line">        multiDexEnabled <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Now when you build your app, the Android build tools construct a primary DEX file (<code>classes.dex</code>) and supporting DEX files (<code>classes2.dex</code>, <code>classes3.dex</code>, and so on) as needed. The build system then packages all DEX files into your APK. </p></blockquote><h2 id="运行多Dex"><a href="#运行多Dex" class="headerlink" title="运行多Dex"></a>运行多Dex</h2><p>ART本身支持从apk文件中加载多个Dex。ART在app安装时，会进行预处理（Ahead of time compilation），即扫描apk包中所有的Dex文件，进行编译并生成一个oat执行文件。因此ART在运行时只需加载一个oat文件，无需处理加载多Dex 的问题。相对应的，由于运行Dalvik 的系统（5.0以下系统）默认只加载一个Dex（以下简称<strong>主Dex</strong>），开发者需要处理加载运行其他Dex（以下简称<strong>子Dex</strong>） 的问题。</p><h3 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h3><p>在 <a href="https://android-developers.googleblog.com/2011/07/custom-class-loading-in-dalvik.html" target="_blank" rel="noopener">Custom Class Loading in Dalvik</a> 中提到的方案，主要包含以下内容：</p><ol><li>在app 代码设计上，划分模块。</li><li>将不同的模块编入不同的Dex。</li><li>模块之间通过接口关联调用。</li><li>运行时使用<code>DexClassLoader</code>动态加载子Dex，反射创建子Dex 中的业务对象，并强转为约定的接口进行调用。</li></ol><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>此方案适合模块之间较为独立的项目，其缺点是约束性较强，模块之间仅能通过接口或者反射进行调用，并且随着接口的增多，Dex 中的方法数也相应地增多。</p><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>将多个模块共用的基础业务或工具划分到主Dex，利用<code>ClassLoader</code>的父类委托机制，将主Dex 的<code>ClassLoader</code>作为子Dex 的<code>ClassLoader</code>的父亲。通过这种方式，子模块可直接调用主Dex 中的类，无需反射调用以及借助接口。</p><h3 id="Hook-DexPathList"><a href="#Hook-DexPathList" class="headerlink" title="Hook DexPathList"></a>Hook <code>DexPathList</code></h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile <span class="string">'com.android.support:multidex:1.0.3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理是<code>BaseDexClassLoader</code>允许加载多个apk、jar或者dex文件，并从中加载类。需要使用反射来实现。</p><h2 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h2><h3 id="加载Dex-是耗时操作"><a href="#加载Dex-是耗时操作" class="headerlink" title="加载Dex 是耗时操作"></a>加载Dex 是耗时操作</h3><p>需要在划分Dex 的时候按业务模块划分，加载的时候，运用多线程、提前加载等，再结合交互上的进度圈等，优化体验。在<a href="https://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank" rel="noopener">美团的方案</a>中也提到了，通过Hook Instrumentation 的方式来避免多线程加载时的同步问题。</p><h3 id="按需加载Dex"><a href="#按需加载Dex" class="headerlink" title="按需加载Dex"></a>按需加载Dex</h3><p>曾经想要做到按需加载Dex，也就是在需要加载一个类的时候，才去加载这个类所在的Dex。最好的方法自然是使用自定义的类加载器。</p><p>一开始企图使用反射，直接将<code>ContextImpl</code>里的<code>mClassLoader</code>替换为自定义的类加载器，但是由于<strong>初始加载器机制</strong>，使得自定义类加载器并未发挥作用。于是，改变策略，通过反射将自定义类加载器设置为系统类加载器的父亲，以此来获得优先加载权。</p><p>但是又碰到另一个问题：<a href="https://stackoverflow.com/questions/32519420/moving-classes-to-multidex-in-existing-apk" target="_blank" rel="noopener">Dalvik 提前解析依赖类</a>。在Dalvik 上，加载类的时候，会进行优化和验证，此过程会解析类的依赖（但是不会马上加载，在真正执行的时候才会加载）。如果一个类A引用了子Dex 中的类B，在加载类A的时候，如果此时还未加载子Dex，可观察到如下log。即使在真正执行到与依赖的类相关的语句之前加载子Dex，仍然会报<code>NoClassDefFoundError</code>。根据log可猜测，类A在加载的时候，与类B相关的某些指令被替换修改了。这对按需加载的打击是毁灭性的。ART 上则不存在此问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E/dalvikvm: Could not find class &apos;com.example.dex.lib.Test&apos;, referenced from method com.example.dex.App.attachBaseContext</span><br><span class="line">W/dalvikvm: VFY: unable to resolve new-instance 28 (Lcom/example/dex/lib/Test;) in Lcom/example/dex/App;</span><br><span class="line">D/dalvikvm: VFY: replacing opcode 0x22 at 0x0039</span><br><span class="line">D/dalvikvm: DexOpt: unable to opt direct call 0x003e at 0x3b in Lcom/example/dex/App;.attachBaseContext</span><br></pre></td></tr></table></figure><blockquote><p>There’s a thing called <a href="https://android.googlesource.com/platform/dalvik/+/master/docs/verifier.html" target="_blank" rel="noopener">Dalvik verifier</a> that has complex rules for determining inappropriate bytecode. For example, before loading the Application class, VM verifier performs its checks and if it finds a field whose type it can’t resolve (yet), it will not allow to run instruction that accessing this field, even if at that point of time we already patched the ClassLoader and the class could be resolved. </p></blockquote>]]></content>
    
    <summary type="html">
    
      Android 多Dex方案。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>View树的绘制</title>
    <link href="http://yoursite.com/2018/06/29/Android/View/View%E6%A0%91%E7%9A%84%E7%BB%98%E5%88%B6/"/>
    <id>http://yoursite.com/2018/06/29/Android/View/View树的绘制/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T07:38:29.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="View树的绘制"><a href="#View树的绘制" class="headerlink" title="View树的绘制"></a>View树的绘制</h2><h3 id="自顶向下的绘制派发"><a href="#自顶向下的绘制派发" class="headerlink" title="自顶向下的绘制派发"></a>自顶向下的绘制派发</h3><p><code>View</code>树的绘制流程是由<code>ViewRootImpl</code>发起，从根<code>View</code>开始，向子<code>View</code>树派发绘制事件。</p><p><code>View</code>有两个<code>draw()</code>重载方法：</p><ul><li><p><code>View</code>的软件绘制行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Manually render this view (and all of its children) to the given Canvas.</span></span><br><span class="line"><span class="comment"> * The view must have already done a full layout before this function is</span></span><br><span class="line"><span class="comment"> * called.  When implementing a view, implement</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onDraw(android.graphics.Canvas)&#125; instead of overriding this method.</span></span><br><span class="line"><span class="comment"> * If you do need to override this method, call the superclass version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> canvas The Canvas to which the View is rendered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span></span></span><br></pre></td></tr></table></figure></li><li><p>由父<code>View</code>调用，会根据layer type 和硬件加速是否开启选择不同的绘制行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method is called by ViewGroup.drawChild() to have each child view draw itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is where the View specializes rendering behavior based on layer type,</span></span><br><span class="line"><span class="comment"> * and hardware acceleration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span></span></span><br></pre></td></tr></table></figure></li></ul><p><img src="http://pb88ntxoi.bkt.clouddn.com/image/android/View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.png" alt="View树的绘制流程"></p><h3 id="重绘请求"><a href="#重绘请求" class="headerlink" title="重绘请求"></a>重绘请求</h3><h4 id="自底向上传递的invalidate-请求"><a href="#自底向上传递的invalidate-请求" class="headerlink" title="自底向上传递的invalidate 请求"></a>自底向上传递的invalidate 请求</h4><p><code>View.invalidate()</code>的系列重载方法，通过调用<code>ViewParent.invalidateChild()</code>向父<code>View</code>发起重绘请求，请求在<code>View</code>树中逐层往上传递，最后到达<code>ViewRootImpl</code>，由其触发新的绘制流程。</p><p><img src="http://pb88ntxoi.bkt.clouddn.com/image/android/View%E9%87%8D%E7%BB%98%E8%AF%B7%E6%B1%82.png" alt="View重绘请求"></p><h4 id="postInvalidate"><a href="#postInvalidate" class="headerlink" title="postInvalidate"></a>postInvalidate</h4><p>与<code>invalidate()</code>不同，<code>postInvalidate()</code><strong>并非</strong>自底向上地向父<code>View</code>发起请求，而是直接调用<code>attachInfo.mViewRootImpl.dispatchInvalidateDelayed()</code>，来发送一个消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchInvalidateDelayed</span><span class="params">(View view, <span class="keyword">long</span> delayMilliseconds)</span> </span>&#123;</span><br><span class="line">    Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);</span><br><span class="line">    mHandler.sendMessageDelayed(msg, delayMilliseconds);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_INVALIDATE:</span><br><span class="line">                ((View) msg.obj).invalidate();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该消息的处理，实际上是调用发起<code>postInvalidate()</code>方法的<code>View</code>的<code>invalidate()</code>方法，从而发起一个invalidate 重绘请求。</p><blockquote><p><code>postInvalidate()</code> can be invoked from outside of the UI thread only when this View is attached to a window.</p></blockquote><h4 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h4><p><code>View.setVisibility()</code>等方法正是通过<code>invalidate()</code>方法来发起重绘请求。</p><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>Android系统在渲染画面到显示屏上时，先把<code>View</code>的内容计算成多边形、纹理 ，再交由GPU 转换到不同的像素上进行显示， 后者称为栅格化（<strong>rasterization</strong>），是一个复杂耗时的过程。</p><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>Canvas 记录了一个<code>View</code>的绘制命令。<code>View</code>使用<code>Canvas</code>来发起绘制命令，比如绘制各种形状、<code>Bitmap</code>等。</p><blockquote><p>The Canvas class holds the “draw” calls. To draw something, you need 4 basic components: A Bitmap to hold the pixels, a Canvas to host the draw calls (writing into the bitmap), a drawing primitive (e.g. Rect, Path, text, Bitmap), and a paint (to describe the colors and styles for the drawing).</p></blockquote><h4 id="ClipRect"><a href="#ClipRect" class="headerlink" title="ClipRect"></a>ClipRect</h4><p><code>View</code>的内容绘制（<code>onDraw()</code>）本身并不关注脏区域，而是由<code>Canvas</code>的裁剪区域决定了哪些区域会被绘制。换言之，<code>View</code>在使用<code>Canvas</code>进行绘制时，<code>Canvas</code>已经根据脏区域设置了裁剪区域。</p><h4 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h4><p><code>Canvas</code>有一个<code>Matrix</code>对象，用于记录当前的transformation。在<code>View.draw(Canvas canvas, ViewGroup parent, long drawingTime)</code>中，会根据<code>View</code>在父<code>View</code>中的坐标、translation以及scroll 等对<code>Canvas</code>的<code>Matrix</code>设置偏移，使得<code>View</code>的左上角对应到<code>Canvas</code>的原点。因此<code>View</code>在执行真正的绘制工作时（比如<code>onDraw()</code>），无需考虑偏移、缩放等。这也是为什么<code>View</code>的transformation不会影响布局。</p><p>举个例子：当<code>View</code>的<code>translationY</code>不为0时，<code>View.onDraw()</code>在实现绘制时并不需要设置<code>Canvas</code>的偏移值，因为<code>Canvas</code>的<code>Matrix</code>已经记录了所有的transformation，<code>View</code>的开发者只需要关注内容的绘制。</p><p>在使用View 动画<code>Animation</code>时，会从<code>Animation</code>中计算得到<code>Transformation</code>对象，并通过<code>Canvas.concat(TransformToApply.getMatrix())</code>将动画的当前结果（偏移、alpha等）设置到<code>Canvas</code>的<code>Matrix</code>中，从而绘制出动画中的这一帧。</p><h3 id="View-的Matrix"><a href="#View-的Matrix" class="headerlink" title="View 的Matrix"></a>View 的Matrix</h3><p><code>View</code>也有一个<code>Matrix</code>对象，用于记录当前<code>View</code>的transformation（translation、scale、alpha等）。触摸事件在派发时，判断事件是否落在<code>View</code>的位置上时，会使用<code>View.getInverseMatrix().mapPoints(point)</code>来帮助计算事件与转换（移动、缩放、旋转）后的<code>View</code>的关系。</p><h4 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h4><p>在View 动画中，是通过<code>Canvas</code>的<code>Matrix</code>使视图内容发生变化，而<code>View</code>本身的属性不变，因此<code>View</code>的触摸事件响应区域不随动画而改变。</p><h4 id="Animator"><a href="#Animator" class="headerlink" title="Animator"></a>Animator</h4><p>在属性动画中，是通过设置<code>View</code>本身的属性，从而改变了<code>View</code>的<code>Matrix</code>，因此<code>View</code>的触摸事件响应区域会随着动画而改变。</p><h2 id="绘制模型"><a href="#绘制模型" class="headerlink" title="绘制模型"></a>绘制模型</h2><p>Android 的绘制模型包括软件模型（Software-based drawing model） 和硬件加速模型（Hardware accelerated drawing model）。</p><h3 id="Software-based-drawing-model"><a href="#Software-based-drawing-model" class="headerlink" title="Software-based drawing model"></a>Software-based drawing model</h3><p>每次绘制（重绘），都需要调用<code>Canvas</code>来发起绘制命令，也就是执行<code>View.onDraw()</code>等方法。</p><p>invalidate 流程会将脏区域从<code>View</code>坐标（从脏<code>View</code>开始向父<code>View</code>递归计算）转换成屏幕坐标，在重绘时，所有与脏区域有交集的<code>View</code>都会重新绘制。</p><p><code>View</code>绘制时使用的<code>Canvas</code>是由<code>ViewRootImpl</code>的<code>Surface.lockCanvas(Rect inOutDirty)</code>得来，整棵<code>View</code>树都是使用该对象进行绘制，创建的<code>Canvas</code>已经根据参数<code>inOutDirty</code>设置了裁剪区域，也就是脏区域。<code>View</code>的内容绘制（<code>onDraw()</code>）本身并不关注脏区域，而是由<code>Canvas</code>的裁剪区域决定了哪些区域会被绘制。</p><h3 id="Hardware-accelerated-drawing-model"><a href="#Hardware-accelerated-drawing-model" class="headerlink" title="Hardware accelerated drawing model"></a>Hardware accelerated drawing model</h3><p><code>View</code>绘制时使用的<code>Canvas</code>是<code>DisplayListCanvas</code>，其不会马上执行绘制命令，而是使用Display Lists 来记录绘制操作，最后通过绘制Display Lists 来发起绘制命令。在重绘时，只有脏<code>View</code>需要重新创建Display List，也就是只有脏<code>View</code>的<code>onDraw()</code>等绘制方法会被执行。</p><p>另一方面，对于诸如缩放、移动、旋转、设置alpha 等行为，也不需要执行脏<code>View</code>的<code>onDraw()</code>等绘制方法来重建Display List，直接设置Display List 的属性，即可交由GPU 进行计算。</p><p>硬件加速减少了大量CPU 计算，将部分以浮点运算为主的操作交给擅长浮点运算的GPU 执行。</p><p>在 android 26中，每个<code>View</code> 有一个<code>RenderNode</code>，硬件加速使用的<code>DisplayListCanvas</code>是由<code>RenderNode.start(int width, int height)</code>创建的，因此每个<code>View</code>在绘制时使用的<code>Canvas</code>不是同一个对象。</p><h4 id="硬件加速使用"><a href="#硬件加速使用" class="headerlink" title="硬件加速使用"></a>硬件加速使用</h4><ul><li><a href="https://developer.android.com/guide/topics/graphics/hardware-accel#controlling" target="_blank" rel="noopener">硬件加速开关</a></li><li><a href="https://developer.android.com/guide/topics/graphics/hardware-accel#determining" target="_blank" rel="noopener">判断是否开启</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用户界面是以<code>View</code>为基本模块，并以树的结构进行组织，所以像绘制、触摸事件处理、重绘请求等流程，都包含一个基本行为模式：遍历<code>View</code>树或者其子树：</p><ul><li>要么是从<code>ViewRootImpl</code>开始遍历<code>View</code>树，并根据一些条件跳过一些<code>View</code>树，或者选择遍历路径。</li><li>要么是从某个节点开始，递归或循环遍历父节点，直到<code>ViewRootImpl</code>。</li></ul><p><code>View</code>是用户界面的蓝图，而<code>Canvas</code>是将界面蓝图输出到结果的工具（显示到屏幕上、或者绘制到<code>Bitmap</code>上）。</p><p><code>View</code>和<code>Canvas</code>都有<code>Matrix</code>，前者的<code>Matrix</code>记录了<code>View</code>的transformation，而后者的用于控制内容的输出结果。<code>View</code>往往会根据自身的transformation以及<code>View</code>坐标，对<code>Canvas</code>的<code>Matrix</code>进行设置，使得绘制在预期的位置以及得到预期的绘制效果。</p>]]></content>
    
    <summary type="html">
    
      View树的绘制流程，重绘请求流程，绘制模型及其他细节。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>View触摸事件</title>
    <link href="http://yoursite.com/2018/06/29/Android/View/View%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/06/29/Android/View/View触摸事件/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T05:06:16.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="View触摸事件"><a href="#View触摸事件" class="headerlink" title="View触摸事件"></a>View触摸事件</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p><strong>默认</strong>的设计中，采用责任链模式，从根<code>View</code>开始，根据<strong>事件派发条件</strong>，在<code>View</code>树中<strong>满足条件</strong>的<code>View</code>之间形成一条<strong>自顶向下</strong>传递事件的<strong>事件处理链</strong>。</p><blockquote><p>注：触摸事件来源于硬件层，以<code>message</code>的形式发送给应用层，传递到<code>ViewRootImpl</code>，从而派发给根<code>View</code>。如果根<code>View</code>是<code>DecorView</code>，<code>DecorView</code>会将事件派发给<code>Window.Callback</code>（<code>Activity</code>实现了此接口），后又流经<code>Window</code>回到<code>DecorView.superDispatchTouchEvent()</code>。这也是为什么<code>Activity</code>和<code>Window</code>也能拦截或处理事件。以上流程忽略了一些细节，实际流程会判断是否传递事件给<code>Window.Callback</code>等，而且不同版本的系统表现也可能不同。但整体流程上，仍然符合责任链模式，只是事件处理链上不只有<code>View</code>，为了简化描述，下文仍用<code>View</code>来指代<strong>事件处理者</strong>。</p></blockquote><h3 id="事件派发条件"><a href="#事件派发条件" class="headerlink" title="事件派发条件"></a>事件派发条件</h3><ol><li>在默认行为中，事件的派发往往基于该事件与<code>View</code>的<strong>位置关系</strong>，即事件应该只被派发到对应位置的<code>View</code>上。</li><li>对于一个<code>View</code>而言，事件不是相互独立的，以<code>ACTION_DOWN</code>作为起点，直到下一个<code>ACTION_DOWN</code>到来前的事件，可以看做一个<strong>事件序列</strong>。在一个事件序列中，<strong>接收并消费（直接消费或子<code>View</code>树消费）</strong>某个事件的所有前序事件，是一个<code>View</code>继续接收该事件的条件。</li></ol><blockquote><p>注：任何一个节点都可以打破这种默认行为，包括先预处理事件再向下派发、拦截事件向下派发、继续处理已被消费的事件等等。</p></blockquote><h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><h4 id="事件接收方法"><a href="#事件接收方法" class="headerlink" title="事件接收方法"></a>事件接收方法</h4><p><code>boolean dispatchTouchEvent(MotionEvent event)</code>是每个事件处理者接收事件的方法，其返回值表示事件是否已被消费。</p><h4 id="事件处理细节"><a href="#事件处理细节" class="headerlink" title="事件处理细节"></a>事件处理细节</h4><h5 id="View的dispatchTouchEvent-MotionEvent-event"><a href="#View的dispatchTouchEvent-MotionEvent-event" class="headerlink" title="View的dispatchTouchEvent(MotionEvent event)"></a><code>View</code>的<code>dispatchTouchEvent(MotionEvent event)</code></h5><p>在<code>View</code>的实现中，会先将事件传递给<code>OnTouchListener</code>，如果未被消费，则调用<code>onTouchEvent()</code>，其中包含了对点击事件的识别与处理等。</p><p><code>OnTouchListener</code>实际上是一个观察者，android 通过这个观察者给开发者提供了更<strong>优先</strong>的事件处理权限。当然，开发者也可以通过继承并复写<code>onTouchEvent()</code>甚至<code>dispatchTouchEvent()</code>的方式来实现更自由的事件处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ViewGroup的dispatchTouchEvent-MotionEvent-event"><a href="#ViewGroup的dispatchTouchEvent-MotionEvent-event" class="headerlink" title="ViewGroup的dispatchTouchEvent(MotionEvent event)"></a><code>ViewGroup</code>的<code>dispatchTouchEvent(MotionEvent event)</code></h5><p><code>ViewGroup</code>本身作为布局控件，其主要作用是组织子控件，所以一般而言，其对事件的消费优先级要比子控件低。这也是为什么要先将事件传给子控件。</p><ul><li><code>ViewGroup</code>会先判断是否拦截事件。有两个判断依据：<ol><li>外部可通过调用<code>ViewGroup.requestDisallowInterceptTouchEvent(boolean disallowIntercept)</code>来设置是否阻止<code>ViewGroup</code>拦截事件，默认是false，也就是<code>ViewGroup</code>默认是可拦截事件的。</li><li>如果外部没有阻止<code>ViewGroup</code>拦截事件，则通过自身的<code>boolean onInterceptTouchEvent(MotionEvent ev)</code>方法判断当前是否需要拦截事件。值得一提的是，一旦该方法返回<code>true</code>，后续事件不会再进行此判断，因为子<code>View</code>的事件序列已被结束，不会再接收事件，自然也就无需判断是否拦截。</li></ol></li><li>如果没有子<code>View</code>符合派发事件的条件，就会调用<code>super.dispatchTouchEvent()</code>，也就是<code>View</code>的<code>dispatchTouchEvent()</code>方法，开始自身处理事件的过程。</li></ul>]]></content>
    
    <summary type="html">
    
      View触摸事件的派发。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>View的绘制三要点</title>
    <link href="http://yoursite.com/2018/06/29/Android/View/View%E7%9A%84%E4%B8%89%E8%A6%81%E7%82%B9/"/>
    <id>http://yoursite.com/2018/06/29/Android/View/View的三要点/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T07:37:17.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="View的绘制三要点"><a href="#View的绘制三要点" class="headerlink" title="View的绘制三要点"></a>View的绘制三要点</h2><p><code>View</code>作为用户界面的基本组成模块，需要处理三个问题：显示区域的大小、显示位置、显示的内容。因此，<code>View</code>的绘制从<strong>工作内容</strong>的角度来看，有三要点：measure（计算尺寸），layout（排版布局）和draw（绘制内容）。</p><p>在设计上，采用了<strong>模板方法模式</strong>，<code>View</code>为这三个步骤定义了<code>measure()</code>、<code>layout()</code>和<code>draw()</code>三个<strong>模板</strong>方法，模板方法分别调用了<code>onMeasure()</code>、<code>onLayout()</code>和<code>onDraw()</code>这三个<strong>具体方法</strong>，<code>View</code>的子类根据各自的特性复写这三个具体方法，来实现真正与计算尺寸、排版和内容相关的工作。</p><p>在结构和流程上，<code>View</code>之间形成树状结构，由<code>ViewRootImpl</code>触发，从根<code>View</code>开始，采用深度优先的方式，自顶向下遍历子<code>View</code>，发起工作。值得注意的是，<code>View</code>通过<code>ViewParent</code>这个接口类型来持有自己的父<code>View</code>，而不是<code>ViewGroup</code>类型。而<code>ViewGroup</code>和<code>ViewRootImpl</code>都实现了<code>ViewParent</code>接口。这就解决了每个<code>View</code>，包括根<code>View</code>，都有父亲的问题，即使<code>ViewRootImpl</code>并不是<code>View</code>的子类。从这个角度来讲，可以将<code>ViewRootImpl</code>视为整棵树的根，当然，此时这棵树就不能称为<code>View</code>树了。</p><h3 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h3><p>measure主要有两方面的工作：</p><ul><li><p><strong>计算尺寸</strong></p><p>模板方法<code>measure(int widthMeasureSpec, int heightMeasureSpec)</code>中的两个参数（以下简称<code>measureSpec</code>）是父<code>View</code>提供给子<code>View</code> 进行<code>measure()</code>的“参考值”。这两个参数的本质，可以认为是<code>View</code>体系关于尺寸的协议。</p></li><li><p><strong>设置计算结果</strong></p><p><code>View</code>根据<code>measureSpec</code>以及其他信息（比如自身的尺寸需求）计算完尺寸后，必须通过<code>setMeasuredDimension(int measuredWidth, int measuredHeight)</code>方法进行设置使计算结果生效。</p></li></ul><blockquote><p>值得一提的是，<code>measure()</code>方法是<code>final</code>修饰的，意味着子类不能修改其行为。其执行了一些优化（比如通过判断是否真的需要执行<strong>具体方法</strong>来避免无谓的计算）。</p></blockquote><h4 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h4><p><code>measureSpec</code>是一个<code>int</code>类型，它包含了两个信息：size和mode。高位<strong>两个bit</strong>表示mode，低位<strong>30个bit</strong>表示size。<code>View</code>有一个静态内部类<code>MeasureSpec</code>，封装了创建和解析<code>measureSpec</code>的方法。</p><blockquote><p>注：<code>measureSpec</code>是小写开头，表示尺寸规格。<code>MeasureSpec</code>是大写开头，是一个辅助类。</p></blockquote><h5 id="mode的三个类型"><a href="#mode的三个类型" class="headerlink" title="mode的三个类型"></a>mode的三个类型</h5><ul><li><code>AT_MOST</code>表示父<code>View</code>认为该子<code>View</code>的<strong>最大</strong>尺寸是<code>measureSpec</code>中指定的size。</li><li><code>EXACTLY</code>表示父<code>View</code>认为该子<code>View</code>的尺寸就是<code>measureSpec</code>中指定的size。</li><li><code>UNSPECIFIED</code>表示父<code>View</code>不知道子<code>View</code>的尺寸。</li></ul><h5 id="measureSpec-的来源"><a href="#measureSpec-的来源" class="headerlink" title="measureSpec 的来源"></a>measureSpec 的来源</h5><p><code>measureSpec</code>是父<code>View</code>为子<code>View</code>的measure提供的“参考值”，来源于父<code>View</code>。而根<code>View</code>的<code>measureSpec</code>来自于<code>ViewRootImpl</code>（不是<code>View</code>的子类，但实现了<code>ViewParent</code>接口）。</p><h5 id="measureSpec-的计算规则"><a href="#measureSpec-的计算规则" class="headerlink" title="measureSpec 的计算规则"></a>measureSpec 的计算规则</h5><ul><li><code>ViewRootImpl</code>调用<code>getRootMeasureSpec()</code>方法，根据<code>Window</code>的尺寸和<code>WindowManager.LayoutParams</code>为根<code>View</code>计算<code>measureSpec</code>。</li><li><code>ViewGroup</code>中提供了<code>getChildMeasureSpec()</code>方法，根据父<code>View</code>自身的大小规格，和要测量的子<code>View</code>的<code>LayoutParams</code>（来自于xml布局文件中指定的<code>layout_width</code>和<code>layout_height</code>，或者代码中动态设置），来计算<code>measureSpec</code>。</li></ul><h5 id="measureSpec-的意义与使用准则"><a href="#measureSpec-的意义与使用准则" class="headerlink" title="measureSpec 的意义与使用准则"></a>measureSpec 的意义与使用准则</h5><p><code>measureSpec</code>可以理解为<code>View</code>体系关于尺寸的协议，尤其是其所携带的mode信息，为子<code>View</code>计算自身尺寸提供了信息。然而<code>measureSpec</code>的计算规则以及<code>View</code>之间的亲子组合关系的不确定性，使得其协议不能为<code>View</code>的显示结果提供任何保证。</p><p>举个例子，<code>LinearLayout</code>在计算子<code>View</code>的<code>measureSpec</code>时，调用了<code>ViewGroup.getChildMeasureSpec()</code>，也就是采用了默认的计算规则。如果发现子<code>View</code>的<code>LayoutParams</code>中明确指定了具体的尺寸，而不是<code>match_parent</code>或<code>wrap_content</code>，会将子<code>View</code>的<code>measureSpec</code>的mode设置为<code>EXACTLY</code>，而size则设置为指定的尺寸。而这个size可能实际上超出了<code>LinearLayout</code>本身的尺寸，这可能导致子<code>View</code>被截断。</p><p>综上，<code>measureSpec</code>本身不保证其指定的尺寸信息能使得子<code>View</code>能“<strong>正确</strong>”显示（正确是指，<code>View</code>的内容能通过滚动、缩放等方式完全展示）。但这并不意味着<code>measureSpec</code>没有意义，而是要求<strong>布局控件开发者</strong>、<strong>非布局控件开发者</strong>以及<strong>布局开发者</strong>，共同遵守<strong>良好的准则</strong>，才能使得<code>measureSpec</code>提供“<strong>正确</strong>”的参考值。良好的准则是指，开发者需充分考虑父<code>View</code>和子<code>View</code>的特性与尺寸，比如父<code>View</code>是否可滚动显示其内容，子<code>View</code>是否可缩放等，如若不具备这些特性，则不应该为他们设置冲突的尺寸，以免导致“<strong>错误</strong>”显示。</p><h4 id="计算尺寸"><a href="#计算尺寸" class="headerlink" title="计算尺寸"></a>计算尺寸</h4><ul><li><p><code>View</code>在计算尺寸时，一般需要考虑两个方面：</p><ul><li>来自于父<code>View</code>和布局开发者的尺寸约束，也就是<code>measurSpec</code>，以下简称其中的size信息为<code>specSize</code>。</li><li>来自于自身的尺寸需求（以下简称<code>size</code>），如最小宽高、或者宽高相同等。</li></ul></li><li><p><code>View</code>中提供了一些方法来从<code>size</code>和<code>specSize</code>中做出选择。</p><ul><li><code>getDefaultSize(int size, int measureSpec)</code>会以遵守<code>measureSpec</code>为准则，如果<code>measureSpec</code>的mode为<code>UNSPECIFIED</code>，会返回<code>size</code>参数，否则会返回<code>specSize</code>。</li><li><code>getSuggestedMinimumWidth()</code>和<code>getSuggestedMinimumHeight()</code>根据<code>View</code>的背景和自身的<code>mMinWidth</code>和<code>mMinHeight</code>属性来返回一个“建议”的最小size。</li><li><code>resolveSize(int size, int measureSpec)</code>会在遵守<code>measureSpec</code>的前提下，返回<code>size</code>，否则会返回<code>specSize</code>。具体规则：<ul><li>如果mode为<code>AT_MOST</code>，且<code>size</code>小于<code>specSize</code>，或者mode为<code>UNSPECIFIED</code>，返回<code>size</code>。</li><li>否则返回<code>specSize</code>。</li></ul></li></ul></li><li><p>在真正的尺寸和<code>measureSpec</code>之间，还有一个中间产物，<code>measureSize</code>，它也是一个由两部分信息拼起来的<code>int</code>类型。<code>measureSize</code>的高位<strong>一个字节</strong>是state，低位<strong>三个字节</strong>表示具体的size。目前state只有默认和<code>MEASURED_STATE_TOO_SMALL</code>两种。<code>measureSize</code>代表了一个计算结果的尺寸和<code>measureSpec</code>之间的关系，即为了遵守<code>measureSpec</code>，是否采取了一个小于自身需求的尺寸。</p><blockquote><p><code>MEASURED_STATE_TOO_SMALL</code> indicates that the measured size is smaller that the space the view would like to have.</p></blockquote></li><li><p><code>ViewGroup</code>因为嵌套了子<code>View</code>，因此其measure过程，往往需要发起子<code>View</code>的measure过程。<code>ViewGroup</code>提供了一些方法来计算提供给子<code>View</code>的<code>measureSpec</code>并触发其measure过程。</p><blockquote><p>注：在这些方法中的<code>measureSpec</code>参数，都是<code>ViewGroup</code>自身的<code>measureSpec</code>，他们是计算子<code>View</code>的<code>measureSpec</code>的重要依据。</p></blockquote><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ask all of the children of this view to measure themselves, taking into</span></span><br><span class="line"><span class="comment"> * account both the MeasureSpec requirements for this view and its padding.</span></span><br><span class="line"><span class="comment"> * We skip children that are in the GONE state The heavy lifting is done in</span></span><br><span class="line"><span class="comment"> * getChildMeasureSpec.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> widthMeasureSpec The width requirements for this ViewGroup</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> heightMeasureSpec The height requirements for this ViewGroup</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ask one of the children of this view to measure itself, taking into</span></span><br><span class="line"><span class="comment"> * account both the MeasureSpec requirements for this view and its padding.</span></span><br><span class="line"><span class="comment"> * The heavy lifting is done in getChildMeasureSpec.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child The child to measure</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentWidthMeasureSpec The width requirements for this ViewGroup</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentHeightMeasureSpec The height requirements for this ViewGroup</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> parentHeightMeasureSpec)</span></span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ask one of the children of this view to measure itself, taking into</span></span><br><span class="line"><span class="comment"> * account both the MeasureSpec requirements for this view and its padding</span></span><br><span class="line"><span class="comment"> * and margins. The child must have MarginLayoutParams The heavy lifting is</span></span><br><span class="line"><span class="comment"> * done in getChildMeasureSpec.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child The child to measure</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentWidthMeasureSpec The width requirements for this ViewGroup</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> widthUsed Extra space that has been used up by the parent</span></span><br><span class="line"><span class="comment"> *        horizontally (possibly by other children of the parent)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentHeightMeasureSpec The height requirements for this ViewGroup</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> heightUsed Extra space that has been used up by the parent</span></span><br><span class="line"><span class="comment"> *        vertically (possibly by other children of the parent)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed, <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span></span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Does the hard part of measureChildren: figuring out the MeasureSpec to</span></span><br><span class="line"><span class="comment"> * pass to a particular child. This method figures out the right MeasureSpec</span></span><br><span class="line"><span class="comment"> * for one dimension (height or width) of one child view.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The goal is to combine information from our MeasureSpec with the</span></span><br><span class="line"><span class="comment"> * LayoutParams of the child to get the best possible results. For example,</span></span><br><span class="line"><span class="comment"> * if the this view knows its size (because its MeasureSpec has a mode of</span></span><br><span class="line"><span class="comment"> * EXACTLY), and the child has indicated in its LayoutParams that it wants</span></span><br><span class="line"><span class="comment"> * to be the same size as the parent, the parent should ask the child to</span></span><br><span class="line"><span class="comment"> * layout given an exact size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spec The requirements for this ViewGroup</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> padding The padding of this view for the current dimension and</span></span><br><span class="line"><span class="comment"> *        margins, if applicable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> childDimension How big the child wants to be in the current</span></span><br><span class="line"><span class="comment"> *        dimension</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a MeasureSpec integer for the child</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="设置计算结果"><a href="#设置计算结果" class="headerlink" title="设置计算结果"></a>设置计算结果</h4><ul><li><p><code>onMeasure()</code>方法中必须调用<code>setMeasuredDimension(int measuredWidth, int measuredHeight)</code>来设置计算结果使其生效（<code>measure()</code>会在调用<code>onMeasure()</code>后检查是否已设置尺寸，若未设置将抛出<code>IllegalStateException</code>）。</p></li><li><p><code>setMeasuredDimension(int measuredWidth, int measuredHeight)</code>的两个参数并不是<code>measureSpec</code>，而是<code>measureSize</code>，或者只包含尺寸信息的<code>int</code>。</p></li><li><p><code>View</code>中提供了一些方法，可在设置过结果后，获取计算结果。</p><ul><li><p><code>getMeasureWidth()</code>和<code>getMeasureHeight()</code>方法返回的是尺寸信息。</p></li><li><p><code>getMeasuredWidthAndState()</code>和<code>getMeasuredHeightAndState()</code>方法返回的是<code>measureSize</code>。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return only the state bits of &#123;<span class="doctag">@link</span> #getMeasuredWidthAndState()&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> #getMeasuredHeightAndState()&#125;, combined into one integer.</span></span><br><span class="line"><span class="comment"> * The width component is in the regular bits &#123;<span class="doctag">@link</span> #MEASURED_STATE_MASK&#125;</span></span><br><span class="line"><span class="comment"> * and the height component is at the shifted bits</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #MEASURED_HEIGHT_STATE_SHIFT&#125;&gt;&gt;&#123;<span class="doctag">@link</span> #MEASURED_STATE_MASK&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mMeasuredWidth&amp;MEASURED_STATE_MASK)</span><br><span class="line">        | ((mMeasuredHeight&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)</span><br><span class="line">           &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><h4 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h4><p><code>View</code>的<code>layout()</code>不是<code>final</code>方法，除了调用<code>onLayout</code>，还执行了<strong>调用回调</strong>（<code>onLayoutChanged()</code>）等工作。<code>ViewGroup</code>的<code>layout()</code>方法则被<code>final</code>修饰。</p><p><code>View.layout()</code>中会调用<code>setFrame()</code>对<code>mLeft</code>等四个属性进行赋值，从而使得<code>getWidth()</code>和<code>getHeight()</code>能返回有效的值。</p><h4 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h4><p><code>View.onLayout()</code>是个空实现，<code>ViewGroup.onLayout()</code>甚至重新将其声明为<code>abstract</code>方法，这意味着，排版布局是<code>ViewGroup</code>子类的重点工作，因为排版正是布局控件的重要功能。而对于非布局控件而言往往没有排版的需要。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><strong>measure</strong>步骤为<code>layout(int l, int t, int r, int b)</code>和<code>onLayout(boolean changed, int left, int top, int right, int bottom)</code>提供了参数，这四个参数表示<code>View</code>在父<code>View</code>中的位置，同时也表示着父<code>View</code>为子<code>View</code>指定的空间。</p><p>从参数可以看出，子<code>View</code>的真正尺寸不一定是其在<strong>measure</strong>步骤中设置的尺寸，父<code>View</code>的排版决定了子<code>View</code>的真正尺寸。但这并不表示measure没有意义，因为父<code>View</code>在排版时，往往会根据子<code>View</code>的measure结果计算其layout的参数。</p><p>同时，也能看出<code>getMeasuredWidth()</code>、<code>getMeasuredHeight()</code>和<code>getWidth()</code>、<code>getHeight()</code>在生效时机和实际意义上的区别。</p><h3 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h3><p><code>draw()</code>方法虽不被<code>final</code>修饰，但一般子类不修改其行为，因为其除了调用<code>onDraw()</code>方法，还执行了诸如绘制背景、触发子<code>View</code>绘制这些约定俗成的工作。</p><ol><li>绘制背景<code>drawBackground(canvas)</code></li><li>If necessary, save the canvas’ layers to prepare for fading</li><li>调用具体方法<code>onDraw()</code></li><li>调用具体方法<code>dispatchDraw()</code>，<code>ViewGroup</code>及其子类复写该方法实现调用子<code>View</code>进行绘制</li><li>If necessary, draw the fading edges and restore layers</li><li>Draw decorations (foreground, scrollbars). 调用<code>onDrawForeground(canvas)</code></li><li>draw the default focus highlight. 调用<code>drawDefaultFocusHighlight(canvas)</code></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://hencoder.com/ui-1-1/" target="_blank" rel="noopener">绘制特效</a>​</li></ul>]]></content>
    
    <summary type="html">
    
      View的绘制三要点：measure,layout,draw。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化分析篇</title>
    <link href="http://yoursite.com/2018/06/29/Android/%E6%8F%92%E4%BB%B6%E5%8C%96/%E6%8F%92%E4%BB%B6%E5%8C%96%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/06/29/Android/插件化/插件化分析/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-07-02T05:12:59.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>动态更新</li><li>减小apk包容量，减少方法数 </li><li>提升编译速度</li></ul><h2 id="考虑因素"><a href="#考虑因素" class="headerlink" title="考虑因素"></a>考虑因素</h2><h3 id="维护成本"><a href="#维护成本" class="headerlink" title="维护成本"></a>维护成本</h3><ul><li>与技术选型相关，对Android 系统侵入性越强，开发与测试维护成本越高。</li><li>插件开发维护成本。<ul><li>插件版本管理。</li><li>插件与宿主关系维护。</li></ul></li></ul><h3 id="技术难点"><a href="#技术难点" class="headerlink" title="技术难点"></a>技术难点</h3><h4 id="依赖与混淆"><a href="#依赖与混淆" class="headerlink" title="依赖与混淆"></a>依赖与混淆</h4><p>取决于插件框架的管理模式，插件之间的耦合以及插件与宿主之间的耦合。</p><h4 id="无安装带来的问题"><a href="#无安装带来的问题" class="headerlink" title="无安装带来的问题"></a>无安装带来的问题</h4><p>由于插件并没有被系统安装，未能得到app级别的待遇。系统安装app过程有个重要步骤，<strong>解析Apk中的AndroidManifest.xml</strong>，完成注册四大组件等工作。缺少此过程，主要产生了以下问题。</p><ol><li>四大组件未注册，无法使用常规方法调用。</li><li>资源加载问题。</li><li>权限、进程等其他只能在AndroidManifest.xml文件中声明的特性。</li></ol>]]></content>
    
    <summary type="html">
    
      Android插件化作用与问题分析。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
</feed>
