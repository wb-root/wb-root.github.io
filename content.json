{"meta":{"title":"WB's Root","subtitle":null,"description":"在开发的路上摸爬滚打","author":"WB","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-07-02T02:30:17.000Z","updated":"2018-07-02T02:30:51.227Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android 资源编译","slug":"Android/Android 资源/资源编译","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T04:38:27.836Z","comments":true,"path":"2018/06/29/Android/Android 资源/资源编译/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/Android 资源/资源编译/","excerpt":"","text":"约定文中所说的资源，是指res目录下的资源，不包含asset目录下的资源。 编译对象资源包一般而言，App会引用两个资源包，一个是系统资源包，一个是App自身的资源包（包括App依赖的其他模块中的资源）。 1234在xml中引用资源的完整格式：package:type/entry在Java代码中引用资源的完整格式：package.R.type.entry 系统资源包系统资源包仅在构建的时候引用，不会导出到Apk中。系统资源包的包名是android，App在引用系统资源包的时候需要指定此包名。 App资源包App资源包中的资源包含主模块的资源以及依赖的模块中资源。其构建有两个特点： 资源整合将资源包中的所有模块的资源整合在一起，为它们分配唯一的id，生成一个统一的package.R类（package是主模块的包名），通过这个R类可以唯一识别并引用资源包中的任意资源。 同时，每个包含资源的子模块，也会有对应的modulePkg.R类（modulePkg是子模块的包名）。猜测是因为子模块中在引用资源的时候用的是这个R类，因此构建的时候，要么需要将所有子模块对其R类的引用改为对主模块R类的引用，要么就需要保留子模块的R类。Android采取了后者，安全省事。 值得一提的是，在各个模块的R类中，同一个资源项的id是相同的。比如package.R.string.ok和modulePkg.R.string.ok的id是同一个值。 解决冲突不同的variant或者模块可能存在同类型的同名资源，它们有着不同的优先级，android在构建的时候，会选择优先级最高的资源，以此来解决冲突。 编译步骤资源编译主要涉及两方面内容：编译资源文件和创建资源索引。下文描述顺序不代表编译流程的先后顺序。 编译资源文件构建时会对各种格式的资源文件进行处理，以下描述仅针对xml文件的编译。xml资源可分两类：values和其他。两者的编译方式有所不同。 values资源values资源编译的时候，不会生成对应的二进制文件，所有的values资源最终会被整合到resources.arsc文件中。 其他资源其他xml资源的编译，会生成对应的二进制文件。 编译特点 提取字符串 类似于Dex文件，资源编译的时候也会将所有的字符串提取出来，放到字符串常量池。字符串包括标签名、属性名和xml文件中出现的字符串字面量。 解析引用 将文件中对资源的引用解析为资源id或字面量等。 生成二进制文件 xml文件的编译过程，可以看做是将xml原始文件解析成一个数据结构，再将数据结构进行持久化，生成二进制文件。 创建资源索引分配资源id，生成R类和资源索引表resources.arsc文件。 资源id每个资源项会被分配一个资源id。 结构资源id是一个int类型的常量。从高到低，第一个字节表示package id，第二个字节描述资源类型，第三和第四个字节共16位，描述给定资源类型下的具体资源项。 1216进制表示的资源id，PP描述包，TT描述类型，EEEE描述具体资源项：PPTTEEEE 分配默认分配方式 package id 系统资源的package id是0x01，而App资源的package id默认是0x7F。[0x01, 0x7f]是合法的资源package id范围。 TTEEEE 一般而言，TTEEEE的分配是根据资源类型和命名排序的。如下： 1234R.color.black = 0x7f010000R.color.white = 0x7f010001R.string.app_name = 0x7f020000R.string.hello = 0x7f020001 因此，当发生资源增加、减少或改名时，可能会改变其他资源项的id值。此特性在以下场景需要注意： 系统资源包中的资源id不可发生改变。 App资源包发生改变时会重新构建，不受影响。但是对于插件化或者皮肤等场景，如果需要动态改变资源，需要考虑资源id的影响。 使用public.xml在android的res目录下提供public.xml文件，可用于指定资源的id。public.xml文件的内容格式如下。 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;public type=\"string\" name=\"app_name\" id=\"0x7f060000\" /&gt;&lt;/resources&gt; 以上例子将app_name的id指定为0x7f060000。值得一提的是，此方法不能指定package id。 R类开发者可通过R类引用资源。 resources.arsc 文件resources.arsc文件记录了资源id与资源的映射关系，也存储了values类型资源。系统在运行App时，需要加载resources.arsc文件并进行解析，才能根据资源id加载资源。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Handler消息处理机制","slug":"Android/Handler消息处理机制","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T05:16:26.390Z","comments":true,"path":"2018/06/29/Android/Handler消息处理机制/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/Handler消息处理机制/","excerpt":"","text":"消息处理机制需求分析Android是响应式的操作系统，系统需要对用户的触摸操作、时间的变化、光线的变化等事件做出及时响应，比如响应点击、激活闹钟、自动调节屏幕亮度等。这符合生产者与消费者模型。 问题满足这个需求，至少需要解决以下两个问题： 生产者生产的消息能被加入消息队列进行处理。并且，消息往往需要指定其被处理的时间。 消费者要能及时处理消息。多线程（多进程也同理，但不在本文讨论范围内）是解决此问题的一种方式，也是Android系统采用的方式。 方案Handler 消息处理机制为了解决这两个问题，提供了以下两个功能： 能在指定时间处理消息。以下简称功能A。 能将消息发送到指定线程处理。以下简称功能B。 There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own. 实现角色在Handler消息机制中，有以下四个角色： Message是消息，或者称为事件。 MessageQueue是消息队列。 Handler提供了将消息入列的方法，充当生产者的角色。 Looper会从消息队列中提取消息，充当消费者的角色。实际上Looper提取消息后，是调用Message.target.dispatchMessage(Message msg)来处理消息，而这里的target就是Handler类型，所以从这个角度来看，Handler不仅是生产者，也是真正的消费者。 功能实现功能A功能A的实现需要Message、MessageQueue、Handler三者的配合。 生产消息Handler提供了一系列send和post方法来发送消息，并指定消息的处理时机。这些方法最终都会调用enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)，该方法做了以下两件事： 将Message.target指向Handler自身。此操作将消息与处理者绑定在一起。 调用MessageQueue.enqueueMessage(Message msg, long when)来将消息入列。这里when参数正是消息的处理时间。 Handler.sendMessageAtFrontOfQueue(Message msg)方法将when赋值为0。 The time-base is android.os.SystemClock.uptimeMillis(). 消息入列实际上，Handler消息处理机制并未提供在准确的时间处理消息的机制。而是折衷地采取了以下方案： 在消息入列时，根据Message.when将消息插入到队列中合适的位置，使得队列中的消息总是按照处理时间排序的。 在消费消息时，总是从队列头部提取消息，并检查是否还未到达消息的处理时间，若是则不消费消息继续等待；否则消费消息。 因此实际效果是不早于消息指定的时间来处理消息。并且，已经入列的消息的执行顺序在入列的时候就已经确定了，消费消息的时候不会改变顺序。 MessageQueue采用链表来存储消息，enqueueMessage(Message msg, long when)的实现中会根据Message.when将消息插入到链表中的正确位置。 功能B功能B的实现依赖于Looper，MessageQueue和Handler的配合。 每个线程可以绑定不超过一对Looper和MessageQueue（可以没有，那就是常规的Java线程，不具备Handler消息处理机制）。 每个Handler也持有一对Looper和MessageQueue，一旦Handler实例被构造，只能用于向其持有的队列添加消息。 在线程中启动绑定的Looper，在队列中监听并处理消息。 创建线程独立的消息队列让一个线程具备消息处理机制，需要完成两件事： 创建Looper和MessageQueue。 在线程中调用静态方法Looper.prepare()，该方法会创建一个Looper对象，该Looper创建一个MessageQueue并持有它（Looper也会持有当前Thread对象）。 Android使用ThreadLocal来保证一个线程不能绑定超过一个Looper。 在绑定的线程中调用Looper的静态方法loop()让Looper开始监听消息。loop()方法会无限循环调用MessageQueue.next()方法来将消息出列并处理。 123456789101112131415161718192021222324252627/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; //... for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; //... try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; //... &#125; //... msg.recycleUnchecked(); &#125;&#125; 注意：由于loop()方法是一个死循环，调用loop()之后的语句在其跳出循环之前不会被执行。这也是为什么经常看到以下写法。 123456789101112131415161718/** * This is a typical example of the implementation of a Looper thread, * using the separation of &#123;@link #prepare&#125; and &#123;@link #loop&#125; to create an * initial Handler to communicate with the Looper. */class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; //... Looper.loop(); &#125;&#125; 消息出列MessageQueue.next()方法会返回下一个达到执行时间的消息。实现这个需求有以下方案： 无限循环访问消息队列对其进行监听，并判断队头是否有到时间的消息。缺点是显而易见的，该线程将始终处于忙碌状态，造成对CPU等资源的浪费。 挂起线程，直到有可处理的消息。sleep()和wait()都能实现挂起线程。关键在于线程需要在以下两种情况苏醒或被唤醒： 到达队头消息处理时间。sleep()和wait()都可以传参设置挂起的时长，做到主动苏醒。 有新的消息被加入到队列头部，而且该消息已到达可被处理的时间。只有wait()可以做到被notify()唤醒。 在MessageQueue.next()中，通过调用native 方法nativePollOnce(long ptr, int timeoutMillis)来完成挂起线程指定时长，与wait()作用相同。MessageQueue.enqueueMessage(Message msg, long when)将消息入列时，如果是加到队头，会调用native 方法nativeWake(long ptr)来唤醒线程，被唤醒的线程会去检查队列中是否有可被处理的消息，否则重新挂起。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; //... int nextPollTimeoutMillis = 0; for (;;) &#123; //... //将线程挂起 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; //... if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; //... &#125; //... &#125;&#125; 实现细节 为什么Looper与线程是一对一的关系，而与Handler是一对多的关系？ 作为消息发送工具，Handler只需一个即可。但是Handler同时还具有消费者的身份，这使其可处理具体的业务（通过复写其void handleMessage(Message msg)方法），因此为不同的业务分配不同的Handler有了充分的理由。 为什么消息只会被对应的Handler处理？ 因为Message.target指定了对应的Handler。 Handler如何实现删除消息时，只删除由其加入队列的消息？ 实际上，Handler并不负责删除消息的细节，它会调用MessageQueue的remove方法来删除消息，并将自身作为参数传递给remove方法。MessageQueue会遍历链表，删除满足条件的消息。其中一个条件就是Message.target为参数中Handler。 为什么使用Handler不用加锁？ 因为真正执行消息入列的MessageQueue被加了锁。 开发者无需对Message调用recycle()方法，因为Looper每处理完一个Message，都会调用Message.recycleUnchecked()来回收。 主线程调用Looper.loop()，并且当其队列为空被挂起之后，主线程如何被唤醒？ 主线程并不是唯一的线程，还有Binder线程等其他线程存在，这些线程可向主线程的队列添加消息。 调试发现，nativePollOnce(long ptr, int timeoutMillis)这个本地方法的作用不只是简单地挂起线程。在主线程的队列为空调用这个方法被阻塞之后，点击一下屏幕，发现主线程的调用栈如下： 12345678at android.view.InputEventReceiver.dispatchInputEvent(InputEventReceiver.java:185)at android.os.MessageQueue.nativePollOnce(MessageQueue.java:-1)at android.os.MessageQueue.next(MessageQueue.java:325)at android.os.Looper.loop(Looper.java:142)at android.app.ActivityThread.main(ActivityThread.java:6541)at java.lang.reflect.Method.invoke(Method.java:-1)at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240)at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767) 在nativePollOnce(long ptr, int timeoutMillis)里调用了InputEventReceiver.dispatchInputEvent(InputEventReceiver.java:185)，看源码可以发现该方法有如下注释，这是一个被native 代码调用的方法。 123// Called from native code.@SuppressWarnings(\"unused\")private void dispatchInputEvent(int seq, InputEvent event) 由此可推测，调用nativePollOnce()方法挂起主线程之后，当有一些事件到来时，native层会唤醒主线程。具体的阻塞和唤醒机制，就是epoll 机制了。 附加题ThreadLocal这个类的实例可以用来存储或获取一个与线程相关的变量。在不同的线程调用同一个对象的TheadLocal.set()和ThreadLocal.get()可以设置和访问对应线程的变量。原理上是隐藏了对Thread.currentThread()的调用，变量实际上是被Thread对象持有的。 Synchronization barrier &amp; Asynchronous message Sets whether the message is asynchronous, meaning that it is not subject to {@link Looper} synchronization barriers.Certain operations, such as view invalidation, may introduce synchronization barriers into the {@link Looper}’s message queue to prevent subsequent messages from being delivered until some condition is met. In the case of view invalidation, messages which are posted after a call to {@link android.view.View#invalidate} are suspended by means of a synchronization barrier until the next frame is ready to be drawn. The synchronization barrier ensures that the invalidation request is completely handled before resuming.Asynchronous messages are exempt from synchronization barriers. They typically represent interrupts, input events, and other signals that must be handled independently even while other work has been suspended.Note that asynchronous messages may be delivered out of order with respect to synchronous messages although they are always delivered in order among themselves. If the relative order of these messages matters then they probably should not be asynchronous in the first place. Use with caution. Message processing occurs as usual until the message queue encounters the synchronization barrier that has been posted. When the barrier is encountered, later synchronous messages in the queue are stalled (prevented from being executed) until the barrier is released by calling {@link #removeSyncBarrier} and specifying the token that identifies the synchronization barrier.This method is used to immediately postpone execution of all subsequently posted synchronous messages until a condition is met that releases the barrier. Asynchronous messages (see {@link Message#isAsynchronous} are exempt from the barrier and continue to be processed as usual. 同步消息屏障消息队列中的消息会根据时间按序被处理，这些消息称为同步消息。有时需要延迟处理消息，直到达到某个条件。Synchronization Barrier（以下简称Sync Barrier），翻译为同步消息屏障或同步分隔栏等，提供了这样的功能。 Sync Barrier的本质是一个Message，只是target为null，使用的时候，像普通消息一样，将其添加到消息队列即可。其作用是作为队列中一个的标志，标志着其后续的同步消息暂不被处理。其本身不需要被处理。 Sync Barrier的入列规则与同步消息相同，会根据Message.when排序。 系统对添加Sync Barriers 的方法postSyncBarrier()添加了{@Hide}注解，而Handler会为其发送的所有消息指定target，因此App 开发者无法采用常规方式添加同步消息屏障。 异步消息Sync Barriers会阻止同步消息的处理，对于一些不需要被Sync Barriers阻止的消息，比如输入事件，Android 引入了异步消息的概念，来避免受制于Sync Barriers，使其能被正常执行。 异步消息也是Message，Message.setAsynchronous(boolean async)可消息设置一个消息是否为异步消息。 异步消息的入列规则与同步消息相同，会根据Message.when排序。因此异步消息之间会按序被执行。并且，当不存在Sync Barrier时，异步消息与同步消息没有差别。 延迟处理消息MessageQueue.next()在提取下一个处理的消息时，分以下两种情况： 如果队头是Sync Barrier，会遍历队列寻找第一个异步消息进行处理。 Sync Barrier本身不会被该方法出列。需要调用MessageQueue.removeSyncBarrier(int token)才能将Sync Barrier移除。 如果队头不是Sync Barrier，会处理队头消息。 12345678910Message prevMsg = null;Message msg = mMessages;if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());&#125;// 处理消息或者挂起线程... IdleHandler Callback interface for discovering when a thread is going to block waiting for more messages. MessageQueue.next()如果没找到可以处理的消息，会遍历MessageQueue.mIdleHandlers调用IdleHandler.queueIdle()来执行一些”空闲“时处理的工作。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android 杂记","slug":"Android/Android杂记","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T08:32:34.006Z","comments":true,"path":"2018/06/29/Android/Android杂记/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/Android杂记/","excerpt":"","text":"Device Compatibility Device features declare necessary features 1234&lt;manifest&gt; &lt;uses-feature android:name=\"android.hardware.sensor.compass\" android:required=\"true\" /&gt;&lt;/manifest&gt; check for the device feature at runtime 12345PackageManager pm = getPackageManager();if (!pm.hasSystemFeature(PackageManager.FEATURE_SENSOR_COMPASS)) &#123; // This device does not have a compass, turn off the compass feature disableCompassFeature();&#125; Some system permissions implicitly require the availability of a device feature. For example, if your app requests permission to access to BLUETOOTH, this implicitly requires the FEATURE_BLUETOOTH device feature. You can disable filtering based on this feature and make your app available to devices without Bluetooth by setting the required attribute to “false” in the &lt;uses-feature&gt; tag. Platform version declare the minimum version with which your app is compatible and the highest version on which you’ve optimized your app 123&lt;manifest&gt; &lt;uses-sdk android:minSdkVersion=\"14\" android:targetSdkVersion=\"19\" /&gt;&lt;/manifest&gt; check the API level at runtime 12345if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123; // Running on something older than API level 11, so disable // the drag/drop features that use ClipboardManager APIs disableDragAndDrop();&#125; Screen configuration screen size: small, normal, large, and xlarge densities: mdpi (medium), hdpi (hdpi), xhdpi (extra high), xxhdpi (extra-extra high), and others 总结 There are two types of compatibility: device compatibility and app compatibility. AndroidManifest.xml 文件中声明“要求”的标签的名字都是“uses-XXX” IntentIntent Intent 的常用Action定义在Intent的类里，以及Android 框架的其他类里，比如Settings，用于打开设置界面。自定义的Intent Action一般以包名作为前缀，并以大写后缀部分，如123456789101112- **Data**是一个Uri。Intent的```setData()```和```setType()```会互相置空对方，因此当需要设置两者的时候，使用```setDataAndType()```方法。- **category** 提供了一些额外的信息。对用于启动Activity的隐式Intent，系统在解析其可接收的组件时，会假定该Intent携带```CATEGORY_DEFAULT```的category（但系统**不会**自动在Intent中添加这个category）。因此，对于支持隐式Intent启动的Activity，必须在Intent Filter中添加```CATEGORY_DEFAULT```。可以认为```CATEGORY_DEFAULT```将一个Activity标志为可被隐式启动的。- 像Action一样，Intent也定义了很多标准[**Extra**常量](https://developer.android.com/reference/android/content/Intent.html#EXTRA_ALARM_COUNT)。- 由于设备上不一定有能响应隐式Intent的app，使用隐式Intent启动Activity时，应先进行检查。 ```java if (sendIntent.resolveActivity(getPackageManager()) != null) &#123; startActivity(sendIntent); &#125; 当响应隐式Intent的Activity有多个时，系统会弹出选择界面供用户选择，并且有选项可供用户将某个Activity设置为默认Activity，下次响应该Intent类型时，将直接启动默认Activity。App也可如下强制每次都调起选择界面。 123456789101112Intent sendIntent = new Intent(Intent.ACTION_SEND);...// This says something like \"Share this photo with\"String title = getResources().getString(R.string.chooser_title);// Create intent to show the chooser dialogIntent chooser = Intent.createChooser(sendIntent, title);// Verify the original intent will resolve to at least one activityif (sendIntent.resolveActivity(getPackageManager()) != null) &#123; startActivity(chooser);&#125; 常用Intent Intent Filter Intent Filter 只对隐式Intent起作用。 一个组件可以声明多个Intent Filter。隐式Intent在解析时，只要能通过组件任意一个Filter，该组件即可响应该Intent。 组件在声明Intent Filter时，应该将不同的功能分成不同的Filter。 data 包含两部分，mime type和URI结构。 Intent 解析 Intent Filter的作用是声明了一个组件可以处理的Intent信息，比如Action、Category和数据类型、数据URI结构。 隐式Intent携带了希望执行的Action，该Intent所属的Category，以及包含的数据及其类型。 综上，一个Intent命中一个组件的条件是，该Intent符合该组件的任意一个Intent Filter的声明，即该Intent携带的信息被全部包含在一个Intent Filter的声明中。 匹配Intent不仅可以用来寻找响应的组件，也可以用来查询设备上有哪些组件可以匹配指定的Intent。PackageManager提供了一些1234## Task and back stack- ```Intent Flag 使用1234567 - 使用```FLAG_ACTIVITY_CLEAR_TOP```调起已经存在于某个task中的Activity时，会清空该task中位于目标Activity之上的其他Activity。常与```FLAG_ACTIVITY_NEW_TASK```配合使用。- ```Launch Mode``` - 对于launchMode为```standard```的Activity，不管用于调起它们的Intent设置了怎样的flag，每次被调起，都会创建新的实例。- ```Document``` - ```FLAG_ACTIVITY_NEW_DOCUMENT```和```documentLaunchMode```的```intoExist```与```always```属性值仅对launchMode为```standard```的Activity起作用。- Activity的调起结果，由以下三个元素决定： - Intent的```Flag Activity的1234567891011121314151617181920212223 - Activity的```documentLaunchMode``` - 这三个元素共同确定了以下维度的结果： 1. 是否在已存在的task中查找目标Activity 2. 当满足1，查找task的范围（仅当前task还是所有task） 3. 当满足1，且在已存在的task中找到目标Activity，如何处理该task中的其他Activity。 4. 是否创建新实例（onCreate还是onNewIntent）。与1不是互斥关系，查找目标Activity不意味着不创建新实例。 5. 若需要创建新实例，新实例创建的task。推论（未证实）：与1有关联，若需要查找task，则新实例将被创建于目标task，不然查找task来干嘛？仅仅是用来销毁？ 6. 当目标Activity结束时，是否在```Recents Screen```中留下入口。## Fragment- 每个Fragment都需要一个id或者tag来唯一标识。- Fragment 的backStack维护的是transaction，而不是Fragment。 &gt; The order in which you add changes to a FragmentTransaction doesn&apos;t matter, except: &gt; &gt; You must call `commit()` last. &gt; &gt; If you&apos;re adding multiple fragments to the same container, then the order in which you add them determines the order they appear in the view hierarchy. &gt; If you do not call `addToBackStack()` when you perform a transaction that removes a fragment, then that fragment is destroyed when the transaction is committed and the user cannot navigate back to it. Whereas, if you do call `addToBackStack()` when removing a fragment, then the fragment is stopped and will be resumed if the user navigates back.- 提交与执行```FragmentTraction 事务被提交，但不会马上执行，而是被异步执行。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 - ```commitNow()``` 事务被提交并同步执行。在此方法返回前，事务中添加或去除Fragment等操作已被执行。 - ```commitAllowingStateLoss()```允许在Activity保存状态之后提交事务。 - ```executePendingTransactions()``` 马上**同步**执行所有提交但未执行的事务。 &gt; 批注：在FragmentManager中，维护一个事务的队列，使用```Handler.post()```来异步执行事务。```FragmentTransaction.commit()```方法实际是向FragmentManager入列一个事务。而```commitNow()```方法则是调用FragmentManager同步执行一个事务。- Fragment的生命周期受Activity影响，但并不一定是对应关系。特别是对于动态添加的Fragment，比如在Activity的resumed状态下添加Fragment，Fragment的生命周期是“一次性”走到```onResume()```的.## LayoutInflater- `LayoutInflater`的多个`inflate()`重载方法，最终都是调用`inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)`版本，该方法会根据XML布局文件的解析结果`parser`创建`View`树，并返回根`View`。- `createViewFromTag()`顾名思义，该方法会根据`parser`解析出来的标签名和属性等信息，创建**一个**`View`。在实现中，会先尝试调用`Factory2`和`Factory`的`onCreateView()`来创建`View`，如果返回`null`，再调用自身的`onCreateView()`。 ```java public interface Factory &#123; /** * Hook you can supply that is called when inflating from a LayoutInflater. * You can use this to customize the tag names available in your XML * layout files. * * &lt;p&gt; * Note that it is good practice to prefix these custom names with your * package (i.e., com.coolcompany.apps) to avoid conflicts with system * names. * * @param name Tag name to be inflated. * @param context The context the view is being created in. * @param attrs Inflation attributes as specified in XML file. * * @return View Newly created view. Return null for the default * behavior. */ public View onCreateView(String name, Context context, AttributeSet attrs); &#125; public interface Factory2 extends Factory &#123; /** * Version of &#123;@link #onCreateView(String, Context, AttributeSet)&#125; * that also supplies the parent that the view created view will be * placed in. * * @param parent The parent that the created view will be placed * in; &lt;em&gt;note that this may be null&lt;/em&gt;. * @param name Tag name to be inflated. * @param context The context the view is being created in. * @param attrs Inflation attributes as specified in XML file. * * @return View Newly created view. Return null for the default * behavior. */ public View onCreateView(View parent, String name, Context context, AttributeSet attrs); &#125; 从这两个接口的注释可以看出，它们可以作为“Hook”，用来自定义创建View的行为。AppCompat这些支持库就是利用它在加载布局时，识别XML布局文件中的TextView等标签，并创建对应的AppCompatTextView等。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Service","slug":"Android/Service","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T19:23:13.187Z","comments":true,"path":"2018/06/29/Android/Service/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/Service/","excerpt":"","text":"ServiceFundamental Beginning with Android 5.0 (API level 21), the system throws an exception if you call bindService() with an implicit intent. If your app targets API level 26 or higher, the system imposes restrictions on running background services when the app itself is not in the foreground. In most cases like this, your app should use a scheduled job instead. See also Background Service Limitations. Users can see what services are running on their device and can stop them. In order to avoid having your service stopped accidentally by users, you need to add the android:description attribute to the element in your app manifest. In the description, provide a short sentence explaining what the service does and what benefits it provides. process lifecycle foreground process visible process service process cached process 12345678910111213141516171819202122232425262728293031323334public class ExampleService extends Service &#123; int mStartMode; // indicates how to behave if the service is killed IBinder mBinder; // interface for clients that bind boolean mAllowRebind; // indicates whether onRebind should be used @Override public void onCreate() &#123; // The service is being created &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; // The service is starting, due to a call to startService() return mStartMode; &#125; @Override public IBinder onBind(Intent intent) &#123; // A client is binding to the service with bindService() return mBinder; &#125; @Override public boolean onUnbind(Intent intent) &#123; // All clients have unbound with unbindService() return mAllowRebind; &#125; @Override public void onRebind(Intent intent) &#123; // A client is binding to the service with bindService(), // after onUnbind() has already been called &#125; @Override public void onDestroy() &#123; // The service is no longer used and is being destroyed &#125;&#125; The startService() method returns immediately, and the Android system calls the service’s onStartCommand() method. The binding is also asynchronous, and bindService() returns immediately without returning the IBinder to the client. 这意味着Service是异步创建的。 If bindService()) returns false, your client does not have a valid connection to the service. However, your client should still call unbindService(); otherwise, your client will keep the service from shutting down when it is idle. The Android system calls onServiceDisconnected()) when the connection to the service is unexpectedly lost, such as when the service has crashed or has been killed. This is not called when the client unbinds. If your service is started and accepts binding, then when the system calls your onUnbind() method, you can optionally return true if you would like to receive a call to onRebind() the next time a client binds to the service. onRebind() returns void, but the client still receives the IBinder in its onServiceConnected() callback. Unless the service is bound to a client, the system destroys it when the service is stopped by calling stopSelf() or stopService. When the last client unbinds from the service, the system destroys the service, unless the service was also started by startService(). That is, the system destroys an service only after no clients bound to it and explicitly stopped if has been started. AIDLAIDL 线程与阻塞 A service runs in the main thread of its hosting process; the service does not create its own thread and does not run in a separate process unless you specify otherwise. Calls made from the local process are executed in the same thread that is making the call. Calls from a remote process are dispatched from a thread pool the platform maintains inside of your own process. You must be prepared for incoming calls from unknown threads, with multiple calls happening at the same time. In other words, an implementation of an AIDL interface must be completely thread-safe. 当客户端调用服务端提供的IBinder接口时，客户端会被阻塞直到方法返回。在服务进程，系统维护一个线程池，当服务端接口被调用的请求到达时，系统从线程池中调起一个线程来执行服务。 The oneway keyword modifies the behavior of remote calls. When used, a remote call does not block; it simply sends the transaction data and immediately returns. The implementation of the interface eventually receives this as a regular call from the Binder thread pool as a normal remote call. If oneway is used with a local call, there is no impact and the call is still synchronous. 已验证：oneway用于修饰接口，表示对该接口所有方法的调用是“单向”的，即无需等待返回数据，方法的返回类型只能是void，并且不含有out或者inout修饰的参数。调用该接口的线程不会被阻塞。 从根据AIDL文件生成的Proxy类中，可以看到在调用Binder.transact(int code, Parcel data, Parcel reply, int flags)方法时，传递了android.os.IBinder.FLAG_ONEWAY给flag参数，该值用于标示非阻塞调用远程接口。 AIDL 接口定义AIDL 接口是用Java语法定义的。 支持的类型By default, AIDL supports the following data types: All primitive types in the Java programming language (such as int, long, char, boolean, and so on) String CharSequence List All elements in the List must be one of the supported data types in this list or one of the other AIDL-generated interfaces or parcelables you’ve declared. A List may optionally be used as a “generic” class (for example, List&lt;String&gt;). The actual concrete class that the other side receives is always an ArrayList, although the method is generated to use the List interface. Map All elements in the Map must be one of the supported data types in this list or one of the other AIDL-generated interfaces or parcelables you’ve declared. Generic maps, (such as those of the form Map&lt;String,Integer&gt; are not supported. The actual concrete class that the other side receives is always a HashMap, although the method is generated to use the Map interface. You must include an import statement for each additional type not listed above, even if they are defined in the same package as your interface. 参数的directional标签All non-primitive parameters require a directional tag indicating which way the data goes. Either in, out, or inout. Primitives are in by default, and cannot be otherwise. 已验证：这个设定是为了节省传递数据的消耗。in 表示其修饰的参数仅用于提供数据给服务端，因此服务端对该参数的修改，不会影响客户端的实例。out则相反，表示其修饰的参数仅用于从服务端获取数据，接口实现中对该参数的修改将被传递给客户端。 从根据aidl文件生成的java类中，也可以一见端倪。Proxy是客户端用于与远程接口交互的代理类，其持有的Binder对象实现了IBinder接口，封装了与Binder驱动的交互细节。Stub是服务端的抽象类，继承了Binder，封装了远程连接的数据读写等操作，也声明了对aidl接口的实现，服务端的接口实现类继承Stub并实现aidl接口中声明的方法。对于in、out、inout修饰的参数，有如下特点： Proxy在调用远程方法前 Proxy在调用远程方法后 Stub在调用aidl接口方法前 Stub在调用aidl接口方法后 in 写入数据 不读取数据 读取数据 不写入数据 out 忽略参数 读取数据 直接生成指定类型的对象，并传递给实现方法 写入数据 inout 写入数据 读取数据 读取数据 写入数据 异常No exceptions that you throw are sent back to the caller. 验证：实际上服务端抛出的部分RuntimeException，是会传递给客户端的。以下描述仅对不被oneway修饰的接口有效。 首先，由于服务端提供的Binder是根据aidl文件生成的，在生成的接口的方法签名中，只抛出了RemoteException，这意味着Binder的实现类中的方法，无法抛出其他非运行时的异常。 对于抛出的运行时异常，从Binder.execTransact()和Parcel.writeException()可以看出，若是系统“已支持”的异常类型，会将该异常的信息写入数据流中，传递给客户端。而对于其他异常类型，将在服务端抛出RuntimeException。 客户端的远程服务代理类Proxy会在调用Binder.transact()方法后，执行Parcel.readException()，该语句将读取服务端写入数据流中的异常信息，生成并抛出对应的异常实例。对于未被传递的异常，客户端读取不到异常。若远程方法因异常终止执行，未将返回值写入数据流（如果该方法有返回值的话），客户端从数据流中也读取不到返回值。 AIDL类图 其他 Objects are reference counted across processes. Parcel是传输数据的管道，Parcelable是一个接口，表示其可被Parcel传输。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Java杂记","slug":"Java/Java杂记","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T09:09:54.987Z","comments":true,"path":"2018/06/29/Java/Java杂记/","link":"","permalink":"http://yoursite.com/2018/06/29/Java/Java杂记/","excerpt":"","text":"字符与字符串字符集与字符编码 代码点（code point）是指与一个编码表中的某个字符对应的代码值，比如A的代码点是65（\\u0041）。 代码单元（code unit） 在基本多语言级别中，每个字符用16位表示，称为代码单元。 其他级别中的字符采用一对连续的代码单元进行编码。 Java中采用UTF-16。char用两个字节（16位）来表示一个字符，所以char不能描述所有Unicode字符。因此不建议使用char。 String String.length()返回的是字符串的代码单元的数量，而不是代码点的数量。 即”\\uD801\\uDC37”实际上表示一个字符，但需要两个代码单元来描述。 String.codePointCount(0, String.length())返回的才是代码点的数量，也就是字符的数量。 String.charAt(n)返回位置n的代码单元。 String.codePointAt(String.offsetByCodePoints(0, i))返回的才是位置i的代码点。 String是不可变字符串，没有提供修改字符串的行为，String的拼接或提取等都是产生新的String对象。 StringBuilder 为了避免“修改”字符串时，产生大量新对象，可使用StringBuilder，其内部实现是一个char[]。 采用+运算符来拼接String，编译后实际上是使用StringBuilder，并且每一个使用+的语句，都会创建一个StringBuilder对象。 StringBufferStringBuilder的线程安全版本，使用synchronized。 包装类 内部有一个对应的基本类型的final成员value。 包装类会自动打包，本质是调用包装类的static方法valueOf()来创建一个包装类对象。 包装类会自动拆包，本质是调用包装类对象的intValue()等方法来返回value成员。 值得一提的是，Integer和Long有缓存机制，会将值落在[-128, 127]（上限可被虚拟机参数修改）范围内的Integer和Long对象缓存起来，因此不会重复创建对象。 1234//a 跟 b是同一个对象，a == b 返回trueInteger a = 37, b = 37;//c 跟 d不是同一个对象，c == d 返回falseInteger c = 137, d = 137; 内部类内部类是一种编译器现象，对于虚拟机而言，并不知道内部类的存在，编译器会把内部类编译成用$符号分隔外部类名和内部类名的常规类文件，虚拟机将其当做常规类文件处理。 并通过修改内部类的构造器等行为，绕过权限控制。 非静态内部类编译器会在非静态内部类中添加一个外部类类型的final成员this$0，并通过修改内部类的所有构造器，添加一个外部类的引用参数，在创建内部类对象时，将实例化该内部类的外部类对象作为参数传入构造器，再将该参数赋值给this$0。 访问私有成员内部类和外部类之间可以相互调用私有成员（包括field和method）。编译器会为被调用的私有成员生成具有包权限的静态方法，内部类和外部类通过这些静态方法来相互调用私有成员。 值得一提的是，如果调用的是非静态成员，自动生成的静态方法会带有一个对方类型的参数。 field对于被调用的私有field，编译器会生成具有包权限的静态方法，来get和set field。 method对于被调用的私有method，编译器会生成具有包权限的静态方法，该方法会调用私有method。 局部内部类定义在局部块（方法）中的类称为局部内部类。 局部内部类可以访问final的局部变量。编译器会为局部内部类添加一个该局部变量类型的finalfield，添加一个构造函数，并将被调用的局部变量作为参数，对其进行赋值。 内存泄露正如上文所言，非静态内部类因持有外部类对象以及局部变量，容易造成内存泄露。 除了显式声明为静态内部类，在外部类的静态方法中声明的局部内部类，也是静态内部类，不会隐式持有外部类对象（因为不存在）。 对于局部变量，可用弱引用等进行包装。 枚举编译结果编译后实际上是一个类，access flags 为 0x4031[public final enum]，继承自java.lang.Enum。 枚举值一个枚举类型的每个值都是该类的一个final static的实例对象。在字节码文件中可以看到，编译器自动生成了一个静态初始化块，在该初始化块中，会对每个值进行初始化。 序列化Serializable 是一个标记接口，声明实现Serializable的类，其对象可被ObjectOutputStream和ObjectInputStream序列化和反序列化。Serializable标记的类默认会序列化所有不被static和transient修饰的成员。 private static final long serialVersionUID 可用于做序列化的版本兼容。 控制非法反序列化。没有正确serialVersionUID的程序无法对序列化的字节码进行反序列化。 用transient修饰的成员不会被序列化。 添加以下方法，替换默认的序列化行为，达到加密、序列化特定成员等目的。 123456private void writeObject(ObjectOutputStream out) &#123; &#125;private void readObject(ObjectInputStream in) &#123;&#125; Externalizable继承于Serializable，但默认不序列化任何成员，需要自定义序列化行为，类似于android中的Parcelable。 1234public interface Externalizable extends java.io.Serializable &#123; void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;&#125; 加密包装类javax.crypto.SealedObject 和java.security.SignedObject 可用于包装Serializable的实现类，它们定义了加密的序列化行为。 设计 继承和持有对象的选择 有时候我们面临着这么一个情况，当我们需要一个类B来扩展一个类A时，是选择继承A，还是持有A的一个对象引用。这两者的区别如下： 对于客户端需要的调用方法，前者可选择性复写并添加父类A的方法来实现自己的逻辑功能，而后者需要全部提供入口 。 前者只能拥有父类A的方法属性，而无法拥有A的其他子类的。而后者，则可以引用类A及其所有子类。 在设计模式中，前者拥有适配器的特点，Adapter包含并重定义了Adaptee的方法，以提供给客户端需要的接口。而后者更接近于门面模式，封装了内部复杂的模块，只提供必需的接口给客户端。 宽接口与窄接口。有时候对于一个类，在内部模块（可能在同一个包或不同的包下，跨包情况下default权限并不能很好地起作用）希望提供正常使用的接口，而对外进行访问限制，例如单纯只被引用，可以考虑，实现两个接口，一个用于内部模块，一个用于外部模块，各自声明拥有仅需的方法。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Android 支持不同的屏幕","slug":"Android/支持不同的屏幕","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T08:15:29.837Z","comments":true,"path":"2018/06/29/Android/支持不同的屏幕/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/支持不同的屏幕/","excerpt":"","text":"清晰度我认为清晰度是，特定人所看到的物体的图像与此人对该物体的认知是否相同的一个反映。也就是说不同的人对同一个图像的清晰度的看法是不同的。比如UI设计师，往往能观察到更多图像细节，觉得不清晰。再比如，像素鸟，尽管一眼看去，全是块状的颜色，但在人们的认知中，这就是像素鸟的样子，所以不会觉得它“糊了”。因此清晰度实际上是由两个因素共同决定： 图像的客观显示效果。 图像观察者的主观认知。 在显示器上，图像的客观显示效果，由很多个因素共同决定，比如颜色。这里仅讨论，“像素”对显示效果的影响。图像在显示器上显示，是将图像数据解析并通过物理硬件显示。因此其显示效果主要依赖于以下两个因素： 硬件显示图像的基本单位（以下简称物理显示单位）的物理尺寸。对硬件而言，比如液晶显示屏，基本显示单位往往是固定的，由晶体管等的显示效果决定。在古老的显示设备上，物理显示单位往往较大，以至于大多数人能辨识出这些单位，产生块状感。 图像数据与物理显示单位的映射关系。不同的图像数据格式记录数据的方式不同，但有一个共同点，将图像转换为一系列的颜色值进行记录，换言之，图像数据记录了颜色值和这些颜色值的排列关系。显示器在软件和硬件的共同作用下，使用一个或多个基本显示单位来显示图像数据记录的每一个颜色值，以下称之为映射关系。 当物理显示单位的物理尺寸较大，以至能被人眼所辨识时，便产生不连续的块状感，与物体在认知中的连续性不同，便觉得不清晰。 当物理显示单位足够小，不能被人眼所辨识时，映射关系成为影响清晰度的主要因素。如果映射关系是一对一，那么每一个颜色值的物理显示尺寸足够小，足以产生连续感。如果映射关系是多对一，比如将图片放大，试图将数量固定的颜色值显示在数量多于颜色值的物理显示单位上，软件或硬件需要将缺失的颜色值补全，最粗暴的方式是让多个物理显示单位显示同一个颜色值。这种映射比例越大，一个颜色值的物理显示尺寸便越大，块状感便越强。 使内容的物理显示尺寸固定PPI &amp; DPI PPI，pixel per inch，描述的是显示的像素密度。包括两方面，一方面是硬件的像素密度，往往是固定的。另一方面，往往可通过软件设置分辨率，来改变最终显示的像素密度。以下统称为显示像素密度。 DPI，dot per inch，原本用于描述扫描设备的采样点密度，或者打印设备的打印墨点密度等。 在Android中，DPI 实际上指的是PPI。从7.0开始，系统提供了开发者选项来设置”最小宽度”，作用等同于设置分辨率。部分厂商也将这个特性开放给了普通用户，在设置中提供了“显示”选项。 DIP显示器以像素作为基本显示单位，因此必须将物理长度单位转换为像素才能显示在显示器上，而像素的物理尺寸不是固定的，因此物理长度单位与像素的转换关系是与像素的物理尺寸相关的。像素的物理尺寸信息可通过DPI来表示（倒数）。 实际上，Android允许直接使用in（表示英寸）作为长度单位，系统会将以in为单位的dimen数值，根据DPI换算成像素数量。换算公式为：$$ypx = npx/inch * xinch$$其中$npx/inch$ 即为DPI，是系统根据设备的物理像素密度或者设置的分辨率得出的值。式子左边$ypx$即为换算结果。 DIP（简称DP），density-independent pixel，虽然名字里有像素，但其显示长度与像素密度无关，而是与物理长度相关，可用于为内容设定（大致）固定的物理显示尺寸。与物理长度相关指的是，其与英寸等长度单位相同，直接指明了其表示的物理长度，并可与英寸等长度单位进行换算。DP其本身只是一个符号，是Android设计的一个单位，脱离了Android的解析，其本身便失去了表示长度的能力。Android指定dp与px的换算公式为： $$ypx = npx/inch / 160 * xdp$$因此，1dp等于1/160英寸。并且当DPI为160时，1dp可换算为1px。但是，实际上，系统在英寸和dp与像素的两个换算关系中，使用了不同的DPI。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TypedValue &#123; public static float applyDimension(int unit, float value, DisplayMetrics metrics) &#123; switch (unit) &#123; case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.xdpi; case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); &#125; return 0; &#125;&#125;public class DisplayMetrics &#123; /** * The logical density of the display. This is a scaling factor for the * Density Independent Pixel unit, where one DIP is one pixel on an * approximately 160 dpi screen (for example a 240x320, 1.5\"x2\" screen), * providing the baseline of the system's display. Thus on a 160dpi screen * this density value will be 1; on a 120 dpi screen it would be .75; etc. * * &lt;p&gt;This value does not exactly follow the real screen size (as given by * &#123;@link #xdpi&#125; and &#123;@link #ydpi&#125;, but rather is used to scale the size of * the overall UI in steps based on gross changes in the display dpi. For * example, a 240x320 screen will have a density of 1 even if its width is * 1.8\", 1.3\", etc. However, if the screen resolution is increased to * 320x480 but the screen size remained 1.5\"x2\" then the density would be * increased (probably to 1.5). * * @see #DENSITY_DEFAULT */ public float density; /** * The exact physical pixels per inch of the screen in the X dimension. */ public float xdpi;&#125; 可以看到，在英寸的换算中，使用的是物理DPI，而在DP的换算中，使用的是逻辑DPI，从7.0开始提供的修改分辨率的设置，修改的正是逻辑DPI。这导致DP与英寸之间的换算公式不成立，也使得DP失去了“density independence”的特性。 Your application achieves “density independence” when it preserves the physical size (from the user’s point of view) of user interface elements when displayed on screens with different densities. The density-independent pixel is equivalent to one physical pixel on a 160 dpi screen, which is the baseline density assumed by the system for a “medium” density screen. The Android system helps your application achieve density independence in two ways: The system scales dp units as appropriate for the current screen density The system scales drawable resources to the appropriate size, based on the current screen density, if necessary You can use the command line to simulate different device densities and display resolutions. 123456&gt; // Set the display size&gt; adb shell am display-size 600x800&gt; &gt; // Set the display density&gt; adb shell am display-density 80&gt; A set of six generalized densities ldpi (low) ~120dpi mdpi (medium) ~160dpi hdpi (high) ~240dpi xhdpi (extra-high) ~320dpi xxhdpi (extra-extra-high) ~480dpi xxxhdpi (extra-extra-extra-high) ~640dpi 通过划分出6个通用的密度区间，开发者不需为每个不同像素密度的设备提供对应的资源，系统会根据设备像素密度所属的区间，从对应后缀名的资源目录中寻找资源。特别是对于图片资源的匹配，系统的匹配优先级如下： 优先从对应目录中寻找资源，假设DPI为300，会在xhdpi目录下寻找资源，并进行“压缩”显示（因为该目录下的图片应该是为320DPI设计的）。 从密度更高的目录中寻找，并将图片进行“压缩”显示。 从密度更低的目录中寻找，并将图片进行“拉伸”显示。 If the qualifier in question is screen pixel density, Android selects the option that most closely matches the device screen density. In general, Android prefers scaling down a larger original image to scaling up a smaller original image. Note: Place all your launcher icons in the res/mipmap-[density]/ folders, rather than the res/drawable-[density]/ folders. The Android system retains the resources in these density-specific folders, such as mipmap-xxxhdpi, regardless of the screen resolution of the device where your app is installed. This behavior allows launcher apps to pick the best resolution icon for your app to display on the home screen. For more information about using the mipmap folders, see Managing Projects Overview. 为不同尺寸的设备提供不同的资源A set of four generalized sizes xlarge screens are at least 960dp x 720dp large screens are at least 640dp x 480dp normal screens are at least 470dp x 320dp small screens are at least 426dp x 320dp When selecting resources based on the screen size qualifiers, the system uses resources designed for a screen smaller than the current screen if there are no resources that better match (for example, a large-size screen uses normal-size screen resources if necessary). However, if the only available resources are larger than the current screen, the system doesn’t use them and your app will crash if no other resources match the device configuration (for example, if all layout resources are tagged with the xlarge qualifier, but the device is a normal-size screen). 160 DPI 和 normal size 的由来 The generalized sizes and densities are arranged around a baseline configuration that is a normal size and mdpi (medium) density. This baseline is based upon the screen configuration for the first Android-powered device, the T-Mobile G1, which has an HVGA screen (until Android 1.6, this was the only screen configuration that Android supported). Starting with Android 1.6 (API Level 4), Android provides support for multiple screen sizes and densities.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Java异常机制","slug":"Java/异常机制","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T12:30:47.270Z","comments":true,"path":"2018/06/29/Java/异常机制/","link":"","permalink":"http://yoursite.com/2018/06/29/Java/异常机制/","excerpt":"","text":"异常机制异常分类与继承关系 ErrorError及其子类，描述了Java运行时系统的内部错误和资源耗尽错误。应用程序开发者不应该使用Error。原则上，出现Error时，最多只能保证尽快安全地终止程序。 Exception应用开发者主要面对Exception，其分为两大类：RuntimeException与编译时异常。 RuntimeExcetpion运行时异常，或称为未受检异常（unchecked exception）。由应用程序错误导致的异常属于RuntimeException。如错误的类型转换，数组越界等，这些错误往往是由应用开发者的错误导致。因此“如果出现RuntimeException异常，那么就一定是你的问题”。 编译时异常或称为受检异常（checked exception）。应用程序本身没有问题，但由于像I/O错误这类问题导致的异常属于编译时异常。 使用异常使用异常 对于可能发生的错误，有两种方法通知调用者。一种是通过返回值，一种是抛出异常。异常处理机制，也是对责任链模式的运用。使用异常，一定程度上可以让开发者专注于业务，而非错误处理，并让“合适的”处理者来处理异常。 有些情况，无法从返回值中区分是否遭遇了错误，此时可使用异常。 原则：对于可恢复的情况，使用受检异常；对于程序错误，则使用运行时异常。 不使用异常 异常处理机制更耗时。 在某些情况下，API方法遇到的错误是调用者的疏忽造成的，而这种错误，调用者可以通过诸如判空、判断是否可执行等来避免，这种情况下应该提供这些检测方法，而不是一味地抛出异常，特别是受检异常。 线程异常处理器UncaughtExceptionHandler是线程用于处理异常的接口，如果异常没有被调用栈处理，JVM在终止线程（而不是进程）之前，会先调用线程异常处理器。开发者可通过设置线程异常处理器来保障应用安全地终止。值得一提的是，此处理器，并不能阻止线程的终止。 可以通过Thread对象的setUncaughtExceptionHandler()方法给线程设置异常处理器。 也可以通过Thread的静态方法setDefaultUncaughtExceptionHandler()方法给所有线程设置默认异常处理器。前者优先级更高。 如果不为独立的线程设置处理器，其处理器就是该线程的ThreadGroup对象，该类实现了Thread.UncaughtExceptionHandler接口。其行为如下： 如果线程组有父线程组，调用父线程组的UnCaughtException()方法。 否则，如果有默认处理器，调用该处理器。 否则，如果Throwable是ThreadDeath的一个实例，什么都不做。 否则，线程的名字以及Throwable的栈踪迹被输出到System.err上。 细节 一旦某个方法遭遇异常，将抛出异常并立刻退出，而不返回任何值，此外，调用此方法的代码也将无法继续执行，而是异常处理机制开始搜索异常处理器。直到异常处理器处理之后，便可以继续执行处理器之后的代码。 子类重写的方法抛出的异常不能超过父类，因此如果子类的重写方法代码可能遭遇异常，需要在子类中捕获异常。 再次抛出异常与异常链：在catch子句中可以再抛出异常，这样做的目的是改变异常类型。比如子系统抛出的异常，可能在其他系统有不同的异常类型表示，这时候可先捕获再抛出新的异常。同时，可调用新抛出的异常对象的initCause() 方法，把原始异常作为参数传入，在之后捕获异常时，可以使用getCause()方法重新得到原始异常。 try语句块之后可以不跟catch而直接跟finally，这样就可以在不处理异常的情况下，执行一些必须执行的工作，比如回收资源。 以下写法不仅逻辑清晰，内嵌try语句负责收尾工作，外部try语句负责处理异常，并且外部的catch子句还能捕获finally子句抛出的异常。 123456789try &#123; try &#123; //... &#125; finally &#123; //...回收资源 &#125;&#125; catch (Exception e) &#123; //&#125; finally子句只有在try语句块被进入（不被条件语句跳过等）的情况下，才会被执行。 finally子句的缺陷。当finally子句也抛出异常时，会覆盖try子句抛出的异常。最好的办法是就地捕获finally语句中抛出的异常。 Throwable.getStackTrace()方法将返回一个StackTraceElement对象的数组，该数组是对一个方法调用过程的堆栈追踪。 类似的有Thread的静态方法的getAllStackTrace()方法，提供对所有线程的堆栈追踪。 try-with-resources语句，会把资源（AutoCloseable或 Closeable）对象在try代码块执行结束或捕捉异常后，执行close()方法，close()方法如果抛出异常，将调用该方法抛出的异常的addSuppressed()方法，并将关闭异常作为参数传入，如果该方法未抛异常，则无此步骤。 编译结果在Java的字节码中，异常处理器不是通过指令实现，而是通过Exception Table。 12345678910111213141516171819public void tryFunc(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: new #8 // class java/lang/RuntimeException 3: dup 4: invokespecial #9 // Method java/lang/RuntimeException.&quot;&lt;init&gt;&quot;:()V 7: athrow 8: astore_1 9: goto 15 12: astore_2 13: aload_2 14: athrow 15: return Exception table: from to target type 0 8 8 Class java/lang/Exception 0 9 12 any from和to描述try块的开始和结束的行数，target指的是处理异常的行数。这里的行数，指的是字节码方法中的行数，而不是源码中的行数。 上例中，当方法中的第0行（含）到第8行（不含）之间抛出Exception时，跳转到第8行，开始处理异常。finally子句的本质，也是在Exception Table中添加处理器（并重新抛出异常），来保证会被执行，如上例中的第二个处理器。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java中的异步与同步","slug":"Java/异步与同步机制","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T09:21:31.099Z","comments":true,"path":"2018/06/29/Java/异步与同步机制/","link":"","permalink":"http://yoursite.com/2018/06/29/Java/异步与同步机制/","excerpt":"","text":"异步ThreadJava中用Thread类来启动线程，除了自身的run()方法，还可以接收一个Runnable来作为线程工作。 挂起线程 sleep()休眠一定时间，进入阻塞状态。 yield()让出CPU，进入就绪状态，重新抢占CPU。 中断线程！ stop() 调用的时候，被调用的线程会马上从正在执行（或者挂起）的地方抛出ThreadDeath（Error的子类）。 interrupt() 调用的时候，如果该线程被挂起或阻塞，该线程会抛出InterruptedException等异常；否则，该方法仅起到设置标志的作用，可通过interruped()方法判断是否该结束线程。 不管是stop()还是interrupt()，都是通过抛出Throwable来起到“中断”的作用。实际上，这里的Throwable同样可以被catch子句捕获，finally子句也同样有效。因此，这两个方法都不能保证中断线程。 相对而言，stop()比interrup()更粗暴，因此也具有一定危险。比如，当线程持有锁，线程的中断，会释放锁，这可能会导致原本需要被锁保护的对象，暴露给了其他线程。因此stop()被标记为废弃的方法。 线程的优先级 getPriority() setPriority()参数为Thread的静态常量。 Callable&lt;T&gt;与Future&lt;T&gt; Callable&lt;T&gt;作用与Runnable类似，但可在执行后返回一个T类型的返回值，需要与Future&lt;T&gt;配合使用，Callable&lt;T&gt;的执行结果会存储在一个Future&lt;T&gt;对象中。Future.get()方法可用于取回结果，调用该方法将会阻塞线程直到工作线程计算出结果。 FutureTask&lt;T&gt;实现了Runnable和Future接口，可接收一个Callable对象，起到包装Callable的作用，可以将FutureTask交给Thread执行，并取得执行结果。 线程池Executors类有许多静态工厂方法用来构建线程池，可根据需要选择不同的线程池。线程池是实现了ExecutorService接口的类，重载了多个submit()方法，使用Runnable或Callable作为参数，并返回Future。 重要！当使用完一个线程池，应该调用shutdown方法来停止线程池，其内部是调用了Thread.interrupt()来中断线程。 同步竞争条件根据各线程访问同一数据的次序，可能会产生讹误的对象，这种情况称为竞争条件（race condition）。 锁 锁是可重入的。 条件：当一个线程获得某个锁，却发现需要满足某个条件才能继续执行时，需要释放锁并阻塞线程，直到被唤醒。条件用于挂起线程与唤醒线程。 ReentrantLock 使用的时候，如果临界区可能抛出异常，应该在finally子句中调用unlock()，以防止其他线程被永远阻塞。 条件 ReentrantLock有一个newCondition()方法，该方法返回一个Condition对象。在某个条件下，线程应该等待，这时可调用条件对象的await()方法挂起线程。当其他线程执行后，使得该条件可能已经改变时，应该在该线程调用该条件对象的signal()或signalAll()方法，通知线程调度器，解除该条件的等待集中的所有线程的阻塞状态。 锁重入 锁保持一个持有计数来跟踪对lock()方法的嵌套调用，因此在每一次调用lock()，都应对应地调用unlock()。由于这一特性，被一个锁保护的代码可以调用另一个使用相同锁的方法。 锁测试和锁超时 boolean tryLock()尝试获取锁，成功返回true，否则返回false。 boolean tryLock(long time, TimeUnit unit)尝试获取锁，但阻塞时间不会超过给定值，成功返回true。TimeUnit是枚举类型，指定时间单位（秒，毫秒，微秒，纳秒）。 void lockInterruptibly() lock()方法不能被中断，如果线程在等待锁的期间被中断，中断线程在获得锁之前仍将处于阻塞状态。带有时间参数的tryLock()在阻塞中被中断，将抛出InterruptedException。lockInterrupted()方法相当于设置一个超时为无限的tryLock()，允许线程提前结束阻塞。 boolean await(long time, TimeUnit unit) 进入该条件的等待集，直到线程从等待集移出或者达到指定时间，才解除阻塞。因到达时间而返回，则返回false，否则返回true。如果线程阻塞期间被中断，抛出InterruptedException。 void awaitUniterruptibly() 进入该条件的等待集，直到线程从等待集移出才解除阻塞。如果线程被中断，不会抛出InterruptedException。 synchronized synchronized关键字，锁住的是一个对象，当一个线程调用该对象的（部分或全部）同步代码时，其他需要调用（相同或不同）同步代码的线程进行等待。即synchronized关键字，限制了一个对象的所有同步代码块的并行执行。执行非同步代码块则无需等待。 非静态方法使用synchronize关键字修饰，锁住的是this。 静态方法使用synchronize关键字修饰，锁住的是类的class对象。 条件 Java中的每一个对象都有一个内部锁，内部对象锁只有一个相关条件，wait()方法添加一个线程到等待集中，notifyAll()或notify()方法解除等待线程的阻塞状态。相关条件的使用前提是当前线程持有对象锁。也就是必须先进入临界区，然后判断条件，看是否要先把对象锁让给其他线程。 获取锁与释放锁 字节码中，被synchronized块（不是方法），锁的获取是monitorenter指令，释放是monitorexit指令，即synchronized块中的代码是在monitorenter和monitorexit指令之间的。看起来类似ReentrantLock的lock()和unlock()的结构。 为了保证锁能被释放，编译器会为临界区生成一个异常处理器，在处理器中添加monitorexit指令。这也是为什么线程因异常而中断时，锁会被释放。 volatilevolatile修饰符并不能提供原子性，即不能保证任何代码或代码块的执行不被中断。但它提供了可见性。volatile修饰的变量，能保证其被所有线程读取到的值是最新且一致的。为了效率，CPU可能从内存中读取了变量值后存储到内部缓存（高速缓存），并对该值进行操作，然而并不马上写回内存。对于多核处理器或者多处理器，其内部缓存对变量值的缓存可能导致变量值出现不一致，因为变量值并没有马上被写回内存。使用volatile修饰符，可强制处理器马上将操作后的变量值写回内存。多处理器通过嗅探，发现内部缓存与内存不一致时，会重新从内存读取数据，从而保证数据一致性。详见http://www.infoq.com/cn/articles/ftf-java-volatile","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java中的泛型","slug":"Java/泛型","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T18:59:11.814Z","comments":true,"path":"2018/06/29/Java/泛型/","link":"","permalink":"http://yoursite.com/2018/06/29/Java/泛型/","excerpt":"","text":"Java中的泛型没有泛型的时代往往使用Object替代泛型，例如Java中的集合。但这种方式往往有两个问题： 需要类型强制转化。 没有类型检查，有安全问题。 后来，Java SE 5引入了泛型的概念，解决了相应的问题。 类型擦除实际上，泛型是一种编译器现象。开发者开发时使用泛型，编译器会帮助开发者做类型转换，也会做相应的类型检查。而在编译的结果中，并没泛型的概念。此行为成为类型擦除。 编译器自动提供了一个相应的原始类型，原始类型的名字就是删去类型参数后的泛型类型名。原始类型用第一个限定的类型变量来替换，如果没有给定限定就用Object替换。 当程序调用泛型方法时，如果擦除返回类型，编译器会插入强制类型转换。 桥方法被合成来保持多态。 问题 对于泛型，使用instanceof实际上仅比对了原始类型。 1a instanceof Pair&lt;String&gt;; //等同于 a instanceof Pair 类型强转同上。 1Pair&lt;String&gt; p = (Pair&lt;String&gt;) a; //等同于 Pair p = (Pair) a 通配符在使用泛型API（类或方法时），可用通配符?来替代具体的类型。 ? 结合 extends。 1List&lt;? extends Manager&gt; list; //元素必须是 Manager的子类/实现类。 ?结合super。 1List&lt;? super Manager&gt; list; //元素必须是 Manager的父类。 ?单独使用。 1Class&lt;?&gt; clazz; ?与Object?是通配符，顾名思义，是可以匹配任意类型。Object作为超类，是所有其他类的父类。两者有着本质区别。正如上文所说，泛型的作用之一就是类型检查，?的作用在于匹配所有类型。这两者的区别往往体现在需要类型检查的时候。 12345Class&lt;?&gt; clazz = AnyClass.class; //Class&lt;?&gt;能匹配所有类型的classClass&lt;Object&gt; oClazz = Object.class; //Class&lt;Object&gt;仅能匹配 Object.classList&lt;?&gt; list1 = new ArrayList&lt;String&gt;();List&lt;Object&gt; list2 = new ArrayList&lt;Object&gt;();","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Android性能优化理论篇","slug":"Android/Android 优化/性能优化理论篇","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T04:34:20.124Z","comments":true,"path":"2018/06/29/Android/Android 优化/性能优化理论篇/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/Android 优化/性能优化理论篇/","excerpt":"","text":"优化目标从优化目标的角度来看，大致可分为以下两种： 效率优化，主要为了达到交互流畅，以及提高性能。 耗电优化。 效率优化效率优化，顾名思义，是减少完成任务的时间，从而提高效率，可再细分为以下两种：交互流畅度优化与功能效率优化。 交互流畅度优化提供流畅的交互，避免卡顿、甚至ANR。这里的任务主要是尽快提供UI上的反馈来响应用户操作。 典型场景 当用户点击按钮时，马上呈现水波纹等点击效果。 提供顺畅的列表滑动操作。 在执行耗时任务时，提供流畅的进度圈或进度条。 原理Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps，为了能够实现60fps，这意味着程序的大多数操作都必须在16ms内完成。 如果你的某个操作花费时间是24ms，系统在得到VSYNC信号的时候就无法进行正常渲染，这样就发生了丢帧现象（俗称卡顿）。那么用户在32ms内看到的会是同一帧画面。 这个每秒帧数的参数来自于手机硬件，大多数手机屏幕刷新频率大概为60赫兹。 当系统长时间无法进行正常绘制，就发生了无响应现象，5秒无响应，系统即会弹出ANR 对话框。 功能效率优化除了提供流畅的交互外，提高App 的功能效率也很重要。功能效率指的是App 提供给用户的功能的效率，比如打开文档的效率，加载图片的效率等等。 总结这两者不是相互独立的。 相辅相成功能效率的优化，往往能提升交互流畅度。交互流畅度的优化一般也会减少对CPU时间的占用，为业务执行让路。 异曲同工核心思想是相同的：尽可能减少完成任务的时间。 完成任务的时间在开发者可控范围内，主要受两方面影响： 任务本身的耗时。这很大程度上取决于开发者的设计。比如要显示的界面是否过于复杂；是否采用了缓存技术以及缓存命中率等。 任务执行过程是否包含/遭遇不必要的耗时操作。 任务自身包含的非必要耗时操作。比如响应按钮点击时，是否触发并等待文件读写等耗时操作。 任务执行中与其他任务的竞争。典型的竞争胜利者就是GC。可以认为一次GC 操作具备原子性，一次GC 过程中其他线程无法工作。因此GC 发生的频率、耗时，将变相影响其他任务的效率。 寻找优化点分析任务执行过程。入手点是分析方法的执行，可借助工具来统计查看执行了哪些方法、方法执行的频率、耗时。寻找优化点是最难的一步。困难主要包括： 人的一瞬间，对计算机而言是漫长的，在这其中可能调用了很多方法，要在繁杂的Profiler 报告中定位到异常，往往需要通过多次的定位，不断缩小范围。 对于单次调用时问题不明显，但被循环调用，甚至在多个不同的调用链中被调用，累积产生的效率问题，尤其难以发现。 优化思路 去除冗余。具体方案： 避免没有意义的工作，典型的场景是过度绘制。 运用批处理和缓存的思想，减少重复的工作。 分而治之。合理运用线程等技术“并行”开展任务。 因地制宜。根据具体的需求，选择合适的数据结构、算法。不同的数据结构，比如链表、数组、哈希表，在增删改查上各有所长。 耗电优化Android系统与电量相关的特性 部分硬件会在空闲时被关闭，以此来延长电池使用时间。 硬件被唤醒时会出现一个唤醒耗电高峰。 硬件被唤醒并执行工作后，往往会保持一段时间的活跃。 优化思路尽可能将不必马上执行的任务推迟，并在达到相关条件时，批量执行任务，以此避免频繁唤醒硬件，并尽可能让设备获得更多的休眠时间。 典型场景网络任务蜂窝网络（移动网络）是耗电大户，尤其是其硬件模块的唤醒会引起一个耗电高峰，为了避免频繁唤醒硬件，它会在一小段时间内保持开启状态（等待网络响应或者其他网络请求）。因此尽可能推迟网络请求的任务，在硬件已经被唤醒的情况下，或者当设备连接WiFi 时，批量处理这些任务，可以避免无谓的硬件唤醒，从而减少电量消耗。 耗电任务对于一些不必马上执行的耗电任务，可推迟到设备连接电源时执行，避免对电池电量的消耗。 优化实践预防优于治理。后期优化相对而言，将耗费更多的人力物力，因此应养成良好的开发习惯，避免“产生优化点”。 过度绘制屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。 优化方案 减少布局嵌套层次。&lt;merge&gt;可用于减少无谓的层次。 运用ViewStub实现按需加载布局。 ViewStub继承于View，其复写了onMeasure()、dispatchDraw()和draw()等方法，而实现中没有任何实际工作。因此实际上ViewStub在inflate()之前，并非没有被加载，只是其绘制流程都是空白罢了，起到一个占位的作用，使得动态加载布局更加容易编写以及维护。 在ViewStub.inflate()中，做了以下三件事： 使用LayoutInflater加载指定的布局。 从父View中移除自身。由于inflate()会移除自身，因此不能被多次调用，否则会因mParent为空而抛异常。 将加载的布局添加到父View 去除多余的背景。 12//甚至可以移除（Activity的）Window的背景getWindow().setBackgroundDrawable(null); 避免绘制不必要的区域 123456789101112131415//指定绘制的区域Canvas.clipRect();//Return true if the specified rectangle, after being transformed by the current matrix, would lie completely outside of the current clip. Call this to check if an area you intend to draw into is clipped out (and therefore you can skip making the draw calls).Canvas.quickReject();/** * Return the bounds of the current clip (in local coordinates) in the * bounds parameter, and return true if it is non-empty. This can be useful * in a way similar to quickReject, in that it tells you that drawing * outside of these bounds will be clipped out. * * @param bounds Return the clip bounds here. If it is null, ignore it but * still return true if the current clip is non-empty. * @return true if the current clip is non-empty. */public boolean getClipBounds(@Nullable Rect bounds); 内存优化无用内存不能被释放，或者短时间内大量分配内存，使得可用内存不足，将导致以下两种负面影响： 频繁GC，而GC 需要占用CPU 时间，使得其他工作被延迟，典型的结果是无法在16 ms 内完成一帧内容的绘制，出现丢帧。 遭遇OutOfMemoryException。 优化方案 避免在循环中创建对象。拼接字符串也会创建对象。 避免在View.onDraw()等方法中创建对象。 使用内部类时，注意内存泄露。 按需（尺寸）加载图片。 耗电优化Android 5.0 开始提供了 JobScheduler，此API 提供了延迟执行任务的功能。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android性能优化工具篇","slug":"Android/Android 优化/性能优化工具篇","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T07:31:51.926Z","comments":true,"path":"2018/06/29/Android/Android 优化/性能优化工具篇/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/Android 优化/性能优化工具篇/","excerpt":"","text":"善假于物Android 提供了一些工具来帮助我们寻找优化点。 开发者选项调试GPU过度绘制调试GPU过度绘制（Debug GPU Overdraw），可将绘制次数可视化，开发者可轻易发现过度绘制的区域。 GPU呈现模式分析GPU呈现模式分析（Profile GPU Rendering），将界面绘制时间通过条形图的形式展现出来。每一个长条柱表示一帧的绘制，长条柱由不同的颜色区域组成，每一个颜色代表了在这一帧绘制中的一个阶段。比如： draw 阶段，包含了onDraw() 等方法的执行时间。 Input Handling 阶段，包含了处理事件（比如触摸事件）的时间。 颜色区域越长，表示该阶段消耗的时间越长。 Hierarchy Viewer工具提供的信息 界面View树的层次结构，可用于定位冗余的层次结构。 观察同一棵子View树下的View的相对绘制速率，可用于定位绘制效率低的View。 TraceView主要用于观察App 中方法的执行。使用方法是，生成报告文件，然后用DDMS打开报告文件进行分析。生成报告的方式有两种： 使用DDMS 直接生成指定时间内的所有方法调用的trace文件，可能因信息量过大而难以分析。 在代码中指定trace的范围，运行App 使执行此段代码，生成trace文件。 123456Debug.startMethodTracing(Environment.getExternalStorageDirectory() + File.separator + \"traceFileName.trace\");try &#123; //...&#125; finally &#123; Debug.stopMethodTracing();&#125; 工具提供的信息 各个线程在指定时间内调用的方法。GC线程尤其值得留意。 方法的执行时间、调用者、方法中调用的方法等。 systrace跟TraceView差不多，也是生成报告文件（html文件，用chrome打开）进行分析。不同的是TraceView 提供的是指定App 的方法执行信息，而systrace 是从系统层面出发，提供了比如帧绘制、事件方面的信息。 注：官方教程中提到的使用方法，在命令行调用SDK 中的systrace.py 脚本生成报告文件会执行失败。只能在Android Device Monitor 中使用。 由于报告中包含的信息过多，systrace 允许我们在代码中添加标签，方便定位问题。与TraceView 中指定生成报告的范围不同，此方法只是在报告中添加标签，以便辨识。 123456Trace.beginSection(\"Trace Label\");try &#123; //...&#125; finally &#123; Trace.endSection();&#125; 工具提供的信息 通过小圆圈展示了每一帧的绘制情况，黄色和红色表示这一帧的绘制时间超过16 ms。 点击小圆圈，可以在面板看到更多信息，包括绘制这一帧时所执行的方法，甚至优化建议。 内存分析工具Memory Monitor可以观察内存在时间线上的实时变动，已用内存的分配与释放，内存的大小等。当已用内存频繁抖动时，可得知发生了频繁的GC。 Heap ViewerDDMS 的功能，可以查看各种类型的数据所占用内存空间。每次GC发生后会更新Heap。可用于定位内存泄露。 Allocation Tracker可查看内存分配的时间，以及产生分配内存行为的方法。可用于定位内存泄露。 Tips：Android Device Monitor 里的用不了。Android Studio 3.0以下有集成，3.0及以上被去除。 Battery Historian可用来观察电量的消耗情况。此工具无法直接提供各个App或任务消耗电量的信息，而是提供了以下信息： 各个App或任务执行的时长、频率等。 设备在特定时段内消耗的电量。 Android Profiler!!!Android Studio 3.0 开始提供了强大的Android Profiler。此工具提供了CPU 执行、内存、网络请求三方面的信息。 CPU执行分析使用要点观察方法的执行时长。 执行时间类型 self：方法自身所占的时间，不包括所调用的方法的执行时间。 children：方法中调用其他方法所占的时间。 total：方法的总执行时间，等于self + children。 执行时间统计方式通过不同的统计方式，我们可以观察（多次）执行一个方法的真正影响面。 统计方法在每次调用中的执行时长Call Chart：展示指定时间内的所有调用栈。可用于观察一个方法每次调用的执行时长。 统计在相同调用链下方法的总执行时长整合指定时间段内相同的调用链。可用于观察一个方法在指定时间段内，特定调用链下的总执行时长。举例，三次发生了A-&gt;B的调用链，可观察到三次调用的总执行时长。 Frame Chart：以图表的形式展示。 Top Down：以调用链的形式展示。 统计方法的总执行时长Bottom Up：整合指定时间段内相同方法的调用。可用于观察一个方法在指定时间段内所有被调用的总执行时长。 内存分析在不同系统上的使用方式 Android 8.0以下 需要enable advanced profiling 需要手动录制内存分配 If your device is running Android 7.1 or lower, click Record memory allocations in the Memory Profiler toolbar. While recording, Android Monitor tracks all allocations that occur in your app. When you’re done, click Stop recording (the same button; see video 2) to view the allocations. Android 8.0开始 On Android 8.0 and higher, advanced profiling is always enabled for debuggable apps. If your device is running Android 8.0 or higher, you can view your object allocations at any time as follows: Just click-and-hold in the timeline and drag to select the region where you want to view the allocations 功能 观察内存分配在时间线上的变化（分配与GC）。 观察不同的内存类型及其大小。 观察产生分配内存行为的调用栈。 观察对象的引用者。 使用要点 观察内存变化，看是否发生了内存抖动，即是否频繁GC。常见原因： 在循环中创建对象。拼接字符串也会创建对象。 在View.onDraw()等方法中创建对象。 在内存使用后Dump Heap 来观察是否被正常释放。常见场景： 关闭Activity后，Activity是否被正常释放。 图片不需要的时候，是否被正常释放。 对于未正常释放的内存（往往比较大才会被发现），通过追踪分配的调用栈以及持有者，来解决泄露问题。 网络请求分析可用来观察App 的网络请求。 工具提供的信息 网络请求的发起、执行时长。 观察发起网络请求的线程、调用栈，以及请求的详细信息。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android Permission","slug":"Android/Permissions","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T08:14:25.407Z","comments":true,"path":"2018/06/29/Android/Permissions/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/Permissions/","excerpt":"","text":"PermissionsRequesting permission 清单文件中声明 1234&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.android.app.myapp\" &gt; &lt;uses-permission android:name=\"android.permission.RECEIVE_SMS\" /&gt;&lt;/manifest&gt; 动态申请 注意： 动态授权的时候尽管用户是授权给整个permission group，但是只有所申请的权限会被授予，如果需要使用该permission group中的其他权限，仍然需要再次申请（但是系统不会再次要求用户授权，而是马上回调授权的回调方法onRequestPermissionsResult()）。 permission group可能随着系统版本不同而不同，所以申请授权时不应该依赖permission group中的其他权限。 在授权框上，用户可选择禁止app再次请求该权限，在这种情况下，此后app再调用requestPermissions() ，系统不会弹框要求用户授权，而是马上回调授权的回调方法onRequestPermissionsResult()来通知授权被拒绝。 You can also use the adb -g option to grant all permissions automatically when installing an app on an emulator or test device: 12&gt; $ adb shell install -g MyApp.apk&gt; There are a couple of permissions that don’t behave like normal and dangerous permissions. SYSTEM_ALERT_WINDOW and WRITE_SETTINGS are particularly sensitive, so most apps should not use them. If an app needs one of these permissions, it must declare the permission in the manifest, and send an intent requesting the user’s authorization. The system responds to the intent by showing a detailed management screen to the user. For details on how to request these permissions, see the SYSTEM_ALERT_WINDOW and WRITE_SETTINGS reference entries. PermissionPermission attributes System permissions are divided into several protection levels. The two most important protection levels to know about are normal and dangerous permissions. 个人注解： normal权限其实就是安装app时列出来的权限要求。 dangerous权限从6.0开始需要动态授权。 另外有传言，在Google play 或者app 安装页面，normal权限可能被折叠（如果权限比较多的话），dangerous则不会。 Any permission can belong to a permission group. 个人注解： 6.0及以上系统，当app对某个permission发起授权请求，系统以permission group为单位，向用户提供授权选项。并且当下次对同一个group中的其他permission发起授权请求时，系统自动授予权限。 Define custom permissions 定义权限 123456789&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.myapp\" &gt; &lt;permission android:name=\"com.example.myapp.permission.DEADLY_ACTIVITY\" android:label=\"@string/permlab_deadlyActivity\" android:description=\"@string/permdesc_deadlyActivity\" android:permissionGroup=\"android.permission-group.COST_MONEY\" android:protectionLevel=\"dangerous\" /&gt; ...&lt;/manifest&gt; 由于四大组件是app的入口，app的自定义权限是通过限制四大组件的调用来起保护作用的。 通过在四大组件的声明标签中添加android:permission属性可以声明调用该组件所需要的权限。（动态注册和发送广播时也可以声明必须的权限）（ContentProvider通过android:readPermission和android:writePermission分别控制读写权限） uid及其权限作用 通过在manifest标签中声明sharedUserId属性，并指定相同的属性值，拥有相同签名的多个app在同一台设备上，会被分配相同的uid，从而app可以相互访问私有文件，以及在同一进程中运行。系统不允许uid不同的apk定义同名权限，定义已经存在的权限的apk会安装失败。 如果只想在拥有相同签名的app间共享机能，可以不用定义权限，而是直接进行签名检查。 If the functionality is only available to apps signed with the same signature as the providing app, you may be able to avoid defining custom permissions by using signature checks. When one of your apps makes a request of another of your apps, the second app can verify that both apps are signed with the same certificate before complying with the request. But how to verify ??? URI PermissionsOthers Often times a permission failure will result in a SecurityException being thrown back to the app. However, this is not guaranteed to occur everywhere. For example, the sendBroadcast(Intent) method checks permissions as data is being delivered to each receiver, after the method call has returned, so you will not receive an exception if there are permission failures. In almost all cases, however, a permission failure will be printed to the system log. A particular permission may be enforced at a number of places during your program’s operation: At the time of a call into the system, to prevent an app from executing certain functions. When starting an activity, to prevent apps from launching activities of other apps. Both sending and receiving broadcasts, to control who can receive your broadcast or who can send a broadcast to you. When accessing and operating on a content provider. Binding to or starting a service. Over time, new restrictions may be added to the platform such that, in order to use certain APIs, your app must request a permission that it previously did not need. Android may apply the new permission request to the app’s manifest. Android makes the decision as to whether an app might need the permission based on the value provided for the targetSdkVersion attribute. If the value is lower than the version in which the permission was added, then Android adds the permission. Caution: If a permission is automatically added to your app, your app listing on Google Play lists these additional permissions even though your app might not actually require them.To avoid this and remove the default permissions you don’t need, always update your targetSdkVersion to be as high as possible. You can see which permissions were added with each release in the Build.VERSION_CODES documentation If an app update includes the need for additional permissions， the user is prompted to accept those new permissions before updating the app. 总结 获取权限的结果由以下维度共同决定： 权限的 protection level（是否需要动态授权） 权限的 permission group（以权限组为单位进行授权） App的 targetSdkVersion（是否被自动补充权限声明以及是否需要动态授权等） App的uid（拥有相同signature的不同app可通过声明sharedUserId属性共享uid，从而有权互搞） 权限保护由以下维度共同决定： 四大组件在AndroidManifest.xml文件中声明时，通过标签属性或子元素，声明要求的权限。 URI Permission 动态检查权限其他App是否有某个权限 Context.checkCallingPermission()) Context.checkUriPermission()) PackageManager.checkPermission())","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android Resources 杂记","slug":"Android/Android 资源/Resources杂记","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T07:43:23.189Z","comments":true,"path":"2018/06/29/Android/Android 资源/Resources杂记/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/Android 资源/Resources杂记/","excerpt":"","text":"Resources分类 Base resource directories supported inside project res/ directory. animator/ anim/ color/ drawable/ mipmap/ layout/ menu/ raw/ values/ xml/ font/ Whereas XML resource files in other res/ subdirectories define a single resource based on the XML filename, files in the values/directory describe multiple resources. For a file in this directory, each child of the &lt;resources&gt; element defines a single resource. For example, a &lt;string&gt; element creates an R.string resource and a &lt;color&gt; element creates an R.color resource. Because each resource is defined with its own XML element, you can name the file whatever you want and place different resource types in one file. However, for clarity, you might want to place unique resource types in different files. Alternative Resourcesprovide alternative resources Directories of configuration-specific alternatives for a set of resources are in the following form: &lt;resources_name&gt;-&lt;config_qualifier&gt; Always provide default resources for the resources your app needs to perform properly. Then create alternative resources for specific device configurations using the configuration qualifiers. 除了针对不同密度的drawable资源不需要提供默认资源之外，其他资源都应该提供default 资源，否则系统可能因找不到对应的资源而抛出异常，使得app 崩溃。一般的做法是选择某个配置的资源作为default 资源，放置在不带qualifier 的资源目录下，比如将竖屏的layout 文件放在 layout/目录下，再将横屏的layout 文件放在layout-land目录下。 而对于针对不同密度的drawable，系统在找不到对应设备密度的资源时，会选择最佳匹配的drawable 资源，并根据需要进行缩放。 匹配资源 How Android Finds the Best-matching Resource Though this procedure is executed for each resource requested, the system further optimizes some aspects. One such optimization is that once the device configuration is known, it might eliminate alternative resources that can never match. For example, if the configuration language is English (“en”), then any resource directory that has a language qualifier set to something other than English is never included in the pool of resources checked (though a resource directory without the language qualifier is still included). If the qualifier in question is screen pixel density, Android selects the option that most closely matches the device screen density. In general, Android prefers scaling down a larger original image to scaling up a smaller original image. When selecting resources based on the screen size qualifiers, the system uses resources designed for a screen smaller than the current screen if there are no resources that better match (for example, a large-size screen uses normal-size screen resources if necessary). However, if the only available resources are larger than the current screen, the system doesn’t use them and your app will crash if no other resources match the device configuration (for example, if all layout resources are tagged with the xlarge qualifier, but the device is a normal-size screen). Some device configurations can change during runtime (such as screen orientation, keyboard availability, and language). When such a change occurs, Android restarts the running Activity(onDestroy() is called, followed by onCreate()). The restart behavior is designed to help your application adapt to new configurations by automatically reloading your application with alternative resources that match the new device configuration. Remember: When you declare your activity to handle a configuration change, you are responsible for resetting any elements for which you provide alternatives. If you don’t need to update your application based on these configuration changes, you can instead not implement onConfigurationChanged(). In which case, all of the resources used before the configuration change are still used and you’ve only avoided the restart of your activity. 比如显示string资源的TextView，需要重新设置string资源，否则不会随着语言的切换而自动切换。 Starting with Android 7.0 (API level 24), Android exposes the LocaleList.getDefault() API that lets apps directly query the list of languages a user has specified. This API allows you to create more sophisticated app behavior and better-optimized display of content. For example, Search can show results in multiple languages based on user’s settings. Formatters 使用Locale格式化字符串 Up through Android 6.0 (API level 23), Android supported only one or two locales for many common languages (en, es, ar, fr, ru). Because there were only a few variants of each language, apps could get away with storing some numbers and dates as hard coded strings in resource files. However, with Android’s broadened set of supported locales, there can be significant differences in formats for dates, times, currencies, and similar information even within a single locale. Hard-coding your formats can produce a confusing experience for end users. Therefore, when developing for Android 7.0 or higher versions, make sure to use formatters instead of hard coding numbers and date strings. For example, Android 7.0 and higher includes support for 27 Arabic locales. These locales can share most resources, but some prefer ASCII digits, while others prefer native digits. For example, when you want to create a sentence with a digit variable, such as “Choose a 4 digit pin”, use formatters as shown below: 1format(locale, \"Choose a %d-digit PIN\", 4) Drawable bitmap 可用于设置Drawable的重复模式，比如平铺 nine-patch .9图 layer-list 多个item按照定义的顺序层叠，最后定义的item在最顶层，可对item设置偏移值，item 里面可以有bitmap state-list 标签是&lt;selector&gt; 描述View在不同state下的Drawable lever-list 像是state-list 的可自定义版本，minLevel和maxLevel属性类比state，通过给View设置level可以应用不同的Drawable transition 通过渐变（alpha）动画渐变切换两个item指向的drawable，一般用于开关或CheckBox inset 用来在Drawable周围留边距，View的padding是不影响background的，所以这可以用来处理background clip 可以用于裁剪Drawable，实现类似进度条的效果，不过只能在水平和竖直方向裁剪，圆的就不行了。通过level动态控制裁剪多少。 scale 类似clip，可用于缩放Drawable，通过level动态控制缩放比例 shape 描述以矩形、圆形、线段、环形几何图形为基础的Drawable Others 通过使用别名来避免将同一份资源放置到具有不同qualifier 类型的资源目录（比如图片资源，可减少apk 大小；而layout 资源则可避免重复代码）。 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;drawable name=\"icon\"&gt;@drawable/icon_ca&lt;/drawable&gt;&lt;/resources&gt; Inline Complex XML Resources 对于组合式的xml 资源，可以用内联的方式定义在一个文件中，避免创建多个文件。不过对于那些需要针对不同qualifier 定义的资源，比如drawable-v21/ 和drawable/不知道有什么方法也搞一搞。 &lt;include&gt;声明的属性都会覆盖被引用的布局文件的root view，包括android:id Caution: If you want to override layout attributes using the &lt;include&gt; tag, you must override both android:layout_height andandroid:layout_width in order for other layout attributes to take effect. &lt;merge&gt; is an alternative root element that is not drawn in the layout hierarchy. Using this as the root element is useful when you know that this layout will be placed into a layout that already contains the appropriate parent View to contain the children of the &lt;merge&gt; element. This is particularly useful when you plan to include this layout in another layout file using &lt;include&gt; and this layout doesn’t require a different ViewGroup container. Quantity Strings (Plurals 复数字符串资源) 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;plurals name=\"numberOfSongsAvailable\"&gt; &lt;!-- As a developer, you should always supply \"one\" and \"other\" strings. Your translators will know which strings are actually needed for their language. Always include %d in \"one\" because translators will need to use %d for languages where \"one\" doesn't mean 1 (as explained above). --&gt; &lt;item quantity=\"one\"&gt;%d song found.&lt;/item&gt; &lt;item quantity=\"other\"&gt;%d songs found.&lt;/item&gt; &lt;/plurals&gt;&lt;/resources&gt; Formatting and Styling (格式化和带样式的字符串资源)","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android 资源加载","slug":"Android/Android 资源/资源加载","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T04:37:55.751Z","comments":true,"path":"2018/06/29/Android/Android 资源/资源加载/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/Android 资源/资源加载/","excerpt":"","text":"加载资源Android中与资源相关的类主要有Resources、ResourcesImpl、ResourcesManager、Java层的AssetManager和Native层的AssetManager。 Resources提供了大多数与应用开发直接相关的加载资源的方法，比如getColor(int resId)等。实现上是通过AssetManager来加载资源并进行解析。 AssetManagerJava层的AssetManager是对Native层AssetManager的封装，为上层提供了加载资源的方法。 加载资源包一般而言，一个App至少会引用两个资源包：系统资源包和App的资源包。一个AssetManager对象可加载多个资源包。App在创建AssetManager的时候，会先加载系统资源包，再加载App资源包。这样，通过一个AssetManager对象就可以访问系统资源包和App资源包的资源了。 AssetManager.addAssetPath(String path)是一个@hide方法，调用这个方法可以加载指定的资源包。 在android的资源中，还有个overlay的概念。用于指定覆盖的资源。 访问资源由于资源id包含了package id的信息，AssetManager通过解析资源id，即可知道从哪个资源包来加载资源。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"类加载","slug":"Android/Dex与类加载/类加载机制","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T07:36:08.036Z","comments":true,"path":"2018/06/29/Android/Dex与类加载/类加载机制/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/Dex与类加载/类加载机制/","excerpt":"","text":"加载机制 流程 loadClass()是ClassLoader加载类的入口方法，控制着Java 中的类加载流程。如果整个流程未能成功加载类，会抛出ClassNotFoundException。 findLoadedClass(String className)会查找已经加载的类，避免重复加载。 委托父亲加载器进行加载。 findClass(String className)真正实现类加载器自身加载类的过程。实现一般是定位到类文件（流），读取并调用defineClass()来加载解析类。应用开发者一般通过重写findClass()方法来自定义类加载。 ClassLoader中有多个defineClass()的重载方法，用于将class 文件加载创建对应的Class对象，此过程是由虚拟机实现的，因此这些方法都被final 修饰，不允许子类修改。 特性父亲委托机制ClassLoader会先尝试调用父亲加载器来加载类，如果加载失败（catch 父亲加载器抛出的ClassNotFoundException），再开始自身加载类的过程。 初始加载器机制根据父亲委托机制，一个类的加载过程，可能涉及到多个ClassLoader，我们将发起类加载的类加载器称为一个类的初始加载器，而将真正调用defineClass()方法来加载类的类加载器称为定义加载器。Class.getClassLoader()方法返回的是定义加载器。虚拟机会使用一个类的定义加载器作为初始加载器来加载这个类引用的其他类，即使这些引用类已经被加载过。 类型匹配机制Java 的类加载机制，使得多个名称相同的类可在Java 虚拟机中并存，它们有着不同的定义加载器。可以认为，定义加载器才真正定义了一个类型，不同的类加载器创建了各自的命名空间。 总结一方面，利用初始加载器机制，当开发者需要动态加载代码模块时，只需使用自定义的类加载器作为定义加载器来加载模块的入口类，随后虚拟机会自动使用这个类加载器来启动加载入口类引用的其他类。 另一方面，父亲委托机制，保证了一些基础类，可以在各个命名空间中被共享。 Android 中的类加载器 BaseDexClassLoaderAndroid 使用BaseDexClassLoader来加载类，它是ClassLoader的子类。由于Android 中的虚拟机与JVM 并不兼容，加载的二进制文件也并非class 文件，因此BaseDexClassLoader重写了findClass()，实现从apk、jar或者dex 文件中加载类。从源码可以看到，BaseDexClassLoader并未重写loadClass()，Android 保留了Java 中类加载的特性，包括父亲委托机制、初始加载器机制，类型匹配机制。 DexPathListBaseDexClassLoader的实现并不复杂，类的加载工作主要由其成员DexPathList承担。 DexPathList的成员Element[]存储了apk、jar或者dex 文件的加载结果，这是一个数组，每个文件的加载结果是其中的一个元素。这意味着DexPathList支持加载多个文件。DexPathList.findClass()在加载类时，会遍历数组来寻找。 DexFile真正实现了对apk、jar或者dex 文件的解析加载，以及加载类。其关键实现是调用了Native 方法。 PathClassLoader &amp; DexClassLoaderPathClassLoader和DexClassLoader是BaseDexClassLoader的子类，从源码可以看出，这两者只是简单地提供了构造函数，并没有实质性的工作。二者的不同之处在于后者比前者多了一个String optimizedDirectory这个参数。 1@param optimizedDirectory directory where optimized dex files should be written; must not be &#123;@code null&#125; 源码注释中也指明了这两者的用途：PathClassLoader是android系统和app 的类加载器，而DexClassLoader可以用于加载不随着apk 被安装的代码。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Dex文件","slug":"Android/Dex与类加载/Dex文件","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T07:34:39.396Z","comments":true,"path":"2018/06/29/Android/Dex与类加载/Dex文件/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/Dex与类加载/Dex文件/","excerpt":"","text":"DexDex (dalvik executables) 文件是二进制文件，而非文本文件，是编译java 代码的结果。 Android runtime (ART) is the managed runtime used by applications and some system services on Android. ART and its predecessor Dalvik were originally created specifically for the Android project. ART as the runtime executes the Dalvik Executable format and Dex bytecode specification. Dex 文件类似一个数据包，由 header 等多个数据段拼接而成。 Dex文件的结构在Dex 文件中，data（数据区）不是以类为单位来存储代码，而是分为字符串区域、filed区域、method区域等，所有的数据被分块存储，不同的区块之间通过引用来指明关系。 举例：method区域中一个方法的记录中，有着不同的字段，记录着方法名等。这些字段并非直接存储着这些数据，而是存储着这些数据在Dex 文件中位置的“指针”。比如方法名字段，实际上是一个代表着方法名字符串在字符串区域位置的数字。例如方法名字段为0x5，意味着方法名是字符串区域中的第五个字符串。 值得一提的是，字符串区域，不仅仅存储着代码中的字符串常量，也存储着类名、方法名等字符串。 数据名称 解释 header dex文件头部，记录整个dex文件的相关属性 string_ids 字符串数据索引，记录了每个字符串在数据区的偏移量 type_ids 类似数据索引，记录了每个类型的字符串索引 proto_ids 原型数据索引，记录了方法声明的字符串，返回类型字符串，参数列表 field_ids 字段数据索引，记录了所属类，类型以及方法名 method_ids 类方法索引，记录方法所属类名，方法声明以及方法名等信息 class_defs 类定义数据索引，记录指定类各类信息，包括接口，超类，类数据偏移量 data 数据区，存储代码的真实数据 link_data 连接数据区 Header 字段名称 偏移值 长度 说明 magic 0x0 8 魔数字段，值为”dex\\n035\\0” checksum 0x8 4 校验码 signature 0xc 20 sha-1签名 file_size 0x20 4 dex文件总长度 header_size 0x24 4 文件头长度，009版本=0x5c,035版本=0x70 endian_tag 0x28 4 标示字节顺序的常量 link_size 0x2c 4 链接段的大小，如果为0就是静态链接 link_off 0x30 4 链接段的开始位置 map_off 0x34 4 map数据基址 string_ids_size 0x38 4 字符串列表中字符串个数 string_ids_off 0x3c 4 字符串列表基址 type_ids_size 0x40 4 类列表里的类型个数 type_ids_off 0x44 4 类列表基址 proto_ids_size 0x48 4 原型列表里面的原型个数 proto_ids_off 0x4c 4 原型列表基址 field_ids_size 0x50 4 字段个数 field_ids_off 0x54 4 字段列表基址 method_ids_size 0x58 4 方法个数 method_ids_off 0x5c 4 方法列表基址 class_defs_size 0x60 4 类定义标中类的个数 class_defs_off 0x64 4 类定义列表基址 data_size 0x68 4 数据段的大小，必须4k对齐 data_off 0x6c 4 数据段基址 SmaliDex 文件作为二进制文件，可读性和可编辑性很差。dex2Jar 等工具，可以将Dex 文件反编成Jar 文件甚至解析成java 文件。值得注意的是，Dex 文件内容与Java 代码不能完全对应，即Dex 文件中的代码是以指令为基本单位，而Java 代码作为高级语言，往往一个语句可编译成多个指令，因此在反汇编过程中会有改动或信息丢失。 Smali 类似汇编语言，是根据Dex 文件字节码格式，将可读性差的二进制数据解析成可读性更强的指令。将Dex 文件转成Smali 文件的过程称为baksmali ，反过来称为smali。因此Smali 可以指代一种语言、文件格式或者将Smali 文件转成Dex 文件的过程。 从上面Dex 文件的结构可以看出，Dex 文件中实际上是将不同类型的数据分块存储。在代码区域，存储着函数方法的实现，即编译后的指令。根据Android 对指令集的定义，我们可以解析指令。 What is Smali Code Android What is smali in Android? 指令集Dex 文件中的代码区，包含了方法中的指令。 每条指令包含一个指令码（Op），可在此处查询对应的Op 及其含义，可以理解为不同的指令码对应着不同的操作，如调用方法、赋值等。 不同指令的指令格式可能不同，比如，调用方法（可能）需要指明调用对象、方法名、参数等，而赋值需要指明赋值对象和值。因此每个指令码对应有一个指令格式，通过指令格式标识来指明。指令格式标识大多由三个字符组成，前两个是数字，最后一个是字母。在此处可查询不同的指令格式。 第一个数字是表示指令有多少个16位的字组成。 第二个数字是表示指令最多使用寄存器的个数。特殊标记“r”标识使用一定范围内的寄存器。 第三个字母为类型码，表示指令用到的额外数据的类型 。 Dalvik指令格式 指令解析 参考 Dalvik字节码指令及Smali文件 Dex文件格式详解 odex And oatAndroid 系统在安装app 的时候，会提取dex 文件进行预处理，并将处理结果写入 \\data\\dalvik-cache\\ 目录下，运行app 时加载处理过的文件。不同系统的预处理行为有所不同，生成的文件类型也不同，但目标文件名仍然以“.dex”作为后缀。 5.0 之前的系统预处理行为是对dex 文件进行优化，生成的文件仍然是字节码文件，文件格式称为odex 或dey。 虚拟机Dalvik 中包含一个解释器，在运行app 时，加载odex 文件并将指令逐条解释成机器码执行。从Android 2.2开始，还引入了JIT（Just-In-Time），在运行时，会识别使用频率高的代码块，先编译成本地机器码再执行，以提高效率。顾名思义，JIT 是每次运行时都需要重新进行的操作。 5.0 及以上系统预处理行为是将dex 进行编译，将字节码编译成本地机器码，文件格式称为oat 或elf。运行时，ART 加载oat 文件，由于存储的是机器码，无需解释执行字节码指令，从而提高了效率。 参考Android ART运行时无缝替换Dalvik虚拟机的过程分析","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"MultiDex","slug":"Android/Dex与类加载/MultiDex","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T04:42:35.901Z","comments":true,"path":"2018/06/29/Android/Dex与类加载/MultiDex/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/Dex与类加载/MultiDex/","excerpt":"","text":"背景问题65536 的方法数限制Android 官方在Multidex 方案中提到，在单个Dex 字节码文件中，能被代码调用的方法数量不能超过65536 个。 65536 represents the total number of references that can be invoked by the code within a single Dalvik Executable (DEX) bytecode file. Dex 文件中不能存储超过65536个方法？在Dex 文件的格式规范中，有两个数据信息与存储的方法相关： 4个字节表示的 method_id_size，远大于65536. 用于描述方法的数据结构，method_id_item，并没有限制方法数不能超过65536 。 method_id_item | Name | Format | Description | | ——— | —— | —————————————- | | class_idx | ushort | index into the type_ids list for the definer of this method. This must be a class or array type, and not a primitive type. | | proto_idx | ushort | index into the proto_ids list for the prototype of this method | | name_idx | uint | index into the string_ids list for the name of this method. The string must conform to the syntax for MemberName, defined above. | 相对应的，在Dalvik virtual machine 的源码中，DexFile.h 中的类和结构体等，存储了Dex 文件被虚拟机加载解析后的数据。其中，用于描述方法的结构体DexMethodId如下。 12345struct DexMethodId &#123; u2 classIdx; /* index into typeIds list for defining class */ u2 protoIdx; /* index into protoIds for method prototype */ u4 nameIdx; /* index into stringIds for method name */&#125;; 据此，我们可以看出，无论是Dex 文件规范，还是虚拟机的实现中，都没有限制一个Dex 文件中可以声明的方法数不能超过65536。 能被调用的方法无法超过65536个65536 的方法数限制，实际上是来自于指令集中调用方法的指令格式的定义。调用方法的指令中，仅用16位来存储要调用的方法的引用（指代在method_ids section 中第几个方法）。也就是说尽管method_ids section 中可以存储的方法数远远多于65536，但是能被调用的却只有65536个。这也解释了为什么65536 是被引用的方法数的上限，而不是App 声明的方法数的上限。即，App 中对Android 框架代码的调用，也会被计入。 invoke-kind {vC, vD, vE, vF, vG}, meth@BBBB B: method reference index (16 bits) 这也是构建工具报“65536”错误的根本原因，原因不在于构建工具，而在于指令集。否则Google 只需要发布新的构建工具即可。 思考Google 为何不推行新的指令集来解决此问题？个人认为应该是为了兼容老版本的系统。推出新的指令集，意味着构建的Dex 文件中的指令格式与以往不同，从而无法被老版本的系统识别。 参考Does the Android ART runtime have the same method limit limitations as Dalvik? LinearAlloc exceededFacebook hack 和 Android 官网 中，都提到了一个问题，名为LinearAlloc的buffer 溢出而引起崩溃。LinearAlloc缓存了app 中的方法的信息，它在安装和运行app的时候都会发挥作用。 安装app安装的时候，“dexopt” 这个程序在预处理dex 文件的时候会使用LinearAlloc来索引Dex 文件中的所有方法。通过拆分Dex，可以避免此问题。 http://code.google.com/p/android/issues/detail?id=22586 During standard installation, a program called “dexopt” runs to prepare your app for the specific phone it’s being installed on. Dexopt uses a fixed-size buffer (called the “LinearAlloc” buffer) to store information about all of the methods in your app. Recent versions of Android use an 8 or 16 MB buffer, but Froyo and Gingerbread (versions 2.2 and 2.3) only have 5 MB. Because older versions of Android have a relatively small buffer, our large number of methods was exceeding the buffer size and causing dexopt to crash. When running on versions prior to Android 5.0 (API level 21), using multidex is not enough to work around the linearalloc limit (issue 78035). This limit was increased in Android 4.0 (API level 14), but that did not solve it completely. And on versions lower than Android 4.0, you might reach the linearalloc limit before reaching the DEX index limit. 运行app运行的时候，app 会使用LinearAlloc来索引方法。由于Facebook 在拆分Dex 之后，运行时将子Dex 注入到ClassLoader中，使得运行时的方法数并没能减少，因此再次遇上了此问题。其通过 JNI 来替换buffer，增大其空间，以此来解决问题。 The LinearAlloc buffer doesn’t just exist in dexopt–it exists within every running Android program. While dexopt uses LinearAlloc to to store information about all of the methods in your dex file, the running app only needs it for methods in classes that you are actually using. Looking at the definition of the LinearAlloc buffer (https://github.com/android/platform_dalvik/blob/android-2.3.7_r1/vm/LinearAlloc.h#L33), we realized that if we could only increase that buffer from 5 MB to 8 MB, we would be safe! That’s when we had the idea of using a JNI extension to replace the existing buffer with a larger one. 总结无论是构建时的65536 问题，还是 LinearAlloc exceeded 问题，都将矛头指向了方法数，特别是单个Dex 中的方法数过多的问题。一个可行的解决方案是，在构建的时候将代码拆分到多个Dex。值得一提的是，拆分后所有Dex 的方法数之和不等于原先一个Dex 的方法数。 方案构建多DexAnt 构建Custom Class Loading in Dalvik Gradle 构建123456789android &#123; defaultConfig &#123; ... minSdkVersion 21 targetSdkVersion 26 multiDexEnabled true &#125; ...&#125; Now when you build your app, the Android build tools construct a primary DEX file (classes.dex) and supporting DEX files (classes2.dex, classes3.dex, and so on) as needed. The build system then packages all DEX files into your APK. 运行多DexART本身支持从apk文件中加载多个Dex。ART在app安装时，会进行预处理（Ahead of time compilation），即扫描apk包中所有的Dex文件，进行编译并生成一个oat执行文件。因此ART在运行时只需加载一个oat文件，无需处理加载多Dex 的问题。相对应的，由于运行Dalvik 的系统（5.0以下系统）默认只加载一个Dex（以下简称主Dex），开发者需要处理加载运行其他Dex（以下简称子Dex） 的问题。 DexClassLoader在 Custom Class Loading in Dalvik 中提到的方案，主要包含以下内容： 在app 代码设计上，划分模块。 将不同的模块编入不同的Dex。 模块之间通过接口关联调用。 运行时使用DexClassLoader动态加载子Dex，反射创建子Dex 中的业务对象，并强转为约定的接口进行调用。 分析此方案适合模块之间较为独立的项目，其缺点是约束性较强，模块之间仅能通过接口或者反射进行调用，并且随着接口的增多，Dex 中的方法数也相应地增多。 改进将多个模块共用的基础业务或工具划分到主Dex，利用ClassLoader的父类委托机制，将主Dex 的ClassLoader作为子Dex 的ClassLoader的父亲。通过这种方式，子模块可直接调用主Dex 中的类，无需反射调用以及借助接口。 Hook DexPathList123dependencies &#123; compile 'com.android.support:multidex:1.0.3'&#125; 原理是BaseDexClassLoader允许加载多个apk、jar或者dex文件，并从中加载类。需要使用反射来实现。 遇到过的问题加载Dex 是耗时操作需要在划分Dex 的时候按业务模块划分，加载的时候，运用多线程、提前加载等，再结合交互上的进度圈等，优化体验。在美团的方案中也提到了，通过Hook Instrumentation 的方式来避免多线程加载时的同步问题。 按需加载Dex曾经想要做到按需加载Dex，也就是在需要加载一个类的时候，才去加载这个类所在的Dex。最好的方法自然是使用自定义的类加载器。 一开始企图使用反射，直接将ContextImpl里的mClassLoader替换为自定义的类加载器，但是由于初始加载器机制，使得自定义类加载器并未发挥作用。于是，改变策略，通过反射将自定义类加载器设置为系统类加载器的父亲，以此来获得优先加载权。 但是又碰到另一个问题：Dalvik 提前解析依赖类。在Dalvik 上，加载类的时候，会进行优化和验证，此过程会解析类的依赖（但是不会马上加载，在真正执行的时候才会加载）。如果一个类A引用了子Dex 中的类B，在加载类A的时候，如果此时还未加载子Dex，可观察到如下log。即使在真正执行到与依赖的类相关的语句之前加载子Dex，仍然会报NoClassDefFoundError。根据log可猜测，类A在加载的时候，与类B相关的某些指令被替换修改了。这对按需加载的打击是毁灭性的。ART 上则不存在此问题。 1234E/dalvikvm: Could not find class &apos;com.example.dex.lib.Test&apos;, referenced from method com.example.dex.App.attachBaseContextW/dalvikvm: VFY: unable to resolve new-instance 28 (Lcom/example/dex/lib/Test;) in Lcom/example/dex/App;D/dalvikvm: VFY: replacing opcode 0x22 at 0x0039D/dalvikvm: DexOpt: unable to opt direct call 0x003e at 0x3b in Lcom/example/dex/App;.attachBaseContext There’s a thing called Dalvik verifier that has complex rules for determining inappropriate bytecode. For example, before loading the Application class, VM verifier performs its checks and if it finds a field whose type it can’t resolve (yet), it will not allow to run instruction that accessing this field, even if at that point of time we already patched the ClassLoader and the class could be resolved.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"View树的绘制","slug":"Android/View/View树的绘制","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T07:38:29.175Z","comments":true,"path":"2018/06/29/Android/View/View树的绘制/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/View/View树的绘制/","excerpt":"","text":"View树的绘制自顶向下的绘制派发View树的绘制流程是由ViewRootImpl发起，从根View开始，向子View树派发绘制事件。 View有两个draw()重载方法： View的软件绘制行为。 1234567891011/** * Manually render this view (and all of its children) to the given Canvas. * The view must have already done a full layout before this function is * called. When implementing a view, implement * &#123;@link #onDraw(android.graphics.Canvas)&#125; instead of overriding this method. * If you do need to override this method, call the superclass version. * * @param canvas The Canvas to which the View is rendered. */@CallSuperpublic void draw(Canvas canvas) 由父View调用，会根据layer type 和硬件加速是否开启选择不同的绘制行为。 1234567/** * This method is called by ViewGroup.drawChild() to have each child view draw itself. * * This is where the View specializes rendering behavior based on layer type, * and hardware acceleration. */boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) 重绘请求自底向上传递的invalidate 请求View.invalidate()的系列重载方法，通过调用ViewParent.invalidateChild()向父View发起重绘请求，请求在View树中逐层往上传递，最后到达ViewRootImpl，由其触发新的绘制流程。 postInvalidate与invalidate()不同，postInvalidate()并非自底向上地向父View发起请求，而是直接调用attachInfo.mViewRootImpl.dispatchInvalidateDelayed()，来发送一个消息。 12345678910111213141516public void dispatchInvalidateDelayed(View view, long delayMilliseconds) &#123; Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view); mHandler.sendMessageDelayed(msg, delayMilliseconds);&#125;//...final class ViewRootHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_INVALIDATE: ((View) msg.obj).invalidate(); break; //... &#125; &#125;&#125; 可以看到，该消息的处理，实际上是调用发起postInvalidate()方法的View的invalidate()方法，从而发起一个invalidate 重绘请求。 postInvalidate() can be invoked from outside of the UI thread only when this View is attached to a window. 典型场景View.setVisibility()等方法正是通过invalidate()方法来发起重绘请求。 渲染Android系统在渲染画面到显示屏上时，先把View的内容计算成多边形、纹理 ，再交由GPU 转换到不同的像素上进行显示， 后者称为栅格化（rasterization），是一个复杂耗时的过程。 CanvasCanvas 记录了一个View的绘制命令。View使用Canvas来发起绘制命令，比如绘制各种形状、Bitmap等。 The Canvas class holds the “draw” calls. To draw something, you need 4 basic components: A Bitmap to hold the pixels, a Canvas to host the draw calls (writing into the bitmap), a drawing primitive (e.g. Rect, Path, text, Bitmap), and a paint (to describe the colors and styles for the drawing). ClipRectView的内容绘制（onDraw()）本身并不关注脏区域，而是由Canvas的裁剪区域决定了哪些区域会被绘制。换言之，View在使用Canvas进行绘制时，Canvas已经根据脏区域设置了裁剪区域。 MatrixCanvas有一个Matrix对象，用于记录当前的transformation。在View.draw(Canvas canvas, ViewGroup parent, long drawingTime)中，会根据View在父View中的坐标、translation以及scroll 等对Canvas的Matrix设置偏移，使得View的左上角对应到Canvas的原点。因此View在执行真正的绘制工作时（比如onDraw()），无需考虑偏移、缩放等。这也是为什么View的transformation不会影响布局。 举个例子：当View的translationY不为0时，View.onDraw()在实现绘制时并不需要设置Canvas的偏移值，因为Canvas的Matrix已经记录了所有的transformation，View的开发者只需要关注内容的绘制。 在使用View 动画Animation时，会从Animation中计算得到Transformation对象，并通过Canvas.concat(TransformToApply.getMatrix())将动画的当前结果（偏移、alpha等）设置到Canvas的Matrix中，从而绘制出动画中的这一帧。 View 的MatrixView也有一个Matrix对象，用于记录当前View的transformation（translation、scale、alpha等）。触摸事件在派发时，判断事件是否落在View的位置上时，会使用View.getInverseMatrix().mapPoints(point)来帮助计算事件与转换（移动、缩放、旋转）后的View的关系。 Animation在View 动画中，是通过Canvas的Matrix使视图内容发生变化，而View本身的属性不变，因此View的触摸事件响应区域不随动画而改变。 Animator在属性动画中，是通过设置View本身的属性，从而改变了View的Matrix，因此View的触摸事件响应区域会随着动画而改变。 绘制模型Android 的绘制模型包括软件模型（Software-based drawing model） 和硬件加速模型（Hardware accelerated drawing model）。 Software-based drawing model每次绘制（重绘），都需要调用Canvas来发起绘制命令，也就是执行View.onDraw()等方法。 invalidate 流程会将脏区域从View坐标（从脏View开始向父View递归计算）转换成屏幕坐标，在重绘时，所有与脏区域有交集的View都会重新绘制。 View绘制时使用的Canvas是由ViewRootImpl的Surface.lockCanvas(Rect inOutDirty)得来，整棵View树都是使用该对象进行绘制，创建的Canvas已经根据参数inOutDirty设置了裁剪区域，也就是脏区域。View的内容绘制（onDraw()）本身并不关注脏区域，而是由Canvas的裁剪区域决定了哪些区域会被绘制。 Hardware accelerated drawing modelView绘制时使用的Canvas是DisplayListCanvas，其不会马上执行绘制命令，而是使用Display Lists 来记录绘制操作，最后通过绘制Display Lists 来发起绘制命令。在重绘时，只有脏View需要重新创建Display List，也就是只有脏View的onDraw()等绘制方法会被执行。 另一方面，对于诸如缩放、移动、旋转、设置alpha 等行为，也不需要执行脏View的onDraw()等绘制方法来重建Display List，直接设置Display List 的属性，即可交由GPU 进行计算。 硬件加速减少了大量CPU 计算，将部分以浮点运算为主的操作交给擅长浮点运算的GPU 执行。 在 android 26中，每个View 有一个RenderNode，硬件加速使用的DisplayListCanvas是由RenderNode.start(int width, int height)创建的，因此每个View在绘制时使用的Canvas不是同一个对象。 硬件加速使用 硬件加速开关 判断是否开启 总结用户界面是以View为基本模块，并以树的结构进行组织，所以像绘制、触摸事件处理、重绘请求等流程，都包含一个基本行为模式：遍历View树或者其子树： 要么是从ViewRootImpl开始遍历View树，并根据一些条件跳过一些View树，或者选择遍历路径。 要么是从某个节点开始，递归或循环遍历父节点，直到ViewRootImpl。 View是用户界面的蓝图，而Canvas是将界面蓝图输出到结果的工具（显示到屏幕上、或者绘制到Bitmap上）。 View和Canvas都有Matrix，前者的Matrix记录了View的transformation，而后者的用于控制内容的输出结果。View往往会根据自身的transformation以及View坐标，对Canvas的Matrix进行设置，使得绘制在预期的位置以及得到预期的绘制效果。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android插件化分析篇","slug":"Android/插件化/插件化分析","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T05:12:59.505Z","comments":true,"path":"2018/06/29/Android/插件化/插件化分析/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/插件化/插件化分析/","excerpt":"","text":"作用 动态更新 减小apk包容量，减少方法数 提升编译速度 考虑因素维护成本 与技术选型相关，对Android 系统侵入性越强，开发与测试维护成本越高。 插件开发维护成本。 插件版本管理。 插件与宿主关系维护。 技术难点依赖与混淆取决于插件框架的管理模式，插件之间的耦合以及插件与宿主之间的耦合。 无安装带来的问题由于插件并没有被系统安装，未能得到app级别的待遇。系统安装app过程有个重要步骤，解析Apk中的AndroidManifest.xml，完成注册四大组件等工作。缺少此过程，主要产生了以下问题。 四大组件未注册，无法使用常规方法调用。 资源加载问题。 权限、进程等其他只能在AndroidManifest.xml文件中声明的特性。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"View的绘制三要点","slug":"Android/View/View的三要点","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T07:37:17.816Z","comments":true,"path":"2018/06/29/Android/View/View的三要点/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/View/View的三要点/","excerpt":"","text":"View的绘制三要点View作为用户界面的基本组成模块，需要处理三个问题：显示区域的大小、显示位置、显示的内容。因此，View的绘制从工作内容的角度来看，有三要点：measure（计算尺寸），layout（排版布局）和draw（绘制内容）。 在设计上，采用了模板方法模式，View为这三个步骤定义了measure()、layout()和draw()三个模板方法，模板方法分别调用了onMeasure()、onLayout()和onDraw()这三个具体方法，View的子类根据各自的特性复写这三个具体方法，来实现真正与计算尺寸、排版和内容相关的工作。 在结构和流程上，View之间形成树状结构，由ViewRootImpl触发，从根View开始，采用深度优先的方式，自顶向下遍历子View，发起工作。值得注意的是，View通过ViewParent这个接口类型来持有自己的父View，而不是ViewGroup类型。而ViewGroup和ViewRootImpl都实现了ViewParent接口。这就解决了每个View，包括根View，都有父亲的问题，即使ViewRootImpl并不是View的子类。从这个角度来讲，可以将ViewRootImpl视为整棵树的根，当然，此时这棵树就不能称为View树了。 measuremeasure主要有两方面的工作： 计算尺寸 模板方法measure(int widthMeasureSpec, int heightMeasureSpec)中的两个参数（以下简称measureSpec）是父View提供给子View 进行measure()的“参考值”。这两个参数的本质，可以认为是View体系关于尺寸的协议。 设置计算结果 View根据measureSpec以及其他信息（比如自身的尺寸需求）计算完尺寸后，必须通过setMeasuredDimension(int measuredWidth, int measuredHeight)方法进行设置使计算结果生效。 值得一提的是，measure()方法是final修饰的，意味着子类不能修改其行为。其执行了一些优化（比如通过判断是否真的需要执行具体方法来避免无谓的计算）。 MeasureSpecmeasureSpec是一个int类型，它包含了两个信息：size和mode。高位两个bit表示mode，低位30个bit表示size。View有一个静态内部类MeasureSpec，封装了创建和解析measureSpec的方法。 注：measureSpec是小写开头，表示尺寸规格。MeasureSpec是大写开头，是一个辅助类。 mode的三个类型 AT_MOST表示父View认为该子View的最大尺寸是measureSpec中指定的size。 EXACTLY表示父View认为该子View的尺寸就是measureSpec中指定的size。 UNSPECIFIED表示父View不知道子View的尺寸。 measureSpec 的来源measureSpec是父View为子View的measure提供的“参考值”，来源于父View。而根View的measureSpec来自于ViewRootImpl（不是View的子类，但实现了ViewParent接口）。 measureSpec 的计算规则 ViewRootImpl调用getRootMeasureSpec()方法，根据Window的尺寸和WindowManager.LayoutParams为根View计算measureSpec。 ViewGroup中提供了getChildMeasureSpec()方法，根据父View自身的大小规格，和要测量的子View的LayoutParams（来自于xml布局文件中指定的layout_width和layout_height，或者代码中动态设置），来计算measureSpec。 measureSpec 的意义与使用准则measureSpec可以理解为View体系关于尺寸的协议，尤其是其所携带的mode信息，为子View计算自身尺寸提供了信息。然而measureSpec的计算规则以及View之间的亲子组合关系的不确定性，使得其协议不能为View的显示结果提供任何保证。 举个例子，LinearLayout在计算子View的measureSpec时，调用了ViewGroup.getChildMeasureSpec()，也就是采用了默认的计算规则。如果发现子View的LayoutParams中明确指定了具体的尺寸，而不是match_parent或wrap_content，会将子View的measureSpec的mode设置为EXACTLY，而size则设置为指定的尺寸。而这个size可能实际上超出了LinearLayout本身的尺寸，这可能导致子View被截断。 综上，measureSpec本身不保证其指定的尺寸信息能使得子View能“正确”显示（正确是指，View的内容能通过滚动、缩放等方式完全展示）。但这并不意味着measureSpec没有意义，而是要求布局控件开发者、非布局控件开发者以及布局开发者，共同遵守良好的准则，才能使得measureSpec提供“正确”的参考值。良好的准则是指，开发者需充分考虑父View和子View的特性与尺寸，比如父View是否可滚动显示其内容，子View是否可缩放等，如若不具备这些特性，则不应该为他们设置冲突的尺寸，以免导致“错误”显示。 计算尺寸 View在计算尺寸时，一般需要考虑两个方面： 来自于父View和布局开发者的尺寸约束，也就是measurSpec，以下简称其中的size信息为specSize。 来自于自身的尺寸需求（以下简称size），如最小宽高、或者宽高相同等。 View中提供了一些方法来从size和specSize中做出选择。 getDefaultSize(int size, int measureSpec)会以遵守measureSpec为准则，如果measureSpec的mode为UNSPECIFIED，会返回size参数，否则会返回specSize。 getSuggestedMinimumWidth()和getSuggestedMinimumHeight()根据View的背景和自身的mMinWidth和mMinHeight属性来返回一个“建议”的最小size。 resolveSize(int size, int measureSpec)会在遵守measureSpec的前提下，返回size，否则会返回specSize。具体规则： 如果mode为AT_MOST，且size小于specSize，或者mode为UNSPECIFIED，返回size。 否则返回specSize。 在真正的尺寸和measureSpec之间，还有一个中间产物，measureSize，它也是一个由两部分信息拼起来的int类型。measureSize的高位一个字节是state，低位三个字节表示具体的size。目前state只有默认和MEASURED_STATE_TOO_SMALL两种。measureSize代表了一个计算结果的尺寸和measureSpec之间的关系，即为了遵守measureSpec，是否采取了一个小于自身需求的尺寸。 MEASURED_STATE_TOO_SMALL indicates that the measured size is smaller that the space the view would like to have. ViewGroup因为嵌套了子View，因此其measure过程，往往需要发起子View的measure过程。ViewGroup提供了一些方法来计算提供给子View的measureSpec并触发其measure过程。 注：在这些方法中的measureSpec参数，都是ViewGroup自身的measureSpec，他们是计算子View的measureSpec的重要依据。 12345678910/** * Ask all of the children of this view to measure themselves, taking into * account both the MeasureSpec requirements for this view and its padding. * We skip children that are in the GONE state The heavy lifting is done in * getChildMeasureSpec. * * @param widthMeasureSpec The width requirements for this ViewGroup * @param heightMeasureSpec The height requirements for this ViewGroup */protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) 12345678910/** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding. * The heavy lifting is done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this ViewGroup * @param parentHeightMeasureSpec The height requirements for this ViewGroup */protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) 123456789101112131415/** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding * and margins. The child must have MarginLayoutParams The heavy lifting is * done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this ViewGroup * @param widthUsed Extra space that has been used up by the parent * horizontally (possibly by other children of the parent) * @param parentHeightMeasureSpec The height requirements for this ViewGroup * @param heightUsed Extra space that has been used up by the parent * vertically (possibly by other children of the parent) */protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) 1234567891011121314151617181920/** * Does the hard part of measureChildren: figuring out the MeasureSpec to * pass to a particular child. This method figures out the right MeasureSpec * for one dimension (height or width) of one child view. * * The goal is to combine information from our MeasureSpec with the * LayoutParams of the child to get the best possible results. For example, * if the this view knows its size (because its MeasureSpec has a mode of * EXACTLY), and the child has indicated in its LayoutParams that it wants * to be the same size as the parent, the parent should ask the child to * layout given an exact size. * * @param spec The requirements for this ViewGroup * @param padding The padding of this view for the current dimension and * margins, if applicable * @param childDimension How big the child wants to be in the current * dimension * @return a MeasureSpec integer for the child */public static int getChildMeasureSpec(int spec, int padding, int childDimension) 设置计算结果 onMeasure()方法中必须调用setMeasuredDimension(int measuredWidth, int measuredHeight)来设置计算结果使其生效（measure()会在调用onMeasure()后检查是否已设置尺寸，若未设置将抛出IllegalStateException）。 setMeasuredDimension(int measuredWidth, int measuredHeight)的两个参数并不是measureSpec，而是measureSize，或者只包含尺寸信息的int。 View中提供了一些方法，可在设置过结果后，获取计算结果。 getMeasureWidth()和getMeasureHeight()方法返回的是尺寸信息。 getMeasuredWidthAndState()和getMeasuredHeightAndState()方法返回的是measureSize。 123456789101112/** * Return only the state bits of &#123;@link #getMeasuredWidthAndState()&#125; * and &#123;@link #getMeasuredHeightAndState()&#125;, combined into one integer. * The width component is in the regular bits &#123;@link #MEASURED_STATE_MASK&#125; * and the height component is at the shifted bits * &#123;@link #MEASURED_HEIGHT_STATE_SHIFT&#125;&gt;&gt;&#123;@link #MEASURED_STATE_MASK&#125;. */public final int getMeasuredState() &#123; return (mMeasuredWidth&amp;MEASURED_STATE_MASK) | ((mMeasuredHeight&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT) &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));&#125; layout模板方法View的layout()不是final方法，除了调用onLayout，还执行了调用回调（onLayoutChanged()）等工作。ViewGroup的layout()方法则被final修饰。 View.layout()中会调用setFrame()对mLeft等四个属性进行赋值，从而使得getWidth()和getHeight()能返回有效的值。 具体方法View.onLayout()是个空实现，ViewGroup.onLayout()甚至重新将其声明为abstract方法，这意味着，排版布局是ViewGroup子类的重点工作，因为排版正是布局控件的重要功能。而对于非布局控件而言往往没有排版的需要。 参数measure步骤为layout(int l, int t, int r, int b)和onLayout(boolean changed, int left, int top, int right, int bottom)提供了参数，这四个参数表示View在父View中的位置，同时也表示着父View为子View指定的空间。 从参数可以看出，子View的真正尺寸不一定是其在measure步骤中设置的尺寸，父View的排版决定了子View的真正尺寸。但这并不表示measure没有意义，因为父View在排版时，往往会根据子View的measure结果计算其layout的参数。 同时，也能看出getMeasuredWidth()、getMeasuredHeight()和getWidth()、getHeight()在生效时机和实际意义上的区别。 drawdraw()方法虽不被final修饰，但一般子类不修改其行为，因为其除了调用onDraw()方法，还执行了诸如绘制背景、触发子View绘制这些约定俗成的工作。 绘制背景drawBackground(canvas) If necessary, save the canvas’ layers to prepare for fading 调用具体方法onDraw() 调用具体方法dispatchDraw()，ViewGroup及其子类复写该方法实现调用子View进行绘制 If necessary, draw the fading edges and restore layers Draw decorations (foreground, scrollbars). 调用onDrawForeground(canvas) draw the default focus highlight. 调用drawDefaultFocusHighlight(canvas) 参考 绘制特效​","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android插件化方案篇","slug":"Android/插件化/插件化方案","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T08:17:44.842Z","comments":true,"path":"2018/06/29/Android/插件化/插件化方案/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/插件化/插件化方案/","excerpt":"","text":"本文从三个方面来介绍插件化的一些方案：类加载、适配android特性、插件框架。最后再列举一些遇到过的其他问题。 类加载Hook DexPathList将包含插件类的Dex文件或Apk文件通过反射的方式，添加到App的PathClassLoader中，即可无差别地调用类。 New DexClassLoader创建新的DexClassLoader来加载插件的类。采用这种方式，宿主App无法直接引用插件中的类。但是一般而言，插件和宿主App之间不应该直接耦合。 适配android特性适配android特性指的是，让插件拥有App的能力。包括但不限于：能调起插件的界面、访问插件资源等。这里主要介绍这两者。 插件界面由于插件没有被系统安装，其Actvivity没有向系统注册，无法直接调起。可行的方案如下： 使用Fragment插件中使用Fragment来控制界面是一个可行的方案。 Activity代理在宿主App中声明Activity作为代理类，持有插件中的Activity实体对象，在Activity各个回调函数中调用实体对象的对应方法。缺点是不够灵活。 Hook Instrumentationandroid中启动Activity时，由Instrumentation负责创建Activity对象并回调其生命周期。通过反射将ActivityThread对象的mInstrumentation成员替换为我们自定义的InstrumentationWrapper的实例，我们可以改变调起Activity的一些行为。 主要思路包含以下操作： 代理使用InstrumentationWrapper代理真正的Instrumentation对象，以此在Activity的启动流程中增加一些操作，来绕过系统的检查，解决Activity未注册的问题。 寄宿在宿主App中声明壳Activity，在插件Activity的启动流程中，先替换为壳Activity来绕过系统检查，并在创建Activity时，返回插件Activity的类名。 前置和后置处理在回调插件Activity.onCreate()之前，执行加载插件资源和应用插件Activity主题的工作。 在回调插件Activity.onCreate()之前，执行释放壳Activity的工作。 插件资源利用Android中管理资源的类AssetManager和Resources等，可加载插件资源。有两种思路，适用于不同的情况。 替换系统在创建Activity实例后，会为其创建对应的资源管理类，AssetManager和Resources等。当插件和宿主之间的资源没有关联时，即不相互依赖时，可以在创建插件Activity时，为其创建新的资源管理类，并指定加载插件的资源包。 采用此方式的时候，还需要视情况考虑是否为插件Activity设置依赖插件资源创建的Resources.Theme。 合并当插件和宿主之间存在资源依赖的关系时，可直接调用宿主资源管理器的AssetManager.addAssetPath(String path)来加载插件资源包。 资源id冲突采用此方式，需要考虑资源id冲突的问题。一个解决思路是，为不同的资源包指定不同的package id（默认都是0x7f）。 编译时修改aapt，为资源id指定不同的package id。 编译后在默认的编译行为后，再来修改R类和资源索引表resources.arsc文件等。 插件框架在插件框架的设计中，需要考虑以下问题： 插件的职能与定义 插件（宿主也可视为插件）之间的关联 插件的管理 插件数据（插件文件以及插件产生的数据）管理 插件生命周期管理（包括启动机制和插件的启动销毁等） 插件升级管理 OSGi Wiki一个基于Java语言的服务（业务）规范——OSGi服务平台（Service Platform） 。Eclipse正是根据OSGi规范设计的插件体系。其规范设计值得推荐。 除了核心模块（框架），将其他所有功能模块都视为Bundle。Bundle之间可通过Service相互关联。 issueWebView资源找不到在5.0到6.x的系统（不完全统计）上，插件中使用WebView会遇到资源找不到的异常，经排查，需要将WebView的资源包也加载到插件的资源管理器中。值得一提的是，不同系统的WebView的包名可能不同，所以还需要先根据WebViewFactory.getWebViewPackageName()来获取包名。 颜色值错误宿主与插件的资源包中有同名颜色资源，其颜色值不同。发现运行插件的时候，布局文件背景中引用该颜色资源时，得到的是宿主的颜色值。后发现，在创建View的时候，解析属性时，使用了Resources.Theme来取值，因此需要促使Activity重新创建Resources.Theme。 动态更换皮肤采用替换资源的方式，还可实现动态更换皮肤。 Hook ResourcesManagerResourcesManager负责创建资源管理类，因此相比起Hook 资源管理类，Hook ResourcesManager，使其创建资源管理类时，在不同情况下，加载不同资源，似乎也是一个可行的方案。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"View触摸事件","slug":"Android/View/View触摸事件","date":"2018-06-28T16:00:00.000Z","updated":"2018-07-02T05:06:16.352Z","comments":true,"path":"2018/06/29/Android/View/View触摸事件/","link":"","permalink":"http://yoursite.com/2018/06/29/Android/View/View触摸事件/","excerpt":"","text":"View触摸事件模式默认的设计中，采用责任链模式，从根View开始，根据事件派发条件，在View树中满足条件的View之间形成一条自顶向下传递事件的事件处理链。 注：触摸事件来源于硬件层，以message的形式发送给应用层，传递到ViewRootImpl，从而派发给根View。如果根View是DecorView，DecorView会将事件派发给Window.Callback（Activity实现了此接口），后又流经Window回到DecorView.superDispatchTouchEvent()。这也是为什么Activity和Window也能拦截或处理事件。以上流程忽略了一些细节，实际流程会判断是否传递事件给Window.Callback等，而且不同版本的系统表现也可能不同。但整体流程上，仍然符合责任链模式，只是事件处理链上不只有View，为了简化描述，下文仍用View来指代事件处理者。 事件派发条件 在默认行为中，事件的派发往往基于该事件与View的位置关系，即事件应该只被派发到对应位置的View上。 对于一个View而言，事件不是相互独立的，以ACTION_DOWN作为起点，直到下一个ACTION_DOWN到来前的事件，可以看做一个事件序列。在一个事件序列中，接收并消费（直接消费或子View树消费）某个事件的所有前序事件，是一个View继续接收该事件的条件。 注：任何一个节点都可以打破这种默认行为，包括先预处理事件再向下派发、拦截事件向下派发、继续处理已被消费的事件等等。 具体细节事件接收方法boolean dispatchTouchEvent(MotionEvent event)是每个事件处理者接收事件的方法，其返回值表示事件是否已被消费。 事件处理细节View的dispatchTouchEvent(MotionEvent event)在View的实现中，会先将事件传递给OnTouchListener，如果未被消费，则调用onTouchEvent()，其中包含了对点击事件的识别与处理等。 OnTouchListener实际上是一个观察者，android 通过这个观察者给开发者提供了更优先的事件处理权限。当然，开发者也可以通过继承并复写onTouchEvent()甚至dispatchTouchEvent()的方式来实现更自由的事件处理。 123456789101112131415public boolean dispatchTouchEvent(MotionEvent event) &#123; //... ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; //... return result;&#125; ViewGroup的dispatchTouchEvent(MotionEvent event)ViewGroup本身作为布局控件，其主要作用是组织子控件，所以一般而言，其对事件的消费优先级要比子控件低。这也是为什么要先将事件传给子控件。 ViewGroup会先判断是否拦截事件。有两个判断依据： 外部可通过调用ViewGroup.requestDisallowInterceptTouchEvent(boolean disallowIntercept)来设置是否阻止ViewGroup拦截事件，默认是false，也就是ViewGroup默认是可拦截事件的。 如果外部没有阻止ViewGroup拦截事件，则通过自身的boolean onInterceptTouchEvent(MotionEvent ev)方法判断当前是否需要拦截事件。值得一提的是，一旦该方法返回true，后续事件不会再进行此判断，因为子View的事件序列已被结束，不会再接收事件，自然也就无需判断是否拦截。 如果没有子View符合派发事件的条件，就会调用super.dispatchTouchEvent()，也就是View的dispatchTouchEvent()方法，开始自身处理事件的过程。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]}]}